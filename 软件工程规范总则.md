# 软件工程规范总则

> **文档版本**：v1.0  
> **创建日期**：2025-12-26  
> **最后更新**：2025-12-26  
> **相关文档**：详见 [项目架构设计总览.md](./项目架构设计总览.md)

## 📋 目录

1. [核心编码原则](#一核心编码原则)
2. [C++编码规范](#二c编码规范)
3. [主线程阻塞问题规范](#三主线程阻塞问题规范)
4. [逻辑错误预防规范](#四逻辑错误预防规范)
5. [文档维护规范](#五文档维护规范)
6. [代码审查检查清单](#六代码审查检查清单)

---

## 一、核心编码原则

### 1.1 复用优先，但不过度设计

**核心原则：**
> **在写代码和文档时，尽量先检查是否已有模块/封装是否可用，避免重复造轮子。但也不要为了追求复用而增加复杂度。**
> 
> **⚠️ 关键判断：如果复用后反而增加了复杂度，就属于过度设计，应该直接实现。**

#### ✅ 应该做的：

- **先检查现有模块**：在实现新功能前，先搜索代码库，查看是否有可复用的模块
- **优先使用已有服务**：如 `PageManager`、`HttpService`、`LicenceService`、`SongService`、`HistoryService`、`M3u8DownloadService`、`InputService`、`PlayerService` 等
- **复用公共函数**：如 `create_title_bar`、`create_page_indicator`、`on_back_to_main` 等
- **使用开源库**：优先使用成熟的开源库（libcurl、cJSON、moodycamel::ConcurrentQueue、inih 等）

#### ❌ 不应该做的：

- **盲目创建新模块**：不检查现有代码就直接创建新函数/类
- **过度抽象**：为了复用而创建过于复杂的抽象层
- **强制复用**：如果复用会增加复杂度，应该直接实现，而不是强行复用
- **⚠️ 过度设计**：如果复用后反而增加了复杂度，就属于过度设计，必须避免

### 1.2 判断标准

**何时应该复用：**
- ✅ 现有模块功能完全匹配需求
- ✅ 现有模块可以轻松扩展以满足需求
- ✅ 复用不会显著增加代码复杂度
- ✅ 复用能减少代码重复（减少 > 20 行代码）

**何时不应该复用：**
- ❌ **复用后增加了复杂度**（这是过度设计的标志）
- ❌ 现有模块需要大量修改才能满足需求
- ❌ 复用会导致代码逻辑复杂、难以理解
- ❌ 复用需要创建复杂的适配层或包装器
- ❌ 需求与现有模块差异较大，强行复用反而增加维护成本
- ❌ 复用需要引入额外的依赖或间接调用

**⚠️ 核心判断标准：**
> **如果复用后代码变得更复杂、更难理解、更难维护，那就是过度设计，应该直接实现。**

### 1.3 检查清单

在实现新功能前，按以下顺序检查：

1. **检查现有服务类**
   - [ ] `HttpService` - HTTP 请求
   - [ ] `SongService` - 歌曲数据
   - [ ] `PlayerService` - 播放控制
   - [ ] `QueueService` - 播放队列
   - [ ] `HistoryService` - 历史记录
   - [ ] `LicenceService` - 许可证
   - [ ] `M3u8DownloadService` - 下载服务

2. **检查现有 UI 函数**
   - [ ] `create_title_bar` - 标题栏
   - [ ] `create_page_indicator` - 翻页指示器
   - [ ] `create_song_list_item` - 歌曲列表项
   - [ ] `on_back_to_main` - 返回主屏幕

3. **检查现有工具函数**
   - [ ] `setup_flex_row` / `setup_flex_col` - 布局设置
   - [ ] 样式初始化函数

4. **检查开源库**
   - [ ] libcurl - HTTP 请求
   - [ ] cJSON - JSON 解析
   - [ ] moodycamel::ConcurrentQueue - 队列
   - [ ] inih - 配置文件解析
   - [ ] plog - 日志

5. **评估复用成本（关键步骤）**
   - [ ] 复用是否简单直接？
   - [ ] **复用是否会增加复杂度？** ⚠️ 如果会，就是过度设计
   - [ ] 复用是否能减少代码重复？
   - [ ] **复用后的代码是否更容易理解？** ⚠️ 如果更难理解，就是过度设计
   - [ ] **复用后的代码是否更容易维护？** ⚠️ 如果更难维护，就是过度设计

---

## 二、C++编码规范

### 2.1 核心原则（预分配内存版本 + 简化设计）

#### 重要说明

**本项目采用预分配内存模式 + 简化设计 + 开源库优先**，所有内存在编译期或启动时预分配，**禁止动态内存分配**。

#### 简化设计原则

- ✅ **尽量少线程**：主线程处理UI和业务逻辑，最小化后台线程
- ✅ **尽量少状态机**：避免复杂状态机，使用简单状态枚举
- ✅ **尽量无锁**：单线程设计，避免锁竞争和死锁风险
- ✅ **尽量无状态结构**：函数式风格，最小化状态，减少状态管理复杂度
- ✅ **单例化**：页面和控件尽量单例化，避免重复创建
- ✅ **简化设计**：降低整体复杂度，减少资源泄露风险
- ✅ **避免造轮子**：严格遵循避免造轮子原则，优先使用开源库（libcurl、cJSON、moodycamel::ConcurrentQueue、inih等），低代码实现

### 2.2 现代C++标准（预分配版本）

- **使用C++11/14/17标准**，避免C风格代码
- **优先使用固定大小数组**：`std::array<T, N>`
- **禁止动态内存分配**：`new`/`delete`、`malloc`/`free`
- **使用静态存储**：页面实例使用静态存储
- **使用栈内存**：优先使用栈内存

### 2.3 禁止事项（避坑）

| ❌ 禁止 | ✅ 推荐 |
|---------|--------|
| `new`/`delete` | 静态实例或栈分配 |
| `malloc`/`free` | 静态实例或栈分配 |
| `std::make_unique`/`std::make_shared` | 静态实例 |
| `std::vector`（动态扩容） | `std::array<T, N>`（固定大小） |
| `std::string`（动态分配） | `char buffer[SIZE]` 或 `std::array<char, N>` |
| `std::deque`（动态分配） | `std::array<T, N>`（固定大小） |
| `std::unordered_map`（动态分配） | `std::array<T, N>`（固定大小） |
| 宏定义 `#define MAX 100` | `constexpr int MAX = 100` |
| 全局变量（可变） | 静态实例（单例模式） |

### 2.4 资源管理

#### 预分配内存使用

```cpp
// ❌ 错误：动态分配
void bad_example() {
    Page* page = new Page(PageType::HomeTab);  // 禁止！
    // ... 使用page
    delete page;  // 禁止！
}

// ✅ 正确：静态实例（预分配）
namespace {
    HomeTab g_home_tab;  // 静态存储，预分配
}

void good_example() {
    Page* page = &g_home_tab;  // 使用预分配的实例
    // ... 使用page
    // 无需释放，静态存储
}
```

#### RAII原则

```cpp
// ✅ 资源获取即初始化
class FileHandler {
public:
    FileHandler(const std::string& filename) 
        : file_(std::fopen(filename.c_str(), "r")) {
        if (!file_) {
            throw std::runtime_error("Failed to open file");
        }
    }
    
    ~FileHandler() {
        if (file_) {
            std::fclose(file_);
        }
    }
    
    // 禁止拷贝，允许移动
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
    FileHandler(FileHandler&&) noexcept = default;
    FileHandler& operator=(FileHandler&&) noexcept = default;
    
private:
    FILE* file_;
};
```

### 2.5 字符串处理

```cpp
// ❌ 错误：std::string（动态分配）
void bad_string2() {
    std::string name = "Hello";  // 禁止！动态分配
}

// ✅ 正确：固定大小字符数组
void good_string() {
    char name[256] = {0};  // 栈分配，固定大小
    strncpy(name, "Hello", sizeof(name) - 1);
}

// ✅ 正确：std::array<char, N>
void good_string2() {
    std::array<char, 256> name = {0};  // 栈分配，固定大小
    strncpy(name.data(), "Hello", name.size() - 1);
}
```

### 2.6 容器使用

```cpp
// ❌ 错误：动态容器
void bad_vector() {
    std::vector<int> arr;  // 禁止！动态分配
    arr.push_back(1);
}

// ✅ 正确：固定大小数组
void good_array() {
    std::array<int, 100> arr;  // 固定大小，预分配
    arr[0] = 1;
}

// ✅ 正确：固定大小数组（历史记录）
std::array<HistoryItem, 50> history_items;  // 预分配50条
```

### 2.7 命名规范

```cpp
// 类名：PascalCase
class PageManager { };
class HomeTab { };

// 函数名：camelCase
void switchToPage() { }
void getCurrentPage() { }

// 变量名：camelCase
int pageCount = 0;
std::string songName;

// 常量：UPPER_SNAKE_CASE
constexpr int MAX_HISTORY_COUNT = 50;
const std::string DEFAULT_PATH = "/data";

// 私有成员：下划线后缀
class Page {
private:
    PageType type_;
    lv_obj_t* container_;
};

// 命名空间：小写
namespace ktv {
    namespace ui {
        // ...
    }
}
```

### 2.8 代码组织

#### 头文件保护

```cpp
#ifndef PAGE_H
#define PAGE_H

// 头文件内容

#endif // PAGE_H

// ✅ 或使用#pragma once（更简洁）
#pragma once

// 头文件内容
```

#### 包含顺序

```cpp
// 1. 对应的头文件
#include "page.h"

// 2. C标准库
#include <cstdint>
#include <ctime>

// 3. C++标准库
#include <memory>
#include <vector>
#include <string>

// 4. 第三方库
#include <lvgl.h>
#include "cJSON.h"  // 开源库：JSON解析

// 5. 项目内其他头文件
#include "page_manager.h"
#include "models/song_item.h"
```

---

## 三、主线程阻塞问题规范

### 3.1 核心原则

> **主线程永远、永远、永远不能等待网络和磁盘**

### 3.2 违反的软件工程规范

#### 🚫 1. 主线程职责分离原则（UI Thread Responsibility Separation）

**规范定义**：
> 主线程（UI线程）只负责 UI 渲染和事件处理，不得执行任何耗时操作。

**违反内容**：
- 在主线程执行网络请求（`curl_easy_perform()`）
- 在主线程执行耗时初始化操作

**影响**：
- UI 无法响应，用户体验极差
- Windows 标记为"未响应"，窗口变灰

**修复措施**：
- ✅ 所有网络请求已移到后台线程
- ✅ 初始化流程已优化，UI 先显示

#### 🚫 2. 异步优先原则（Async-First Principle）

**规范定义**：
> 所有耗时操作（网络、IO、复杂计算）必须提供异步 API，优先使用异步方法。

**违反内容**：
- HttpService 只提供同步 API，没有异步版本
- 调用方被迫在主线程使用同步方法

**修复措施**：
- ✅ 新增 `HttpService::getAsync()` 和 `postAsync()` 方法
- ✅ 自动在后台线程执行，回调在 UI 线程

#### 🚫 3. 线程安全原则（Thread Safety）

**规范定义**：
> 多线程环境下，共享资源必须隔离或使用线程安全的访问方式。

**违反内容**：
- 全局复用单个 curl handle
- `curl_easy_perform()` 不是线程安全的

**修复措施**：
- ✅ 每次请求创建新的 curl handle（`createCurlHandle()`）
- ✅ 避免全局 handle 的线程竞争

#### 🚫 4. 初始化顺序原则（UI-First Principle）

**规范定义**：
> UI 必须先显示，耗时初始化在后台执行，不得阻塞 UI 显示。

**违反内容**：
- 在 UI 显示前执行网络请求
- 服务初始化阻塞主线程

**修复措施**：
- ✅ UI 先显示，服务初始化在后台执行
- ✅ 主循环立即启动

#### 🚫 5. 响应性原则（Responsiveness Principle）

**规范定义**：
> UI 必须在 100ms 内响应，主线程操作不得超过 16ms（60fps），超过 5 秒会被系统标记为"未响应"。

**违反内容**：
- 网络请求阻塞主线程 5-30 秒
- 主线程操作超过系统响应阈值

**修复措施**：
- ✅ 主线程不再阻塞
- ✅ 所有耗时操作在后台线程执行

### 3.3 高风险操作（必须移到后台线程）

| 操作类型 | 示例 | 阻塞时间 | 风险等级 |
|---------|------|---------|---------|
| **网络请求** | `HttpService::get()`, `HttpService::post()`, `curl_easy_perform()` | 1-30秒 | 🔴 极高 |
| **文件IO（大文件）** | `fread()`, `fwrite()`, `std::ifstream`, `std::ofstream` | 0.1-10秒 | 🟠 高 |
| **数据库操作** | SQL查询、事务 | 0.1-5秒 | 🟠 高 |
| **复杂计算** | 图像处理、JSON解析（大文件） | 0.1-5秒 | 🟡 中 |
| **系统调用** | `sleep()`, `usleep()`, `SDL_Delay(>100ms)` | 指定时间 | 🔴 极高 |

### 3.4 正确的初始化顺序

```cpp
int main() {
    // 1. 快速初始化（<100ms）
    lv_init();
    init_display();
    init_ui_theme();
    init_input();
    
    // 2. 服务初始化（快速部分）
    HttpService::initialize();
    TaskService::initialize();
    CacheService::initialize();
    
    // 3. 创建UI
    create_main_screen();
    lv_scr_load(screen);
    
    // 4. 启动主循环（立即开始）
    // 5. 后台初始化（不阻塞）
    TaskService::runAsync([&]() {
        // 所有耗时操作在这里
        getToken();
        getConfig();
    });
    
    // 主循环
    while (running) {
        sdl_handle_events();
        lv_timer_handler();
        SDL_Delay(5);
    }
}
```

### 3.5 异步操作模式

```cpp
// 模式1：后台执行 + UI回调
TaskService::getInstance().runAsync([data]() {
    // 后台线程：耗时操作
    auto result = processData(data);
    
    // 回到UI线程：更新界面
    TaskService::getInstance().runOnUIThread([result]() {
        updateUI(result);
    });
});

// 模式2：使用 HttpService 异步 API（推荐）
HttpService::getInstance().getAsync(url, [](bool ok, HttpResponse resp) {
    // 回调在UI线程执行，可以安全地更新UI
    if (ok) {
        updateUI(resp);
    }
});
```

---

## 四、逻辑错误预防规范

### 4.1 永远为真的条件（Always True Conditions）

#### ❌ 错误示例

```cpp
// 错误：条件永远为真
if (count <= 10 || count <= 3) {
    // 这个条件永远为真，因为 count <= 3 是 count <= 10 的子集
}
```

#### ✅ 正确写法

```cpp
// 正确：只保留一个条件
if (count <= 10) {
    // 前10次都执行
}

// 正确：如果需要不同的逻辑，使用明确的区间
if (count <= 3) {
    // 前3次执行
} else if (count <= 10) {
    // 第4-10次执行
}
```

### 4.2 永远为假的条件（Always False Conditions）

#### ❌ 错误示例

```cpp
// 错误：条件永远为假
if (x > 10 && x < 5) {
    // 不可能同时满足 x > 10 和 x < 5
}
```

#### ✅ 正确写法

```cpp
// 正确：使用合理的区间
if (x > 5 && x < 10) {
    // 5 < x < 10
}
```

### 4.3 条件重叠检查规则

| 条件组合 | 关系 | 结果 | 说明 |
|---------|------|------|------|
| `x <= 10 \|\| x <= 3` | 包含 | ❌ 永远为真 | 3 是 10 的子集 |
| `x >= 10 \|\| x >= 3` | 包含 | ❌ 永远为真 | 10 是 3 的子集 |
| `x <= 10 && x <= 3` | 交集 | ✅ 逻辑正确 | 等价于 `x <= 3` |
| `x > 10 && x < 5` | 矛盾 | ❌ 永远为假 | 不可能同时满足 |

### 4.4 冗余代码问题

#### ❌ 错误示例

```cpp
// 错误：重复调用
lv_obj_invalidate(scr);
printf("Screen invalidated...\n");
lv_obj_invalidate(scr);  // 冗余：刚刚已经调用过了
```

#### ✅ 正确写法

```cpp
// 正确：只调用一次
lv_obj_invalidate(scr);
printf("Screen invalidated...\n");
```

### 4.5 检查步骤

1. **识别条件类型**：`<=`, `>=`, `<`, `>`, `==`, `!=`
2. **检查包含关系**：较小的范围是否包含在较大的范围内
3. **检查逻辑运算符**：`||` 会放大范围，`&&` 会缩小范围
4. **验证数学关系**：确保条件组合在数学上合理

---

## 五、文档维护规范

### 5.1 核心原则

- ✅ **单一数据源**：每个主题只有一个权威文档
- ✅ **版本统一**：所有相关文档版本号保持一致
- ✅ **引用正确**：文档间引用必须准确、可访问
- ✅ **无冲突内容**：消除重复和冲突的描述

### 5.2 维护流程

每次生成或修改文档/代码时，必须执行以下步骤：

1. **检查现有文档**
   - 搜索相关主题的所有文档
   - 识别重复、冲突或过时内容

2. **合并和纠正**
   - 合并重复内容到单一文档
   - 纠正冲突和错误
   - 删除过时文档或标记为废弃

3. **更新引用**
   - 更新所有相关文档的引用链接
   - 确保文档索引准确

4. **验证一致性**
   - 检查版本号一致性
   - 验证代码示例与文档一致
   - 确保术语和概念统一

### 5.3 文档头部格式

所有文档必须包含以下头部信息：

```markdown
# 文档标题

> **文档版本**：vX.Y  
> **最后更新**：YYYY-MM-DD  
> **相关文档**：详见 [项目架构设计总览.md](./项目架构设计总览.md)  
> **主要文档**：详见 [相关文档名.md](./相关文档名.md)（如适用）
```

### 5.4 版本号规范

- **主版本号（X）**：重大架构变更
- **次版本号（Y）**：功能添加或重要更新
- **修订号（Z）**：小修复（可选）

示例：
- `v1.0` - 初始版本
- `v2.0` - 重大变更（如从智能指针版本改为预分配内存版本）
- `v2.1` - 添加新功能或重要更新

---

## 六、代码审查检查清单

### 6.1 编码规范检查

#### 预分配内存检查

- [ ] 是否禁止使用 `new`/`delete`？
- [ ] 是否禁止使用 `malloc`/`free`？
- [ ] 是否禁止使用 `std::vector`/`std::string` 等动态容器？
- [ ] 是否使用 `std::array` 替代动态容器？
- [ ] 是否使用固定大小字符数组替代 `std::string`？
- [ ] 是否使用静态实例（单例模式）？
- [ ] 是否优先使用栈内存？

#### 简化设计检查

- [ ] 是否禁止使用 `mutex`/`lock`（无锁设计）？
- [ ] 是否使用单线程设计？
- [ ] 是否避免复杂状态机（使用简单枚举）？
- [ ] 是否使用无状态函数（函数式风格）？

#### 代码质量检查

- [ ] 是否使用 `const` 正确性？
- [ ] 是否使用命名空间组织代码？
- [ ] 是否遵循命名规范？
- [ ] 是否使用头文件保护？

### 6.2 主线程阻塞检查

#### 🔴 P0 级别（必须修复）

- [ ] **主线程中是否有网络请求？**
  - 搜索：`HttpService::get(`, `HttpService::post(`, `curl_easy_perform`
  - 位置：`src/main.cpp` 和 UI 回调函数

- [ ] **主线程中是否有大文件IO？**
  - 搜索：`fread(`, `fwrite(`, `std::ifstream`, `std::ofstream`
  - 检查文件大小是否 > 10KB

- [ ] **主线程中是否有 sleep/delay？**
  - 搜索：`sleep(`, `usleep(`, `SDL_Delay(1000)`
  - 检查延迟时间是否 > 100ms

- [ ] **初始化顺序是否正确？**
  - UI 是否在耗时操作之前显示？
  - 主循环是否在服务初始化之后立即开始？

#### 🟠 P1 级别（建议修复）

- [ ] **是否有全局共享资源？**
  - 检查文件句柄、网络连接等是否全局共享
  - 确认多线程访问是否安全

- [ ] **服务类是否提供异步 API？**
  - 检查是否有 `Async` 后缀的方法
  - 同步方法是否有明确注释

- [ ] **是否有复杂计算在主线程？**
  - 检查 JSON 解析、图像处理等
  - 评估执行时间是否 > 16ms

### 6.3 逻辑错误检查

- [ ] **条件逻辑检查**
  - [ ] 所有 `if` 条件是否可能永远为真？
  - [ ] 所有 `if` 条件是否可能永远为假？
  - [ ] `||` 条件是否有重叠？
  - [ ] `&&` 条件是否矛盾？

- [ ] **冗余代码检查**
  - [ ] 是否有重复的函数调用？
  - [ ] 是否有重复的条件检查？
  - [ ] 是否有重复的变量赋值？

- [ ] **边界条件检查**
  - [ ] 边界值是否正确处理？
  - [ ] 空指针检查是否完整？
  - [ ] 数组越界是否检查？

### 6.4 复用检查

- [ ] **是否有重复实现？**
  - 检查是否有功能相似的代码
  - 是否可以提取公共函数

- [ ] **是否过度抽象/过度设计？**
  - 检查抽象层是否过于复杂
  - **检查复用后是否增加了复杂度** ⚠️ 这是判断过度设计的关键
  - 是否为了复用而增加了不必要的复杂度
  - 复用后的代码是否比直接实现更复杂？

- [ ] **是否使用了现有模块？**
  - 检查是否忽略了可用的服务类
  - 是否重复实现了已有功能

---

## 七、总结

### 7.1 核心原则总结

1. **复用优先，但不过度设计**
   - 先检查现有模块，避免重复造轮子
   - 如果复用后增加了复杂度，就是过度设计，必须避免

2. **预分配内存 + 简化设计**
   - 禁止动态内存分配
   - 单线程、无锁、简单状态、无状态结构

3. **主线程永远不阻塞**
   - 所有耗时操作在后台线程执行
   - UI 先显示，服务初始化在后台

4. **逻辑正确性**
   - 检查条件是否永远为真/假
   - 避免冗余代码

5. **文档一致性**
   - 单一数据源
   - 版本统一
   - 引用正确

### 7.2 关键记忆点

> **主线程永远、永远、永远不能等待网络和磁盘**

> **先检查现有模块，避免重复造轮子；但不要为了复用而增加复杂度。**

> **⚠️ 关键判断：如果复用后反而增加了复杂度，就属于过度设计，必须避免。**

---

## 八、相关资源

- [项目架构设计总览.md](./项目架构设计总览.md)
- [C++架构设计-预分配内存版本.md](./C++架构设计-预分配内存版本.md)
- [开源库选型指南.md](./开源库选型指南.md)
- [线程与事件系统设计.md](./线程与事件系统设计.md)
- [离线优先架构说明.md](./离线优先架构说明.md)

---

**最后更新**：2025-12-26  
**维护者**：开发团队  
**反馈渠道**：通过代码审查和 Issue 系统


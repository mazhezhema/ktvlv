# 输入设备与交互设计

> **文档版本**：v1.0  
> **相关文档**：详见 [项目架构设计总览.md](./项目架构设计总览.md)  
> **架构设计**：详见 [C++架构设计-预分配内存版本.md](./C++架构设计-预分配内存版本.md)  
> **UI设计**：详见 [MVP版本UI设计说明.md](./MVP版本UI设计说明.md)

## ⚠️ 核心需求

**输入设备支持：**
1. **触摸屏点击**：支持触摸屏直接点击操作
2. **HDMI智能TV遥控器操作**：支持通过遥控器按键操作（上下左右、确认、返回等）

### 核心原则

- ✅ **LVGL输入设备**：使用LVGL的输入设备接口
- ✅ **双输入支持**：同时支持触摸屏和遥控器
- ✅ **焦点导航**：遥控器操作时支持焦点导航
- ✅ **预分配内存**：输入设备缓冲区预分配
- ✅ **单线程设计**：输入事件在主线程处理

---

## 一、设计概述

### 1.1 输入设备架构

```
┌─────────────────────────────────────────┐
│  输入设备层                              │
│  - 触摸屏（Touchscreen）                 │
│  - 遥控器（Remote Control / Keyboard）  │
└─────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────┐
│  LVGL输入设备驱动                        │
│  - lv_indev_drv_t（输入设备驱动）        │
│  - lv_indev_t（输入设备实例）            │
└─────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────┐
│  LVGL事件处理                            │
│  - 触摸事件（LV_EVENT_PRESSED等）        │
│  - 按键事件（LV_KEY_UP/DOWN/LEFT/RIGHT）│
└─────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────┐
│  UI层（页面和控件）                      │
│  - 响应触摸点击                          │
│  - 响应遥控器按键                        │
└─────────────────────────────────────────┘
```

### 1.2 输入设备类型

**1. 触摸屏（Touchscreen）**
- 输入类型：`LV_INDEV_TYPE_POINTER`
- 事件：点击、长按、滑动
- 直接操作：点击控件直接触发

**2. 遥控器（Remote Control）**
- 输入类型：`LV_INDEV_TYPE_KEYPAD` 或 `LV_INDEV_TYPE_ENCODER`
- 按键：上下左右、确认、返回、菜单等
- 焦点导航：通过方向键移动焦点，确认键触发

---

## 二、输入设备服务设计

### 2.1 InputDeviceService（单例，预分配版本）

```cpp
#ifndef INPUT_DEVICE_SERVICE_H
#define INPUT_DEVICE_SERVICE_H

#include <lvgl.h>
#include <array>
#include <cstdint>

namespace ktv {

/**
 * 输入设备类型枚举
 */
enum class InputDeviceType : uint8_t {
    Touchscreen = 0,  // 触摸屏
    RemoteControl     // 遥控器
};

/**
 * 输入设备服务（单例，预分配版本，无锁设计）
 */
class InputDeviceService {
public:
    static InputDeviceService& getInstance() {
        static InputDeviceService instance;
        return instance;
    }
    
    InputDeviceService(const InputDeviceService&) = delete;
    InputDeviceService& operator=(const InputDeviceService&) = delete;
    
    // 初始化输入设备
    bool initialize();
    
    // 注册触摸屏设备
    bool registerTouchscreen(const char* device_path);
    
    // 注册遥控器设备（键盘输入）
    bool registerRemoteControl(const char* device_path);
    
    // 获取当前活动的输入设备类型
    InputDeviceType getActiveDeviceType() const { return active_device_type_; }
    
    // 设置焦点导航模式（遥控器操作时）
    void setFocusNavigationEnabled(bool enabled);
    
    // 检查是否启用焦点导航
    bool isFocusNavigationEnabled() const { return focus_navigation_enabled_; }
    
    // 处理输入事件（在主循环中调用）
    void processInputEvents();
    
    // 清理
    void cleanup();
    
private:
    InputDeviceService() = default;
    ~InputDeviceService() = default;
    
    InputDeviceType active_device_type_ = InputDeviceType::Touchscreen;
    bool focus_navigation_enabled_ = false;
    
    // LVGL输入设备实例
    lv_indev_t* touchscreen_indev_ = nullptr;
    lv_indev_t* remote_indev_ = nullptr;
    
    // 触摸屏数据（预分配）
    lv_indev_drv_t touchscreen_drv_;
    lv_point_t touch_point_ = {0, 0};
    bool touch_pressed_ = false;
    
    // 遥控器数据（预分配）
    lv_indev_drv_t remote_drv_;
    uint32_t last_key_ = 0;
    
    // 输入设备文件描述符（Linux）
    int touchscreen_fd_ = -1;
    int remote_fd_ = -1;
    
    // 触摸屏读取回调
    static void touchscreenRead(lv_indev_drv_t* indev_drv, lv_indev_data_t* data);
    
    // 遥控器读取回调
    static void remoteRead(lv_indev_drv_t* indev_drv, lv_indev_data_t* data);
    
    // 按键编码（Linux输入事件）
    static uint32_t encodeKey(uint32_t linux_key);
    
    // 禁止动态分配
    void* operator new(size_t) = delete;
    void* operator new[](size_t) = delete;
    void operator delete(void*) = delete;
    void operator delete[](void*) = delete;
};

} // namespace ktv

#endif // INPUT_DEVICE_SERVICE_H
```

### 2.2 InputDeviceService实现

```cpp
#include "input_device_service.h"
#include <fcntl.h>
#include <unistd.h>
#include <linux/input.h>
#include <cstring>

namespace ktv {

bool InputDeviceService::initialize() {
    // 初始化LVGL输入设备驱动
    // 触摸屏和遥控器可以同时注册
    
    return true;
}

bool InputDeviceService::registerTouchscreen(const char* device_path) {
    // 打开触摸屏设备文件
    touchscreen_fd_ = open(device_path, O_RDONLY);
    if (touchscreen_fd_ < 0) {
        return false;
    }
    
    // 初始化LVGL触摸屏驱动
    lv_indev_drv_init(&touchscreen_drv_);
    touchscreen_drv_.type = LV_INDEV_TYPE_POINTER;
    touchscreen_drv_.read_cb = touchscreenRead;
    touchscreen_drv_.user_data = this;
    
    // 注册输入设备
    touchscreen_indev_ = lv_indev_drv_register(&touchscreen_drv_);
    if (!touchscreen_indev_) {
        close(touchscreen_fd_);
        touchscreen_fd_ = -1;
        return false;
    }
    
    return true;
}

bool InputDeviceService::registerRemoteControl(const char* device_path) {
    // 打开遥控器设备文件（通常是键盘输入设备）
    remote_fd_ = open(device_path, O_RDONLY);
    if (remote_fd_ < 0) {
        return false;
    }
    
    // 初始化LVGL遥控器驱动
    lv_indev_drv_init(&remote_drv_);
    remote_drv_.type = LV_INDEV_TYPE_KEYPAD;  // 或 LV_INDEV_TYPE_ENCODER
    remote_drv_.read_cb = remoteRead;
    remote_drv_.user_data = this;
    
    // 注册输入设备
    remote_indev_ = lv_indev_drv_register(&remote_drv_);
    if (!remote_indev_) {
        close(remote_fd_);
        remote_fd_ = -1;
        return false;
    }
    
    // 启用焦点导航（遥控器操作时）
    setFocusNavigationEnabled(true);
    
    return true;
}

void InputDeviceService::setFocusNavigationEnabled(bool enabled) {
    focus_navigation_enabled_ = enabled;
    
    if (remote_indev_) {
        // 设置焦点导航组（如果需要）
        // lv_group_t* group = lv_group_create();
        // lv_indev_set_group(remote_indev_, group);
    }
}

void InputDeviceService::processInputEvents() {
    // LVGL会自动调用read_cb回调读取输入事件
    // 这里可以处理额外的输入事件逻辑
}

void InputDeviceService::touchscreenRead(lv_indev_drv_t* indev_drv, lv_indev_data_t* data) {
    InputDeviceService* service = static_cast<InputDeviceService*>(indev_drv->user_data);
    
    // 读取触摸屏输入事件（Linux输入子系统）
    struct input_event ev;
    ssize_t n = read(service->touchscreen_fd_, &ev, sizeof(ev));
    
    if (n < 0) {
        data->state = LV_INDEV_STATE_RELEASED;
        return;
    }
    
    // 处理触摸事件
    if (ev.type == EV_ABS) {
        if (ev.code == ABS_X) {
            service->touch_point_.x = ev.value;
        } else if (ev.code == ABS_Y) {
            service->touch_point_.y = ev.value;
        }
    } else if (ev.type == EV_KEY) {
        if (ev.code == BTN_TOUCH) {
            service->touch_pressed_ = (ev.value == 1);
        }
    }
    
    // 更新LVGL输入数据
    data->point.x = service->touch_point_.x;
    data->point.y = service->touch_point_.y;
    data->state = service->touch_pressed_ ? LV_INDEV_STATE_PRESSED : LV_INDEV_STATE_RELEASED;
    
    // 更新活动设备类型
    if (service->touch_pressed_) {
        service->active_device_type_ = InputDeviceType::Touchscreen;
        service->setFocusNavigationEnabled(false);  // 触摸屏操作时禁用焦点导航
    }
}

void InputDeviceService::remoteRead(lv_indev_drv_t* indev_drv, lv_indev_data_t* data) {
    InputDeviceService* service = static_cast<InputDeviceService*>(indev_drv->user_data);
    
    // 读取遥控器输入事件（Linux输入子系统）
    struct input_event ev;
    ssize_t n = read(service->remote_fd_, &ev, sizeof(ev));
    
    if (n < 0) {
        data->state = LV_INDEV_STATE_RELEASED;
        return;
    }
    
    // 处理按键事件
    if (ev.type == EV_KEY && ev.value == 1) {  // 按键按下
        uint32_t lv_key = encodeKey(ev.code);
        if (lv_key != 0) {
            service->last_key_ = lv_key;
            data->key = lv_key;
            data->state = LV_INDEV_STATE_PRESSED;
            
            // 更新活动设备类型
            service->active_device_type_ = InputDeviceType::RemoteControl;
            service->setFocusNavigationEnabled(true);  // 遥控器操作时启用焦点导航
        }
    } else {
        data->state = LV_INDEV_STATE_RELEASED;
    }
}

uint32_t InputDeviceService::encodeKey(uint32_t linux_key) {
    // 将Linux输入事件键码转换为LVGL键码
    switch (linux_key) {
        case KEY_UP:
            return LV_KEY_UP;
        case KEY_DOWN:
            return LV_KEY_DOWN;
        case KEY_LEFT:
            return LV_KEY_LEFT;
        case KEY_RIGHT:
            return LV_KEY_RIGHT;
        case KEY_ENTER:
        case KEY_OK:
            return LV_KEY_ENTER;
        case KEY_ESC:
        case KEY_BACK:
            return LV_KEY_ESC;
        case KEY_MENU:
            return LV_KEY_NEXT;
        case KEY_HOME:
            return LV_KEY_HOME;
        default:
            return 0;
    }
}

void InputDeviceService::cleanup() {
    if (touchscreen_fd_ >= 0) {
        close(touchscreen_fd_);
        touchscreen_fd_ = -1;
    }
    
    if (remote_fd_ >= 0) {
        close(remote_fd_);
        remote_fd_ = -1;
    }
    
    // LVGL会自动清理输入设备
    touchscreen_indev_ = nullptr;
    remote_indev_ = nullptr;
}

} // namespace ktv
```

---

## 三、焦点导航设计

### 3.1 焦点导航组（遥控器操作）

```cpp
// 为遥控器输入设备创建焦点导航组
lv_group_t* remote_group = lv_group_create();
lv_indev_set_group(remote_indev_, remote_group);

// 将可聚焦的控件添加到组中
void addFocusableWidget(lv_obj_t* obj) {
    lv_group_add_obj(remote_group, obj);
}

// 设置焦点样式
void setupFocusStyle() {
    static lv_style_t focus_style;
    lv_style_init(&focus_style);
    lv_style_set_border_color(&focus_style, lv_color_hex(0x00FF00));  // 绿色边框
    lv_style_set_border_width(&focus_style, 2);
    lv_style_set_outline_color(&focus_style, lv_color_hex(0x00FF00));
    lv_style_set_outline_width(&focus_style, 2);
    
    // 应用到组
    lv_group_set_style(remote_group, &focus_style, LV_GROUP_STYLE_FOCUS);
}
```

### 3.2 页面焦点管理

```cpp
// 页面基类添加焦点管理
class BasePage {
protected:
    lv_group_t* focus_group_ = nullptr;
    
public:
    virtual void onShow() {
        // 页面显示时，设置焦点组
        if (InputDeviceService::getInstance().isFocusNavigationEnabled()) {
            if (!focus_group_) {
                focus_group_ = lv_group_create();
            }
            lv_indev_set_group(remote_indev_, focus_group_);
        }
    }
    
    virtual void onHide() {
        // 页面隐藏时，清理焦点组
        if (focus_group_) {
            lv_group_remove_all_objs(focus_group_);
        }
    }
    
    // 添加可聚焦控件
    void addFocusableWidget(lv_obj_t* obj) {
        if (focus_group_) {
            lv_group_add_obj(focus_group_, obj);
        }
    }
};
```

---

## 四、UI控件适配

### 4.1 按钮控件（同时支持触摸和遥控器）

```cpp
// 创建按钮（自动支持触摸和遥控器）
lv_obj_t* createButton(lv_obj_t* parent, const char* text) {
    lv_obj_t* btn = lv_btn_create(parent);
    lv_obj_t* label = lv_label_create(btn);
    lv_label_set_text(label, text);
    
    // 添加到焦点组（遥控器操作）
    if (InputDeviceService::getInstance().isFocusNavigationEnabled()) {
        // 通过页面管理器添加到焦点组
        PageManager::getInstance().addFocusableWidget(btn);
    }
    
    // 设置点击事件（触摸和遥控器确认键都会触发）
    lv_obj_add_event_cb(btn, onButtonClicked, LV_EVENT_CLICKED, nullptr);
    
    return btn;
}

// 按钮点击事件处理
void onButtonClicked(lv_event_t* e) {
    lv_obj_t* btn = lv_event_get_target(e);
    // 处理按钮点击逻辑
}
```

### 4.2 列表控件（支持遥控器导航）

```cpp
// 创建列表（支持遥控器上下导航）
lv_obj_t* createList(lv_obj_t* parent) {
    lv_obj_t* list = lv_list_create(parent);
    
    // 添加到焦点组
    if (InputDeviceService::getInstance().isFocusNavigationEnabled()) {
        PageManager::getInstance().addFocusableWidget(list);
    }
    
    // 设置列表项点击事件
    lv_obj_add_event_cb(list, onListItemClicked, LV_EVENT_CLICKED, nullptr);
    
    return list;
}

// 添加列表项
lv_obj_t* addListItem(lv_obj_t* list, const char* text) {
    lv_obj_t* item = lv_list_add_btn(list, LV_SYMBOL_FILE, text);
    
    // 列表项自动支持焦点导航
    return item;
}
```

---

## 五、应用初始化

### 5.1 主函数初始化

```cpp
#include "input_device_service.h"
#include <lvgl.h>

int main() {
    // 初始化LVGL
    lv_init();
    
    // 初始化显示驱动（framebuffer）
    // ... 显示初始化代码 ...
    
    // 初始化输入设备服务
    InputDeviceService& input_service = InputDeviceService::getInstance();
    input_service.initialize();
    
    // 注册触摸屏设备
    // 触摸屏设备路径：通常是 /dev/input/event0 或 /dev/input/touchscreen0
    if (!input_service.registerTouchscreen("/dev/input/event0")) {
        // 触摸屏注册失败，继续使用遥控器
        printf("Touchscreen not found, using remote control only\n");
    }
    
    // 注册遥控器设备
    // 遥控器设备路径：通常是 /dev/input/event1 或 /dev/input/remote0
    if (!input_service.registerRemoteControl("/dev/input/event1")) {
        // 遥控器注册失败，继续使用触摸屏
        printf("Remote control not found, using touchscreen only\n");
    }
    
    // 初始化页面管理器
    PageManager::getInstance().initialize();
    
    // 主循环
    while (1) {
        lv_timer_handler();  // LVGL定时器处理（包括输入事件）
        usleep(5000);
    }
    
    // 清理
    input_service.cleanup();
    
    return 0;
}
```

---

## 六、输入设备检测

### 6.1 自动检测输入设备

```cpp
// 自动检测可用的输入设备
bool autoDetectInputDevices() {
    InputDeviceService& input_service = InputDeviceService::getInstance();
    input_service.initialize();
    
    // 尝试检测触摸屏设备
    const char* touchscreen_paths[] = {
        "/dev/input/event0",
        "/dev/input/event1",
        "/dev/input/touchscreen0",
        "/dev/input/touchscreen1",
        nullptr
    };
    
    for (int i = 0; touchscreen_paths[i]; ++i) {
        if (input_service.registerTouchscreen(touchscreen_paths[i])) {
            printf("Touchscreen found: %s\n", touchscreen_paths[i]);
            break;
        }
    }
    
    // 尝试检测遥控器设备
    const char* remote_paths[] = {
        "/dev/input/event1",
        "/dev/input/event2",
        "/dev/input/remote0",
        "/dev/input/keyboard0",
        nullptr
    };
    
    for (int i = 0; remote_paths[i]; ++i) {
        if (input_service.registerRemoteControl(remote_paths[i])) {
            printf("Remote control found: %s\n", remote_paths[i]);
            break;
        }
    }
    
    return true;
}
```

### 6.2 输入设备配置文件

```ini
# /data/ktv_input.conf
[touchscreen]
enabled = true
device_path = /dev/input/event0

[remote_control]
enabled = true
device_path = /dev/input/event1
focus_navigation = true
```

---

## 七、遥控器按键映射

### 7.1 标准遥控器按键

| 遥控器按键 | Linux键码 | LVGL键码 | 功能 |
|-----------|----------|---------|------|
| 上 | KEY_UP | LV_KEY_UP | 焦点上移 |
| 下 | KEY_DOWN | LV_KEY_DOWN | 焦点下移 |
| 左 | KEY_LEFT | LV_KEY_LEFT | 焦点左移 |
| 右 | KEY_RIGHT | LV_KEY_RIGHT | 焦点右移 |
| 确认/OK | KEY_ENTER/KEY_OK | LV_KEY_ENTER | 触发点击事件 |
| 返回 | KEY_ESC/KEY_BACK | LV_KEY_ESC | 返回上一页 |
| 菜单 | KEY_MENU | LV_KEY_NEXT | 打开菜单 |
| 主页 | KEY_HOME | LV_KEY_HOME | 返回主页 |

### 7.2 自定义按键映射

```cpp
// 自定义按键映射（根据实际遥控器调整）
uint32_t InputDeviceService::encodeKey(uint32_t linux_key) {
    // 可以根据配置文件或实际遥控器调整映射
    switch (linux_key) {
        case KEY_UP:
            return LV_KEY_UP;
        case KEY_DOWN:
            return LV_KEY_DOWN;
        case KEY_LEFT:
            return LV_KEY_LEFT;
        case KEY_RIGHT:
            return LV_KEY_RIGHT;
        case KEY_ENTER:
        case KEY_OK:
        case KEY_SELECT:  // 某些遥控器使用SELECT键
            return LV_KEY_ENTER;
        case KEY_ESC:
        case KEY_BACK:
        case KEY_EXIT:  // 某些遥控器使用EXIT键
            return LV_KEY_ESC;
        case KEY_MENU:
        case KEY_SETUP:  // 某些遥控器使用SETUP键
            return LV_KEY_NEXT;
        case KEY_HOME:
            return LV_KEY_HOME;
        default:
            return 0;
    }
}
```

---

## 八、使用示例

### 8.1 页面切换（支持触摸和遥控器）

```cpp
// 首页按钮点击（触摸或遥控器确认键）
void onHomeButtonClicked(lv_event_t* e) {
    PageManager::getInstance().switchTo(PageType::HomeTab);
}

// 历史记录按钮点击
void onHistoryButtonClicked(lv_event_t* e) {
    PageManager::getInstance().switchTo(PageType::HistoryTab);
}

// 创建顶部菜单栏（支持触摸和遥控器）
void createTopMenuBar(lv_obj_t* parent) {
    lv_obj_t* home_btn = createButton(parent, "首页");
    lv_obj_add_event_cb(home_btn, onHomeButtonClicked, LV_EVENT_CLICKED, nullptr);
    
    lv_obj_t* history_btn = createButton(parent, "历史记录");
    lv_obj_add_event_cb(history_btn, onHistoryButtonClicked, LV_EVENT_CLICKED, nullptr);
    
    // 添加到焦点组（遥控器操作）
    PageManager::getInstance().addFocusableWidget(home_btn);
    PageManager::getInstance().addFocusableWidget(history_btn);
}
```

### 8.2 歌曲列表（支持触摸和遥控器）

```cpp
// 创建歌曲列表（支持触摸点击和遥控器选择）
void createSongList(lv_obj_t* parent) {
    lv_obj_t* list = lv_list_create(parent);
    
    // 添加歌曲项
    for (size_t i = 0; i < song_count; ++i) {
        lv_obj_t* item = lv_list_add_btn(list, LV_SYMBOL_AUDIO, songs[i].name);
        
        // 设置点击事件（触摸和遥控器确认键）
        lv_obj_add_event_cb(item, onSongItemClicked, LV_EVENT_CLICKED, &songs[i]);
        
        // 添加到焦点组（遥控器操作）
        PageManager::getInstance().addFocusableWidget(item);
    }
}
```

---

## 九、总结

### 9.1 核心组件

1. **InputDeviceService**：输入设备管理服务（单例，预分配版本）
2. **触摸屏支持**：LVGL指针输入设备（`LV_INDEV_TYPE_POINTER`）
3. **遥控器支持**：LVGL按键输入设备（`LV_INDEV_TYPE_KEYPAD`）
4. **焦点导航**：遥控器操作时的焦点管理

### 9.2 技术要点

- ✅ **使用LVGL输入设备接口**：标准输入设备驱动
- ✅ **Linux输入子系统**：读取`/dev/input/event*`设备
- ✅ **双输入支持**：同时支持触摸屏和遥控器
- ✅ **焦点导航**：遥控器操作时自动焦点管理
- ✅ **预分配内存**：输入设备缓冲区预分配
- ✅ **单线程设计**：输入事件在主线程处理

### 9.3 输入设备路径

**触摸屏：**
- `/dev/input/event0`（常见）
- `/dev/input/touchscreen0`（某些平台）

**遥控器：**
- `/dev/input/event1`（常见）
- `/dev/input/remote0`（某些平台）
- `/dev/input/keyboard0`（键盘输入）

---

**总结**：输入设备系统支持触摸屏点击和HDMI智能TV遥控器操作。使用LVGL输入设备接口，Linux输入子系统读取设备事件，同时支持两种输入方式，遥控器操作时自动启用焦点导航。


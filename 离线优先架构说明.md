# 离线优先架构说明

## 概述

应用采用**离线优先（Offline-First）**架构，确保应用在离线状态下也能正常使用，联网后自动更新数据并保存到本地缓存。

## 核心原则

1. **离线是正常状态**：应用默认可以在不联网的情况下运行
2. **默认数据填充**：首次启动时，即使不联网，也有默认数据填充到UI控件
3. **联网自动更新**：联网后从服务器更新列表、图片、歌手等信息
4. **数据持久化**：更新后的数据保存到本地，离线时也能使用

## 架构组件

### 1. CacheService（缓存服务）

**位置**：`src/services/cache_service.h` / `cache_service.cpp`

**职责**：
- 管理本地数据缓存（JSON格式）
- 提供数据的保存和加载接口
- 自动创建和管理缓存目录

**主要方法**：
- `initialize(cache_dir)`: 初始化缓存目录
- `saveSongs(key, songs)`: 保存歌曲列表到缓存
- `loadSongs(key)`: 从缓存加载歌曲列表
- `hasCache(key)`: 检查缓存是否存在
- `clearCache(key)`: 清除指定缓存

**缓存文件位置**：`cache/` 目录（项目根目录下）

**缓存文件命名**：
- 歌曲列表：`songs_page_{page}_size_{size}.json`
- 搜索结果：`search_{keyword}_page_{page}_size_{size}.json`

### 2. SongService（歌曲服务）扩展

**位置**：`src/services/song_service.h` / `song_service.cpp`

**新增方法**：
- `listSongsOfflineFirst(page, size)`: 离线优先获取歌曲列表
- `searchOfflineFirst(keyword, page, size)`: 离线优先搜索

**工作流程**：
```
1. 先尝试从缓存加载数据
2. 如果缓存存在，立即返回缓存数据（不阻塞）
3. 后台尝试联网更新
4. 如果联网成功，更新缓存并返回新数据
5. 如果联网失败，继续使用缓存数据（如果有）
6. 如果缓存和联网都失败，返回空列表（UI层会使用Mock数据）
```

### 3. SongItem 数据模型扩展

**新增字段**：
- `cover_url`: 封面图片URL
- `artist_image_url`: 歌手图片URL
- `album`: 专辑名称
- `duration`: 时长（秒）

**兼容性**：
- 保留了原有的构造函数，确保旧代码兼容
- 新字段在JSON解析时自动填充（如果服务器返回）

### 4. UI层改造

**首页（show_home_tab）**：
```cpp
// 1. 先尝试从缓存或联网加载
std::vector<SongItem> songs = song_service.listSongsOfflineFirst(1, 20);

// 2. 如果失败，使用Mock数据作为默认数据
if (songs.empty()) {
    // 使用Mock数据填充
}
```

**搜索页（show_search_page）**：
```cpp
// 1. 先尝试从缓存或联网搜索
std::vector<SongItem> results = song_service.searchOfflineFirst(keyword, 1, 20);

// 2. 如果失败，从Mock数据搜索
if (results.empty() && !keyword.empty()) {
    // 使用Mock数据搜索
}
```

**历史记录页（show_history_tab）**：
- 优先从 `HistoryService` 加载（这是本地数据）
- 如果没有历史记录，使用Mock数据作为默认显示

## 数据流程

### 首次启动（离线）

```
启动 → 初始化CacheService → 检查缓存 → 无缓存
  → UI使用Mock数据填充 → 显示默认歌曲列表
```

### 首次启动（联网）

```
启动 → 初始化CacheService → 检查缓存 → 无缓存
  → UI使用Mock数据填充（立即显示）
  → 后台调用listSongsOfflineFirst
    → 联网请求成功 → 保存到缓存 → 更新UI
```

### 后续启动（有缓存）

```
启动 → 初始化CacheService → 检查缓存 → 有缓存
  → 立即加载缓存数据 → 显示缓存歌曲列表
  → 后台尝试联网更新
    → 联网成功 → 更新缓存 → 刷新UI
    → 联网失败 → 继续使用缓存数据
```

## 初始化流程

在 `main.cpp` 中：

```cpp
// 1. 初始化缓存服务
if (!CacheService::getInstance().initialize("cache")) {
    PLOGW << "Failed to initialize cache service";
}

// 2. 设置SongService的网络配置
SongService::getInstance().setNetworkConfig(net_cfg);

// 3. UI层自动使用离线优先方法
```

## 缓存文件格式

缓存文件使用JSON格式，示例：

```json
[
  {
    "id": "song_001",
    "title": "红日",
    "artist": "李克勤",
    "m3u8_url": "https://example.com/song.m3u8",
    "cover_url": "https://example.com/cover.jpg",
    "artist_image_url": "https://example.com/artist.jpg",
    "album": "红日专辑",
    "duration": 240
  }
]
```

## Mock数据

**位置**：`src/services/mock_data.h` / `mock_data.cpp`

**作用**：
- 作为离线时的默认数据
- 首次启动时，如果缓存和联网都失败，使用Mock数据填充UI
- 确保应用在任何情况下都能正常显示

**数据内容**：
- 热门歌曲列表（8首）
- 历史记录列表（5首）
- 搜索功能（基于热门歌曲列表）

## 优势

1. **用户体验**：应用启动即可使用，无需等待网络请求
2. **离线可用**：完全支持离线使用，联网后自动更新
3. **数据持久化**：更新后的数据保存到本地，下次启动自动加载
4. **降级策略**：缓存失败 → Mock数据，确保UI始终有数据
5. **性能优化**：优先使用本地缓存，减少网络请求

## 未来扩展

1. **图片缓存**：下载并缓存封面图片、歌手图片到本地
2. **增量更新**：只更新变化的数据，减少网络流量
3. **缓存过期**：设置缓存有效期，自动刷新过期数据
4. **后台同步**：定期在后台同步数据，保持缓存最新
5. **数据压缩**：压缩缓存文件，节省存储空间

## 注意事项

1. **缓存目录**：确保应用有权限创建和写入 `cache/` 目录
2. **文件系统**：使用C++17的 `std::filesystem`，需要编译器支持
3. **线程安全**：当前实现是单线程的，如果未来需要多线程，需要添加锁
4. **缓存清理**：可以调用 `CacheService::clearAllCache()` 清除所有缓存

## 测试建议

### 离线模式测试
1. 断开网络连接
2. 删除 `cache/` 目录
3. 启动应用
4. 验证：应用正常启动，显示Mock数据

### 联网模式测试
1. 连接网络
2. 删除 `cache/` 目录
3. 启动应用
4. 验证：先显示Mock数据，然后自动更新为服务器数据

### 缓存模式测试
1. 联网启动一次应用（生成缓存）
2. 断开网络
3. 重新启动应用
4. 验证：应用加载缓存数据，正常显示

---

**实现日期**：2024年
**状态**：✅ 已完成


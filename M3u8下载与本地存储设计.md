# M3u8下载与本地存储设计

> **文档版本**：v1.0  
> **相关文档**：详见 [项目架构设计总览.md](./项目架构设计总览.md)  
> **架构设计**：详见 [C++架构设计-预分配内存版本.md](./C++架构设计-预分配内存版本.md)  
> **开源库选型**：详见 [开源库选型指南.md](./开源库选型指南.md)

## ⚠️ 核心需求

**播放流程：**
1. 播放器从服务器获取到m3u8的url后，**直接播放**（不等待下载）
2. **后台**把m3u8转成ts，存储在本地的hash目录下
3. 变成用户的历史记录（包含本地文件路径）
4. 暂时最多50首，超过就删除最早一首（包括删除本地文件）

### 核心原则

- ✅ **避免造轮子**：严格遵循避免造轮子原则，优先使用开源库
- ✅ **GitHub Stars多**：优先选择star数多的库
- ✅ **更新频次近**：优先选择最近有更新的库
- ✅ **预分配内存**：使用固定大小缓冲区
- ✅ **单线程设计**：后台下载在单独线程，但使用无锁消息队列通信
- ✅ **使用libcurl**：下载m3u8和ts文件（已有，避免造轮子）
- ✅ **简单m3u8解析**：文本格式，易于解析（避免专门的HLS库）

### 核心原则

- ✅ **避免造轮子**：严格遵循避免造轮子原则，优先使用开源库
- ✅ **GitHub Stars多**：优先选择star数多的库
- ✅ **更新频次近**：优先选择最近有更新的库
- ✅ **预分配内存**：使用固定大小缓冲区
- ✅ **单线程设计**：后台下载在单独线程，但使用无锁消息队列通信

---

## 一、设计概述

### 1.1 工作流程

```
┌─────────────────────────────────────────┐
│  播放器获取m3u8 URL                      │
└─────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────┐
│  直接播放（TPlayer）                     │
│  - TPlayerSetDataSource(m3u8_url)       │
│  - TPlayerStart()                        │
└─────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────┐
│  后台下载服务（M3u8DownloadService）     │
│  - 解析m3u8文件                          │
│  - 下载所有ts片段                        │
│  - 存储到本地hash目录                    │
│  - 生成本地m3u8文件（可选）              │
└─────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────┐
│  历史记录服务（HistoryService）          │
│  - 添加记录（包含本地文件路径）          │
│  - 如果超过50首，删除最早一首的文件      │
└─────────────────────────────────────────┘
```

### 1.2 存储结构

```
/data/ktv_cache/
├── hash1/              # song_id的hash值
│   ├── playlist.m3u8  # 原始m3u8文件
│   ├── segment_0.ts    # ts片段0
│   ├── segment_1.ts    # ts片段1
│   └── ...            # 其他ts片段
├── hash2/
│   └── ...
└── ...
```

---

## 二、M3u8下载服务设计

### 2.1 M3u8DownloadService（单例，预分配版本）

```cpp
#ifndef M3U8_DOWNLOAD_SERVICE_H
#define M3U8_DOWNLOAD_SERVICE_H

#include "http_service.h"  // 使用libcurl
#include <array>
#include <cstdint>

namespace ktv {

/**
 * M3u8下载服务（单例，预分配版本，无锁设计）
 * 后台下载m3u8和ts文件，存储到本地
 */
class M3u8DownloadService {
public:
    static M3u8DownloadService& getInstance() {
        static M3u8DownloadService instance;
        return instance;
    }
    
    M3u8DownloadService(const M3u8DownloadService&) = delete;
    M3u8DownloadService& operator=(const M3u8DownloadService&) = delete;
    
    // 初始化
    bool initialize();
    
    // 开始下载m3u8（异步，后台线程）
    bool startDownload(const char* song_id, const char* m3u8_url);
    
    // 停止下载
    void stopDownload(const char* song_id);
    
    // 获取下载状态
    enum class DownloadStatus : uint8_t {
        Idle,
        Downloading,
        Completed,
        Failed
    };
    
    DownloadStatus getStatus(const char* song_id) const;
    
    // 获取本地文件路径（下载完成后）
    bool getLocalPath(const char* song_id, char* out_path, size_t max_path_len) const;
    
    // 清理下载任务
    void cleanup();
    
private:
    M3u8DownloadService() = default;
    ~M3u8DownloadService() = default;
    
    // 下载任务信息（固定大小数组）
    struct DownloadTask {
        static constexpr size_t MAX_ID_LEN = 64;
        static constexpr size_t MAX_URL_LEN = 512;
        static constexpr size_t MAX_PATH_LEN = 256;
        
        std::array<char, MAX_ID_LEN> song_id = {0};
        std::array<char, MAX_URL_LEN> m3u8_url = {0};
        std::array<char, MAX_PATH_LEN> local_path = {0};
        DownloadStatus status = DownloadStatus::Idle;
        size_t total_segments = 0;
        size_t downloaded_segments = 0;
    };
    
    static constexpr size_t MAX_TASKS = 10;  // 最多10个并发下载任务
    std::array<DownloadTask, MAX_TASKS> tasks_;
    size_t task_count_ = 0;
    
    // 下载线程（后台线程）
    static void* downloadThread(void* arg);
    void processDownload();
    
    // 解析m3u8文件
    bool parseM3u8(const char* m3u8_content, size_t content_len,
                   char (*ts_urls)[512], size_t* out_count, size_t max_count);
    
    // 下载ts文件
    bool downloadTsFile(const char* ts_url, const char* local_path);
    
    // 生成hash目录路径
    void generateHashPath(const char* song_id, char* out_path, size_t max_path_len);
    
    // 禁止动态分配
    void* operator new(size_t) = delete;
    void* operator new[](size_t) = delete;
    void operator delete(void*) = delete;
    void operator delete[](void*) = delete;
};

} // namespace ktv

#endif // M3U8_DOWNLOAD_SERVICE_H
```

### 2.2 M3u8DownloadService实现

```cpp
#include "m3u8_download_service.h"
#include "cJSON.h"  // 如果需要解析m3u8的JSON格式
#include <cstring>
#include <cstdio>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>

namespace ktv {

bool M3u8DownloadService::initialize() {
    // 创建缓存目录
    mkdir("/data/ktv_cache", 0755);
    
    // 启动下载线程（可选，如果使用异步下载）
    // pthread_create(&download_thread_, nullptr, downloadThread, this);
    
    return true;
}

bool M3u8DownloadService::startDownload(const char* song_id, const char* m3u8_url) {
    // 检查是否已有任务
    for (size_t i = 0; i < task_count_; ++i) {
        if (strcmp(tasks_[i].song_id.data(), song_id) == 0) {
            // 已存在，更新状态
            if (tasks_[i].status == DownloadStatus::Completed) {
                return true;  // 已完成
            }
            return false;  // 正在下载
        }
    }
    
    // 创建新任务
    if (task_count_ >= MAX_TASKS) {
        return false;  // 任务队列满
    }
    
    DownloadTask& task = tasks_[task_count_++];
    strncpy(task.song_id.data(), song_id, DownloadTask::MAX_ID_LEN - 1);
    strncpy(task.m3u8_url.data(), m3u8_url, DownloadTask::MAX_URL_LEN - 1);
    task.status = DownloadStatus::Downloading;
    
    // 生成hash目录路径
    generateHashPath(song_id, task.local_path.data(), DownloadTask::MAX_PATH_LEN);
    
    // 创建目录
    mkdir(task.local_path.data(), 0755);
    
    // 开始下载（同步或异步）
    // 这里使用同步下载（在主线程或后台线程）
    processDownload();
    
    return true;
}

void M3u8DownloadService::processDownload() {
    // 处理所有下载任务
    for (size_t i = 0; i < task_count_; ++i) {
        DownloadTask& task = tasks_[i];
        if (task.status != DownloadStatus::Downloading) {
            continue;
        }
        
        // 1. 下载m3u8文件
        char m3u8_path[256];
        snprintf(m3u8_path, sizeof(m3u8_path), "%s/playlist.m3u8", task.local_path.data());
        
        HttpResponse response;
        if (!HttpService::getInstance().get(task.m3u8_url.data(), response)) {
            task.status = DownloadStatus::Failed;
            continue;
        }
        
        // 保存m3u8文件
        FILE* file = fopen(m3u8_path, "wb");
        if (file) {
            fwrite(response.body.data(), 1, response.body_len, file);
            fclose(file);
        }
        
        // 2. 解析m3u8文件，获取ts URL列表
        std::array<char[512], 100> ts_urls;  // 最多100个ts片段
        size_t ts_count = 0;
        
        if (!parseM3u8(response.body.data(), response.body_len,
                       ts_urls.data(), &ts_count, ts_urls.size())) {
            task.status = DownloadStatus::Failed;
            continue;
        }
        
        task.total_segments = ts_count;
        task.downloaded_segments = 0;
        
        // 3. 下载所有ts文件
        bool all_success = true;
        for (size_t j = 0; j < ts_count; ++j) {
            char ts_path[256];
            snprintf(ts_path, sizeof(ts_path), "%s/segment_%zu.ts", 
                    task.local_path.data(), j);
            
            if (!downloadTsFile(ts_urls[j], ts_path)) {
                all_success = false;
                break;
            }
            
            task.downloaded_segments++;
        }
        
        if (all_success) {
            task.status = DownloadStatus::Completed;
            
            // 发送完成事件到消息队列
            EventQueue::getInstance().postEvent(
                EventType::M3u8DownloadCompleted,
                &task.song_id
            );
        } else {
            task.status = DownloadStatus::Failed;
        }
    }
}

bool M3u8DownloadService::parseM3u8(const char* m3u8_content, size_t content_len,
                                    char (*ts_urls)[512], size_t* out_count, size_t max_count) {
    // 简单的m3u8解析（避免造轮子，使用标准库）
    // m3u8格式（文本格式，易于解析）：
    // #EXTM3U
    // #EXTINF:10.0,
    // http://example.com/segment0.ts
    // #EXTINF:10.0,
    // http://example.com/segment1.ts
    // ...
    
    // 注意：不需要专门的HLS库，m3u8是简单的文本格式
    
    *out_count = 0;
    const char* line_start = m3u8_content;
    const char* content_end = m3u8_content + content_len;
    
    while (line_start < content_end && *out_count < max_count) {
        // 查找行尾
        const char* line_end = line_start;
        while (line_end < content_end && *line_end != '\n' && *line_end != '\r') {
            line_end++;
        }
        
        size_t line_len = line_end - line_start;
        
        // 跳过空行和注释行
        if (line_len > 0 && line_start[0] != '#') {
            // 这是ts URL
            size_t copy_len = (line_len < 511) ? line_len : 511;
            strncpy(ts_urls[*out_count], line_start, copy_len);
            ts_urls[*out_count][copy_len] = '\0';
            (*out_count)++;
        }
        
        // 移动到下一行
        line_start = line_end;
        if (line_start < content_end && *line_start == '\r') line_start++;
        if (line_start < content_end && *line_start == '\n') line_start++;
    }
    
    return (*out_count > 0);
}

bool M3u8DownloadService::downloadTsFile(const char* ts_url, const char* local_path) {
    // 使用HttpService下载ts文件
    HttpResponse response;
    if (!HttpService::getInstance().get(ts_url, response)) {
        return false;
    }
    
    // 保存到本地文件
    FILE* file = fopen(local_path, "wb");
    if (!file) {
        return false;
    }
    
    fwrite(response.body.data(), 1, response.body_len, file);
    fclose(file);
    
    return true;
}

void M3u8DownloadService::generateHashPath(const char* song_id, char* out_path, size_t max_path_len) {
    // 简单的hash算法（使用song_id的hash值）
    uint32_t hash = 0;
    const char* p = song_id;
    while (*p) {
        hash = hash * 31 + static_cast<unsigned char>(*p);
        p++;
    }
    
    // 生成路径：/data/ktv_cache/hash值
    snprintf(out_path, max_path_len, "/data/ktv_cache/%08x", hash);
}

bool M3u8DownloadService::getLocalPath(const char* song_id, char* out_path, size_t max_path_len) const {
    for (size_t i = 0; i < task_count_; ++i) {
        if (strcmp(tasks_[i].song_id.data(), song_id) == 0) {
            if (tasks_[i].status == DownloadStatus::Completed) {
                strncpy(out_path, tasks_[i].local_path.data(), max_path_len - 1);
                out_path[max_path_len - 1] = '\0';
                return true;
            }
        }
    }
    return false;
}

void M3u8DownloadService::generateLocalM3u8(const char* hash_dir, 
                                             const char* ts_files[], 
                                             size_t ts_count) {
    // 生成本地m3u8文件（拼装本地ts文件）
    // 使用标准库，避免造轮子
    char m3u8_path[256];
    snprintf(m3u8_path, sizeof(m3u8_path), "%s/playlist_local.m3u8", hash_dir);
    
    FILE* file = fopen(m3u8_path, "w");
    if (!file) return;
    
    // 写入m3u8头部
    fprintf(file, "#EXTM3U\n");
    fprintf(file, "#EXT-X-VERSION:3\n");
    fprintf(file, "#EXT-X-TARGETDURATION:10\n");  // 假设每个ts片段10秒
    
    // 写入ts文件列表
    for (size_t i = 0; i < ts_count; ++i) {
        fprintf(file, "#EXTINF:10.0,\n");  // 每个ts片段10秒
        fprintf(file, "%s\n", ts_files[i]);  // ts文件名
    }
    
    // 写入结束标记
    fprintf(file, "#EXT-X-ENDLIST\n");
    fclose(file);
}

void M3u8DownloadService::cleanup() {
    // 清理所有任务
    task_count_ = 0;
}

} // namespace ktv
```

---

## 三、历史记录服务更新

### 3.1 HistoryItem更新（添加本地文件路径）

```cpp
struct HistoryItem {
    // ... 现有字段 ...
    
    // 新增：本地文件路径
    static constexpr size_t MAX_LOCAL_PATH_LEN = 256;
    std::array<char, MAX_LOCAL_PATH_LEN> local_path = {0};  // 本地ts文件路径
    
    const char* getLocalPath() const { return local_path.data(); }
    
    void setLocalPath(const char* path) {
        strncpy(local_path.data(), path, MAX_LOCAL_PATH_LEN - 1);
        local_path[MAX_LOCAL_PATH_LEN - 1] = '\0';
    }
};
```

### 3.2 HistoryService更新（添加文件管理）

```cpp
class HistoryService {
public:
    // ... 现有方法 ...
    
    // 添加播放记录（包含本地文件路径）
    void addRecord(const char* song_id,
                   const char* song_name,
                   const char* artist,
                   const char* m3u8_url,
                   const char* local_path = nullptr);
    
    // 删除最早的历史记录（包括文件）
    void removeOldestRecord();
    
    // 清理所有历史记录（包括文件）
    void clearAll();
    
private:
    // 删除本地文件
    void deleteLocalFile(const char* local_path);
    
    // 获取最早记录的索引
    size_t getOldestRecordIndex() const;
};
```

### 3.3 HistoryService实现更新

```cpp
void HistoryService::addRecord(const char* song_id,
                                const char* song_name,
                                const char* artist,
                                const char* m3u8_url,
                                const char* local_path) {
    // 单线程设计，无需锁保护
    
    // 检查是否已存在
    for (size_t i = 0; i < queue_size_; ++i) {
        size_t idx = (queue_head_ + i) % MAX_HISTORY_COUNT;
        if (strcmp(history_queue_[idx].getId(), song_id) == 0) {
            // 已存在，更新
            history_queue_[idx].setName(song_name);
            history_queue_[idx].setArtist(artist);
            history_queue_[idx].setUrl(m3u8_url);
            if (local_path) {
                history_queue_[idx].setLocalPath(local_path);
            }
            history_queue_[idx].play_time = std::time(nullptr);
            history_queue_[idx].play_count++;
            return;
        }
    }
    
    // 新记录：如果队列已满，删除最早的记录（包括文件）
    if (queue_size_ >= MAX_HISTORY_COUNT) {
        removeOldestRecord();
    }
    
    // 添加到队列
    size_t new_idx = (queue_head_ + queue_size_) % MAX_HISTORY_COUNT;
    HistoryItem& item = history_queue_[new_idx];
    item.setId(song_id);
    item.setName(song_name);
    item.setArtist(artist);
    item.setUrl(m3u8_url);
    if (local_path) {
        item.setLocalPath(local_path);
    }
    item.play_time = std::time(nullptr);
    item.play_count = 1;
    
    queue_size_++;
}

void HistoryService::removeOldestRecord() {
    if (queue_size_ == 0) {
        return;
    }
    
    // 获取最早的记录
    HistoryItem& oldest = history_queue_[queue_head_];
    
    // 删除本地文件（如果存在）
    if (oldest.getLocalPath()[0] != '\0') {
        deleteLocalFile(oldest.getLocalPath());
    }
    
    // 从队列中移除（FIFO）
    queue_head_ = (queue_head_ + 1) % MAX_HISTORY_COUNT;
    queue_size_--;
}

void HistoryService::deleteLocalFile(const char* local_path) {
    // 删除整个目录（hash目录）
    // 使用system命令（简单，但需要确保路径安全）
    char cmd[512];
    snprintf(cmd, sizeof(cmd), "rm -rf %s", local_path);
    system(cmd);
    
    // 注意：如果需要更安全的实现，可以使用标准库遍历目录删除
    // 但为了简单和避免造轮子，使用system命令即可
}

void HistoryService::clearAll() {
    // 删除所有本地文件
    for (size_t i = 0; i < queue_size_; ++i) {
        size_t idx = (queue_head_ + i) % MAX_HISTORY_COUNT;
        if (history_queue_[idx].getLocalPath()[0] != '\0') {
            deleteLocalFile(history_queue_[idx].getLocalPath());
        }
    }
    
    // 清空队列
    queue_size_ = 0;
    queue_head_ = 0;
}
```

---

## 四、播放流程集成

### 4.1 播放器服务更新

```cpp
class PlayerService {
public:
    // 播放歌曲（包含m3u8下载）
    bool play(const SongItem& song) {
        // 1. 直接播放m3u8（不等待下载）
        TPlayer* player = TPlayerCreate();
        TPlayerSetDataSource(player, song.getUrl(), nullptr);
        TPlayerStart(player);
        
        // 2. 后台开始下载m3u8和ts文件
        M3u8DownloadService::getInstance().startDownload(
            song.getId(),
            song.getUrl()
        );
        
        return true;
    }
    
    // 播放本地文件（从历史记录）
    bool playFromHistory(const HistoryItem& item) {
        // 如果本地文件存在，播放本地文件
        if (item.getLocalPath()[0] != '\0') {
            // 检查文件是否存在
            FILE* test = fopen(item.getLocalPath(), "r");
            if (test) {
                fclose(test);
                // 播放本地文件（需要合并ts文件或使用支持多文件的播放器）
                // 这里简化处理，仍然播放m3u8 URL
            }
        }
        
        // 播放原始m3u8 URL
        TPlayer* player = TPlayerCreate();
        TPlayerSetDataSource(player, item.getUrl(), nullptr);
        TPlayerStart(player);
        
        return true;
    }
};
```

### 4.2 事件处理

```cpp
// 处理m3u8下载完成事件
void EventQueue::onM3u8DownloadCompleted(const char* song_id) {
    // 获取本地文件路径
    char local_path[256];
    if (M3u8DownloadService::getInstance().getLocalPath(song_id, local_path, sizeof(local_path))) {
        // 更新历史记录，添加本地文件路径
        // 这里需要从SongService获取歌曲信息
        // HistoryService::getInstance().updateLocalPath(song_id, local_path);
    }
}
```

---

## 五、文件系统管理

### 5.1 目录结构

```
/data/ktv_cache/
├── 3a5f8b2c/                    # song_id的hash值
│   ├── playlist.m3u8            # 原始m3u8文件（从服务器下载）
│   ├── playlist_local.m3u8      # 本地m3u8文件（拼装本地ts文件）
│   ├── segment_0.ts             # ts片段0
│   ├── segment_1.ts             # ts片段1
│   └── ...                       # 其他ts片段
├── 7d9e1f4a/
│   └── ...
└── ...
```

### 5.2 文件管理策略

**FIFO策略（最多50首）：**
- 当历史记录超过50首时，删除最早一首的本地文件
- 删除整个hash目录（包含所有ts文件）

**存储空间管理：**
- 每个歌曲的存储空间 = m3u8文件 + 所有ts文件
- 需要监控总存储空间，避免占满磁盘

### 5.3 文件删除实现

```cpp
void HistoryService::deleteLocalFile(const char* local_path) {
    // 方式1：使用system命令（简单但不安全）
    char cmd[512];
    snprintf(cmd, sizeof(cmd), "rm -rf %s", local_path);
    system(cmd);
    
    // 方式2：使用标准库（更安全，但需要遍历目录）
    // 实现目录遍历和文件删除
    // ...
}
```

---

## 六、开源库评估

### 6.1 HLS下载库评估

**是否需要专门的HLS库？**

**评估结果：**
- ❌ **不需要专门的HLS库**：m3u8格式简单，可以自己解析
- ✅ **使用libcurl**：下载m3u8和ts文件（已有）
- ✅ **使用标准库**：文件操作、目录管理

**理由：**
- m3u8格式简单，文本格式，易于解析
- 避免引入额外的依赖
- libcurl已经可以下载HTTP文件

### 6.2 文件系统操作

**使用标准库：**
- `fopen` / `fclose` - 文件操作
- `mkdir` - 创建目录
- `rm -rf` - 删除目录（通过system命令，或自己实现）

**如果需要更安全的文件操作：**
- 可以使用`dirent.h`遍历目录
- 使用`unlink`删除文件
- 使用`rmdir`删除目录

---

## 七、使用示例

### 7.1 播放歌曲并下载

```cpp
// 播放歌曲
void onSongItemClicked(const SongItem& song) {
    // 1. 直接播放m3u8
    PlayerService::getInstance().play(song);
    
    // 2. 后台开始下载（异步）
    M3u8DownloadService::getInstance().startDownload(
        song.getId(),
        song.getUrl()
    );
    
    // 3. 添加到历史记录（先不包含本地路径）
    HistoryService::getInstance().addRecord(
        song.getId(),
        song.getName(),
        song.getArtist(),
        song.getUrl()
    );
}

// 下载完成后的处理
void onM3u8DownloadCompleted(const char* song_id) {
    char local_path[256];
    if (M3u8DownloadService::getInstance().getLocalPath(song_id, local_path, sizeof(local_path))) {
        // 更新历史记录，添加本地文件路径
        HistoryService::getInstance().updateLocalPath(song_id, local_path);
    }
}
```

### 7.2 从历史记录播放

```cpp
// 从历史记录播放
void onHistoryItemClicked(const HistoryItem& item) {
    // 如果本地文件存在，优先播放本地文件
    if (item.getLocalPath()[0] != '\0') {
        // 检查文件是否存在
        FILE* test = fopen(item.getLocalPath(), "r");
        if (test) {
            fclose(test);
            // 播放本地文件（需要处理多个ts文件）
            // 这里简化，仍然播放m3u8 URL
        }
    }
    
    // 播放原始m3u8 URL
    PlayerService::getInstance().playFromHistory(item);
}
```

---

## 八、总结

### 8.1 核心组件

1. **M3u8DownloadService**：后台下载m3u8和ts文件
2. **HistoryService**：管理历史记录和本地文件
3. **PlayerService**：播放器服务，支持直接播放和本地播放

### 8.2 技术要点

- ✅ **使用libcurl**：下载m3u8和ts文件（40,000+ stars，避免造轮子）
- ✅ **简单m3u8解析**：文本格式，使用标准库字符串处理（避免专门的HLS库，避免造轮子）
- ✅ **预分配内存**：固定大小数组和缓冲区
- ✅ **FIFO管理**：最多50首，超过删除最早的（包括删除本地文件）
- ✅ **单线程设计**：下载在后台线程，通过消息队列通信（无锁设计）
- ✅ **避免造轮子**：严格遵循避免造轮子原则，使用现有库和标准库

### 8.3 存储策略

- **目录结构**：`/data/ktv_cache/{hash}/`
- **文件命名**：`playlist.m3u8`, `segment_0.ts`, `segment_1.ts`, ...
- **删除策略**：FIFO，删除整个hash目录

---

**总结**：播放器直接播放m3u8，后台异步下载ts文件存储到本地hash目录，历史记录最多50首，超过删除最早的。使用libcurl下载，简单m3u8解析，避免造轮子。


# KTVLV 项目编码原则

> **最后更新**：2025-01-XX

## 🎯 核心原则

### 1. 复用优先，但不过度设计

**原则：**
> **在写代码和文档时，尽量先检查是否已有模块/封装是否可用，避免重复造轮子。但也不要为了追求复用而增加复杂度。**
> 
> **⚠️ 关键判断：如果复用后反而增加了复杂度，就属于过度设计，应该直接实现。**

**具体实践：**

#### ✅ 应该做的：
- **先检查现有模块**：在实现新功能前，先搜索代码库，查看是否有可复用的模块
- **优先使用已有服务**：如 `PageManager`、`HttpService`、`LicenceService`、`SongService`、`HistoryService`、`M3u8DownloadService`、`InputService`、`PlayerService` 等
- **复用公共函数**：如 `create_title_bar`、`create_page_indicator`、`on_back_to_main` 等
- **使用开源库**：优先使用成熟的开源库（libcurl、cJSON、moodycamel::ConcurrentQueue、inih 等）

#### ❌ 不应该做的：
- **盲目创建新模块**：不检查现有代码就直接创建新函数/类
- **过度抽象**：为了复用而创建过于复杂的抽象层
- **强制复用**：如果复用会增加复杂度，应该直接实现，而不是强行复用
- **⚠️ 过度设计**：如果复用后反而增加了复杂度，就属于过度设计，必须避免

### 2. 判断标准

**何时应该复用：**
- ✅ 现有模块功能完全匹配需求
- ✅ 现有模块可以轻松扩展以满足需求
- ✅ 复用不会显著增加代码复杂度
- ✅ 复用能减少代码重复（减少 > 20 行代码）

**何时不应该复用：**
- ❌ **复用后增加了复杂度**（这是过度设计的标志）
- ❌ 现有模块需要大量修改才能满足需求
- ❌ 复用会导致代码逻辑复杂、难以理解
- ❌ 复用需要创建复杂的适配层或包装器
- ❌ 需求与现有模块差异较大，强行复用反而增加维护成本
- ❌ 复用需要引入额外的依赖或间接调用

**⚠️ 核心判断标准：**
> **如果复用后代码变得更复杂、更难理解、更难维护，那就是过度设计，应该直接实现。**

### 3. 实际案例

#### ✅ 好的复用案例：

**案例 1：提取公共 UI 函数**
```cpp
// 之前：3 个地方重复创建标题栏（~45 行重复代码）
// 之后：提取为 create_title_bar() 公共函数
create_title_bar(scr, "已点列表");  // 简洁、统一
```

**案例 2：合并重复实现**
```cpp
// 之前：两个版本的 create_song_list_item（~50 行重复）
// 之后：旧版本调用新版本，统一使用 SongItem
static void create_song_list_item(lv_obj_t* list, const char* title, const char* subtitle) {
    // 转换为 SongItem 调用新版本
    ktv::services::SongItem item;
    item.title = title ? title : "";
    item.artist = subtitle ? subtitle : "";
    create_song_list_item(list, item);  // 复用主实现
}
```

#### ❌ 过度复用的反例：

**反例 1：为了复用而创建复杂的抽象**
```cpp
// ❌ 不好：为了复用而创建过于复杂的模板
// 复杂度：高（需要理解模板、类型推导等）
template<typename T, typename U, typename V>
class UniversalUICreator {
    // 过于复杂，难以理解，增加了复杂度
};

// ✅ 好：直接实现，简单明了
// 复杂度：低（一目了然）
static lv_obj_t* create_title_bar(lv_obj_t* parent, const char* title_text) {
    // 简单、直接、易维护
}
```

**反例 2：强制复用导致复杂适配**
```cpp
// ❌ 不好：为了复用现有函数，创建复杂的适配层
class ComplexAdapter {
    // 需要大量转换逻辑，增加了复杂度
    void adaptAndCall() {
        // 复杂的适配代码...
        existing_function(adapted_params);
    }
};

// ✅ 好：直接实现，避免不必要的适配
void new_function() {
    // 直接实现，简单明了
}
```

### 4. 检查清单

在实现新功能前，按以下顺序检查：

1. **检查现有服务类**
   - [ ] `HttpService` - HTTP 请求
   - [ ] `SongService` - 歌曲数据
   - [ ] `PlayerService` - 播放控制
   - [ ] `QueueService` - 播放队列
   - [ ] `HistoryService` - 历史记录
   - [ ] `LicenceService` - 许可证
   - [ ] `M3u8DownloadService` - 下载服务

2. **检查现有 UI 函数**
   - [ ] `create_title_bar` - 标题栏
   - [ ] `create_page_indicator` - 翻页指示器
   - [ ] `create_song_list_item` - 歌曲列表项
   - [ ] `on_back_to_main` - 返回主屏幕

3. **检查现有工具函数**
   - [ ] `setup_flex_row` / `setup_flex_col` - 布局设置
   - [ ] 样式初始化函数

4. **检查开源库**
   - [ ] libcurl - HTTP 请求
   - [ ] cJSON - JSON 解析
   - [ ] moodycamel::ConcurrentQueue - 队列
   - [ ] inih - 配置文件解析
   - [ ] plog - 日志

5. **评估复用成本（关键步骤）**
   - [ ] 复用是否简单直接？
   - [ ] **复用是否会增加复杂度？** ⚠️ 如果会，就是过度设计
   - [ ] 复用是否能减少代码重复？
   - [ ] **复用后的代码是否更容易理解？** ⚠️ 如果更难理解，就是过度设计
   - [ ] **复用后的代码是否更容易维护？** ⚠️ 如果更难维护，就是过度设计

### 5. 决策流程

```
新功能需求
    ↓
检查现有模块/函数
    ↓
    ├─ 完全匹配 → 直接复用 ✅
    ├─ 可轻松扩展 → 扩展后复用 ✅
    ├─ 需要大量修改 → 评估复杂度
    │   ├─ 复杂度低 → 修改后复用 ✅
    │   └─ 复杂度高 → 直接实现 ✅
    └─ 不匹配 → 直接实现 ✅
```

### 6. 代码审查要点

在代码审查时，关注：

1. **是否有重复实现？**
   - 检查是否有功能相似的代码
   - 是否可以提取公共函数

2. **是否过度抽象/过度设计？**
   - 检查抽象层是否过于复杂
   - **检查复用后是否增加了复杂度** ⚠️ 这是判断过度设计的关键
   - 是否为了复用而增加了不必要的复杂度
   - 复用后的代码是否比直接实现更复杂？

3. **是否使用了现有模块？**
   - 检查是否忽略了可用的服务类
   - 是否重复实现了已有功能

## 📝 相关文档

- [C++编码规范与避坑指南.md](./C++编码规范与避坑指南.md)
- [代码重构总结.md](./代码重构总结.md)
- [开源库选型指南.md](./开源库选型指南.md)

---

**核心记忆：**
> **先检查现有模块，避免重复造轮子；但不要为了复用而增加复杂度。**
> 
> **⚠️ 关键判断：如果复用后反而增加了复杂度，就属于过度设计，必须避免。**
> 
> **简单直接的复用 ✅ | 复杂抽象的复用 ❌ | 增加复杂度的复用 ❌（过度设计）**


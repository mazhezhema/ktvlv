# 黑屏问题诊断与修复

## 🔍 问题分析

**核心问题**: 日志中没有 `[FLUSH]` 输出，说明 `sdl_display_flush()` **根本没有被调用**。

这意味着问题不在渲染逻辑，而在**LVGL → SDL 的调用链路**。

---

## ✅ 已添加的诊断代码

### Step1: flush_cb 注册验证

**位置**: `src/main.cpp` - `init_display()`

```cpp
// ✅ Step1诊断：确认 flush_cb 被注册
if (disp_drv.flush_cb == NULL) {
    fprintf(stderr, "❌ [DIAG] flush_cb NOT SET - CRITICAL ERROR!\n");
    return false;
} else {
    fprintf(stderr, "✅ [DIAG] flush_cb is SET: %p\n", (void*)disp_drv.flush_cb);
}
```

**预期输出**:
- ✅ `flush_cb is SET` → 注册成功
- ❌ `flush_cb NOT SET` → **根因锁定**，需要检查注册逻辑

---

### Step2: full_refresh 位置确认

**位置**: `src/main.cpp` - `init_display()`

```cpp
// ✅ Step2诊断：确认 full_refresh 在注册前设置
fprintf(stderr, "[DIAG] full_refresh = %d (must be 1 before register)\n", disp_drv.full_refresh);
```

**预期输出**: `full_refresh = 1`（必须在 register 之前）

---

### Step3: 强制标脏 + 刷新

**位置**: `src/main.cpp` - 主循环首次迭代

```cpp
// ⚠️ 关键：必须先标脏，否则 LVGL 认为没有需要刷新的内容
lv_obj_t* active_scr = lv_scr_act();
if (active_scr) {
    lv_obj_invalidate(active_scr);  // 强制标脏
    fprintf(stderr, "[MAIN] Screen invalidated, forcing refresh...\n");
}
lv_refr_now(disp);  // 立即刷新
```

**预期输出**: 
- `Screen invalidated, forcing refresh...`
- 如果 flush_cb 已注册，应该看到 `🔥 [FLUSH]` 日志

---

### Step4: SDL Renderer Flags 优化

**位置**: `src/sdl/sdl.cpp` - `sdl_init()`

```cpp
// ✅ Step4修复：使用更兼容的 renderer flags
renderer = SDL_CreateRenderer(window, -1, 
    SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_TARGETTEXTURE);
```

**改进点**:
- 添加 `SDL_RENDERER_TARGETTEXTURE` 支持
- 更好的回退机制（硬件 → 软件）
- 输出 renderer 信息用于诊断

---

### Step5: flush 函数诊断日志

**位置**: `src/sdl/sdl.cpp` - `sdl_display_flush()`

```cpp
// ✅ 关键诊断：每次 flush 都输出，确认函数被调用
fprintf(stderr, "🔥 [FLUSH] sdl_display_flush called! (#%d) area=(%d,%d)-(%d,%d)\n",
        flush_count, area->x1, area->y1, area->x2, area->y2);
```

**预期输出**: 
- 如果看到 `🔥 [FLUSH]` → **flush_cb 被调用，问题在渲染逻辑**
- 如果看不到 → **flush_cb 未被调用，问题在注册/触发链路**

---

## 📊 诊断流程

### 场景1: flush_cb 未注册

**症状**: 
```
❌ [DIAG] flush_cb NOT SET - CRITICAL ERROR!
```

**原因**: `disp_drv.flush_cb = sdl_display_flush;` 这行代码未执行或执行失败

**解决**: 检查 `sdl_display_flush` 函数声明和链接

---

### 场景2: flush_cb 已注册但未被调用

**症状**:
```
✅ [DIAG] flush_cb is SET: 0x...
[MAIN] lv_refr_now() called, check for [FLUSH] logs
（但没有 🔥 [FLUSH] 日志）
```

**可能原因**:
1. LVGL 没有脏区域（没有 invalidate）
2. `full_refresh` 未生效
3. tick 系统未正确初始化

**解决**: 
- 已添加 `lv_obj_invalidate()` 强制标脏
- 检查 tick 更新逻辑

---

### 场景3: flush_cb 被调用但渲染失败

**症状**:
```
🔥 [FLUSH] sdl_display_flush called! (#1)
ERROR: flush: renderer/texture/color_p NULL
```

**原因**: SDL 对象未正确初始化

**解决**: 检查 `sdl_init()` 返回值

---

### 场景4: flush_cb 被调用但屏幕仍黑

**症状**:
```
🔥 [FLUSH] sdl_display_flush called! (#1)
[FLUSH] Screen flush #1 completed
（但屏幕仍黑）
```

**可能原因**:
1. 颜色格式转换错误
2. SDL_UpdateTexture 失败但未报错
3. Renderer flags 不兼容

**解决**: 
- 检查颜色转换逻辑
- 检查 SDL_UpdateTexture 返回值
- 尝试软件渲染模式

---

## 🎯 下一步行动

### 运行程序后，检查日志输出：

1. **查找 `[DIAG]` 日志** → 确认注册状态
2. **查找 `🔥 [FLUSH]` 日志** → 确认是否被调用
3. **查找 `[SDL]` 日志** → 确认 renderer 类型

### 根据日志结果：

- **如果看到 `🔥 [FLUSH]`**: 
  - ✅ flush_cb 链路正常
  - 🔍 问题在渲染逻辑（颜色转换、SDL API 调用）
  
- **如果看不到 `🔥 [FLUSH]`**:
  - ❌ flush_cb 未被调用
  - 🔍 检查注册、invalidate、tick 系统

---

## 📝 总结

**已完成的修复**:
1. ✅ 添加 flush_cb 注册验证
2. ✅ 确认 full_refresh 位置
3. ✅ 强制标脏 + 刷新
4. ✅ 优化 SDL renderer flags
5. ✅ 添加详细的诊断日志

**现在运行程序，查看日志输出，告诉我**:
```
flush_cb 是否进入（是/否）
```

根据结果，我们可以进一步定位问题！🚀



# 线程与事件系统设计

> **文档版本**：v1.0  
> **最后更新**：2024  
> **状态**：⚠️ **参考文档（旧版）**（已更新为 [并发架构总结构（最终版）.md](../architecture/并发架构总结构（最终版）.md)）  
> **相关文档**：详见 [并发架构总结构（最终版）.md](../architecture/并发架构总结构（最终版）.md)

## ⚠️ 核心原则

- ✅ **尽量少线程**：主线程处理UI和业务逻辑，最小化后台线程
- ✅ **尽量无锁**：单线程设计为主，避免锁竞争和死锁风险
- ✅ **解耦合**：使用事件/消息队列解耦组件间通信
- ✅ **避免造轮子**：严格遵循避免造轮子原则，使用成熟的消息队列库
- ✅ **简单实用**：选择轻量级、适合嵌入式的库
- ✅ **嵌入式可用**：资源占用小，无动态内存分配

---

## 一、线程设计

### 1.1 线程列表

**总线程数：2-3个（最小化设计）**

| 线程名称 | 类型 | 职责 | 优先级 | 是否必需 |
|---------|------|------|--------|---------|
| **主线程（Main Thread）** | UI线程 | UI渲染、业务逻辑、事件处理 | 高 | ✅ 必需 |
| **播放器回调线程（Player Callback Thread）** | 后台线程 | TPlayer播放状态回调、进度更新 | 中 | ✅ 必需（如果TPlayer需要） |
| **网络线程（Network Thread）** | 后台线程 | HTTP请求（libcurl异步模式） | 低 | ⚠️ 可选（如果使用异步） |

### 1.2 线程详细说明

#### 1.2.1 主线程（Main Thread）

**职责：**
- LVGL UI渲染和事件处理
- 页面管理和切换
- 业务逻辑处理
- 消息队列处理（从消息队列读取事件并处理）
- 调用服务层（HistoryService、SongService等）

**特点：**
- 单线程设计，无锁
- 所有UI操作在主线程执行
- 通过消息队列接收其他线程的事件

**代码示例：**
```cpp
int main() {
    // 初始化
    lv_init();
    HttpService::getInstance().initialize();
    PageManager::getInstance().initialize();
    
    // 主循环（UI线程）
    while (1) {
        // LVGL事件处理
        lv_timer_handler();
        
        // 处理消息队列中的事件（无锁，单线程）
        EventQueue::getInstance().processEvents();
        
        usleep(5000);  // 5ms
    }
    
    return 0;
}
```

#### 1.2.2 播放器回调线程（Player Callback Thread）

**职责：**
- 接收TPlayer播放状态回调（播放、暂停、结束等）
- 接收播放进度更新
- 将事件发送到消息队列（供主线程处理）

**特点：**
- 由TPlayer SDK创建（如果支持回调线程）
- 或由应用创建（如果TPlayer需要轮询）
- 通过无锁消息队列与主线程通信

**代码示例：**
```cpp
// TPlayer回调函数（在播放器回调线程中执行）
void onPlayerStateChanged(TPlayer* player, int state) {
    // 创建事件并发送到消息队列（无锁）
    EventQueue::getInstance().postEvent(EventType::PlayerStateChanged, state);
}

// 播放进度回调（在播放器回调线程中执行）
void onPlayerProgress(TPlayer* player, int64_t position, int64_t duration) {
    // 发送进度更新事件（无锁）
    EventQueue::getInstance().postEvent(EventType::PlayerProgress, position, duration);
}
```

#### 1.2.3 网络线程（Network Thread）⚠️ 可选

**职责：**
- 执行HTTP请求（如果libcurl使用异步模式）
- 将响应结果发送到消息队列（供主线程处理）

**特点：**
- **可选**：如果libcurl使用同步模式，则不需要此线程
- 如果使用异步模式，可以创建此线程
- 通过无锁消息队列与主线程通信

**代码示例：**
```cpp
// 网络线程函数（可选）
void* networkThread(void* arg) {
    while (running_) {
        // 处理HTTP请求队列
        HttpRequest request;
        if (HttpService::getInstance().popRequest(request)) {
            // 执行HTTP请求
            HttpResponse response;
            HttpService::getInstance().executeRequest(request, response);
            
            // 发送响应事件到消息队列（无锁）
            EventQueue::getInstance().postEvent(
                EventType::HttpResponse, 
                &response
            );
        }
        
        usleep(10000);  // 10ms
    }
    return nullptr;
}
```

**推荐方案：**
- **优先使用同步模式**：libcurl在主线程同步调用，无需网络线程
- **如果响应慢**：可以考虑异步模式，但需要网络线程

---

## 二、事件系统设计

### 2.1 事件类型枚举

```cpp
namespace ktv {

enum class EventType : uint8_t {
    // 播放器事件
    PlayerStateChanged = 0,    // 播放状态改变（播放/暂停/停止）
    PlayerProgress,            // 播放进度更新
    PlayerError,               // 播放错误
    PlayerCompleted,           // 播放完成
    
    // 网络事件
    HttpResponse,              // HTTP响应（如果使用异步网络）
    NetworkError,              // 网络错误
    
    // UI事件（由LVGL触发，在主线程处理）
    PageSwitch,                // 页面切换
    SongItemClicked,           // 歌曲项点击
    SearchRequested,           // 搜索请求
    
    // 系统事件
    VolumeChanged,             // 音量改变
    AudioTrackSwitched,        // 音轨切换（原唱/伴奏）
    
    // 历史记录事件
    HistoryUpdated,            // 历史记录更新
    
    // M3u8下载事件
    M3u8DownloadCompleted,     // M3u8下载完成
    M3u8DownloadFailed,        // M3u8下载失败
    
    Count  // 事件类型总数
};

} // namespace ktv
```

### 2.2 事件数据结构（预分配版本）

```cpp
namespace ktv {

// 事件数据（固定大小，预分配）
struct EventData {
    EventType type;
    union {
        // 播放器事件数据
        struct {
            int state;  // 播放状态
        } player_state;
        
        struct {
            int64_t position;  // 当前位置（毫秒）
            int64_t duration;   // 总时长（毫秒）
        } player_progress;
        
        struct {
            int error_code;
            char error_msg[128];
        } player_error;
        
        // 网络事件数据
        struct {
            int request_id;
            int status_code;
            char response_body[8192];  // 固定大小缓冲区
            size_t body_len;
        } http_response;
        
        // UI事件数据
        struct {
            PageType page_type;
            PageParams params;
        } page_switch;
        
        struct {
            char song_id[64];
        } song_clicked;
        
        struct {
            char keyword[128];
        } search;
        
        // 系统事件数据
        struct {
            int volume;  // 0-100
        } volume;
        
        struct {
            int track_index;  // 0=原唱, 1=伴奏
        } audio_track;
    } data;
};

} // namespace ktv
```

### 2.3 事件处理流程

```
┌─────────────────────────────────────────┐
│  事件源（多线程）                         │
│  - 播放器回调线程（TPlayer回调）          │
│  - 网络线程（HTTP响应，可选）             │
│  - LVGL事件（主线程）                    │
└─────────────────────────────────────────┘
           ↓ 发送事件（无锁）
┌─────────────────────────────────────────┐
│  消息队列（无锁队列）                     │
│  - 固定大小环形缓冲区                    │
│  - 单生产者单消费者（SPSC）              │
│  - 无锁设计                              │
└─────────────────────────────────────────┘
           ↓ 处理事件（主线程）
┌─────────────────────────────────────────┐
│  事件处理器（主线程）                     │
│  - 播放器事件处理                        │
│  - 网络事件处理                          │
│  - UI事件处理                            │
└─────────────────────────────────────────┘
```

---

## 三、消息队列设计（使用开源库）

### 3.1 设计原则

- ✅ **避免造轮子**：严格遵循避免造轮子原则，优先使用成熟的开源消息队列库
- ✅ **无锁设计**：选择无锁队列库，避免锁竞争
- ✅ **预分配内存友好**：库支持固定大小缓冲区或可配置
- ✅ **解耦合**：组件间通过消息队列通信，不直接调用
- ✅ **简单实用**：轻量级，适合嵌入式

### 3.2 推荐方案：moodycamel::ConcurrentQueue ⭐ **推荐**

**moodycamel::ConcurrentQueue**
- **用途**：高性能无锁队列，支持单生产者单消费者（SPSC）和多生产者多消费者（MPMC）
- **特点**：
  - 无锁设计，高性能
  - 支持SPSC和MPMC模式
  - 单头文件，易于集成
  - 支持预分配内存（通过模板参数）
  - 适合嵌入式平台
- **许可证**：Simplified BSD
- **GitHub**：https://github.com/cameron314/concurrentqueue
- **推荐度**：⭐⭐⭐⭐⭐ **推荐**

**使用示例：**

```cpp
#ifndef EVENT_QUEUE_H
#define EVENT_QUEUE_H

#include "events/event_data.h"
#include "concurrentqueue.h"  // moodycamel::ConcurrentQueue
#include <cstdint>

namespace ktv {

/**
 * 事件队列封装（使用moodycamel::ConcurrentQueue）
 * 无锁设计，支持多生产者单消费者（MPSC）
 */
class EventQueue {
public:
    static EventQueue& getInstance() {
        static EventQueue instance;
        return instance;
    }
    
    EventQueue(const EventQueue&) = delete;
    EventQueue& operator=(const EventQueue&) = delete;
    
    // 发送事件（生产者，可在任何线程调用）
    bool postEvent(EventType type, const void* data = nullptr);
    
    // 处理事件（消费者，仅在主线程调用）
    void processEvents();
    
    // 清空队列
    void clear();
    
    // 获取队列大小（近似值）
    size_t size_approx() const;
    
private:
    EventQueue() = default;
    ~EventQueue() = default;
    
    // moodycamel::ConcurrentQueue（无锁队列）
    moodycamel::ConcurrentQueue<EventData> queue_;
    
    // 禁止动态分配
    void* operator new(size_t) = delete;
    void* operator new[](size_t) = delete;
    void operator delete(void*) = delete;
    void operator delete[](void*) = delete;
};

} // namespace ktv

#endif // EVENT_QUEUE_H
```

### 3.3 事件队列实现（使用moodycamel::ConcurrentQueue）

```cpp
#include "event_queue.h"
#include <cstring>

namespace ktv {

bool EventQueue::postEvent(EventType type, const void* data) {
    // 创建事件数据
    EventData event;
    event.type = type;
    
    // 复制事件数据（如果有）
    if (data != nullptr) {
        memcpy(&event.data, data, sizeof(event.data));
    }
    
    // 入队（无锁，可在任何线程调用）
    return queue_.enqueue(event);
}

void EventQueue::processEvents() {
    // 主线程处理事件（消费者）
    EventData event;
    
    // 批量处理事件（最多处理256个）
    const size_t BATCH_SIZE = 256;
    size_t count = 0;
    
    while (count < BATCH_SIZE && queue_.try_dequeue(event)) {
        // 处理事件
        handleEvent(event);
        count++;
    }
}

void EventQueue::handleEvent(const EventData& event) {
    switch (event.type) {
        case EventType::PlayerStateChanged:
            // 处理播放状态改变
            onPlayerStateChanged(event.data.player_state.state);
            break;
            
        case EventType::PlayerProgress:
            // 处理播放进度
            onPlayerProgress(
                event.data.player_progress.position,
                event.data.player_progress.duration
            );
            break;
            
        case EventType::HttpResponse:
            // 处理HTTP响应
            onHttpResponse(event.data.http_response);
            break;
            
        case EventType::PageSwitch:
            // 处理页面切换
            PageManager::getInstance().switchTo(
                event.data.page_switch.page_type,
                &event.data.page_switch.params
            );
            break;
            
        // ... 其他事件处理
        default:
            break;
    }
}

size_t EventQueue::size_approx() const {
    // 返回队列大小的近似值（无锁）
    return queue_.size_approx();
}

void EventQueue::clear() {
    // 清空队列（出队所有事件）
    EventData event;
    while (queue_.try_dequeue(event)) {
        // 丢弃事件
    }
}

} // namespace ktv
```

---

## 四、开源消息队列库对比

### 4.1 推荐库对比（按GitHub Stars和更新频率排序）

| 库名 | GitHub Stars | 更新频率 | 特点 | 适合场景 | 推荐度 |
|------|-------------|---------|------|---------|--------|
| **moodycamel::ConcurrentQueue** | ⭐ 10,000+ | ✅ 2024年更新 | 无锁、高性能、单头文件、支持MPSC | 单/多生产者单/多消费者 | ⭐⭐⭐⭐⭐ **推荐（star最多）** |
| **moodycamel::ReaderWriterQueue** | ⭐ 1,000+ | ✅ 活跃维护 | 轻量、仅SPSC、成熟稳定 | 单生产者单消费者 | ⭐⭐⭐⭐⭐ **推荐（SPSC）** |
| **tinySPSCQueue** | ⚠️ 需验证 | ⚠️ 需验证 | 极轻量、专为SPSC设计 | 单生产者单消费者 | ⭐⭐⭐ **需验证** |
| **libevent** | ⭐ 5,000+ | ✅ 活跃维护 | 事件驱动框架 | 网络事件处理 | ⭐⭐⭐（如果主要用于网络） |
| **libev** | ⭐ 1,000+ | ✅ 活跃维护 | 轻量级事件循环 | 事件驱动 | ⭐⭐⭐（如果主要用于事件） |

### 4.2 推荐方案对比（按GitHub Stars和更新频率）

#### 方案1：moodycamel::ConcurrentQueue ⭐ **推荐（star数最多）**

**moodycamel::ConcurrentQueue**
- **用途**：高性能无锁队列，支持单/多生产者单/多消费者
- **特点**：
  - 成熟稳定，广泛使用
  - 无锁设计，高性能
  - 单头文件，易于集成
  - 支持SPSC/MPSC/MPMC模式
  - 预分配友好：可以配置初始容量
  - 嵌入式友好：资源占用可控
- **许可证**：Simplified BSD
- **GitHub**：https://github.com/cameron314/concurrentqueue
- **GitHub Stars**：⭐ **10,000+**（极高）
- **更新频率**：✅ **活跃维护**（2024年有更新）
- **推荐度**：⭐⭐⭐⭐⭐ **推荐（star数最多，更新活跃）**

**选择理由：**
- ✅ **GitHub Stars最多**：10,000+ stars，社区认可度极高
- ✅ **更新活跃**：2024年有更新，项目维护良好
- ✅ **功能全面**：支持SPSC和MPSC，未来扩展性好
- ✅ **成熟稳定**：广泛使用，经过验证

#### 方案2：moodycamel::ReaderWriterQueue ⭐ **推荐（如果只需要SPSC）**

**moodycamel::ReaderWriterQueue**
- **用途**：单生产者单消费者无锁队列（成熟稳定）
- **特点**：
  - 比ConcurrentQueue更轻量
  - 仅支持SPSC模式
  - 单头文件，易于集成
  - 成熟稳定，广泛使用
- **许可证**：Simplified BSD
- **GitHub**：https://github.com/cameron314/readerwriterqueue
- **GitHub Stars**：⭐ **1,000+**（高）
- **更新频率**：✅ **活跃维护**（定期更新）
- **推荐度**：⭐⭐⭐⭐⭐ **推荐（如果只需要SPSC）**

**选择理由：**
- ✅ **轻量级**：比ConcurrentQueue更轻量
- ✅ **专为SPSC设计**：如果只需要SPSC，这是更好的选择
- ✅ **同作者**：与ConcurrentQueue同作者，质量有保障
- ✅ **star数高**：1,000+ stars，社区认可度高

#### 方案3：tinySPSCQueue ⚠️ **需验证（star数和更新频率未知）**

**tinySPSCQueue**
- **用途**：极轻量级单生产者单消费者无锁队列
- **特点**：
  - 专为SPSC设计，极轻量
  - 无锁设计，高性能
  - 适合嵌入式平台
  - 预分配内存友好
- **适用场景**：单生产者单消费者（SPSC）
- **推荐度**：⭐⭐⭐ **需验证（star数和更新频率未知）**

**评估标准（必须验证）：**
- ⚠️ **GitHub Stars**：需>1000（建议）
- ⚠️ **更新频率**：需最近6个月内有更新（建议）
- ⚠️ **GitHub仓库**：需提供仓库地址
- ⚠️ **许可证**：需兼容项目
- ⚠️ **API文档**：需完整
- ⚠️ **稳定性**：需经过测试

**选择建议：**
- **如果tinySPSCQueue的star数>1000且最近有更新**：可以考虑
- **否则优先选择**：moodycamel::ReaderWriterQueue或ConcurrentQueue

### 4.3 tinySPSCQueue集成（如果选择）

**如果选择tinySPSCQueue，需要验证以下信息：**
- GitHub仓库地址
- 许可证（需兼容项目）
- API接口和使用方式
- 预分配内存支持
- 代码量和资源占用
- 社区支持和文档完整性

**使用示例（假设API）：**
```cpp
#include "tinySPSCQueue.h"

// 创建队列（固定大小，预分配）
tinySPSCQueue<EventData, 256> event_queue;

// 生产者（任何线程）
event_queue.push(event);

// 消费者（主线程）
EventData event;
if (event_queue.pop(event)) {
    handleEvent(event);
}
```

**注意**：使用前需要充分测试和验证其稳定性和性能。

### 4.4 moodycamel::ConcurrentQueue集成

**方式1：单文件集成（推荐）**
```bash
# 下载concurrentqueue.h
wget https://github.com/cameron314/concurrentqueue/raw/master/concurrentqueue.h
# 或
git clone https://github.com/cameron314/concurrentqueue.git
```

**方式2：作为子模块**
```bash
git submodule add https://github.com/cameron314/concurrentqueue.git third_party/concurrentqueue
```

**使用示例：**
```cpp
#include "concurrentqueue.h"

// 创建队列（可以指定初始容量，减少动态分配）
moodycamel::ConcurrentQueue<EventData> event_queue(256);

// 生产者（任何线程）
EventData event;
event.type = EventType::PlayerStateChanged;
event.data.player_state.state = PLAYER_STATE_PLAYING;
event_queue.enqueue(event);

// 消费者（主线程）
EventData event;
if (event_queue.try_dequeue(event)) {
    handleEvent(event);
}

// 批量处理（更高效）
EventData events[256];
size_t count = event_queue.try_dequeue_bulk(events, 256);
for (size_t i = 0; i < count; ++i) {
    handleEvent(events[i]);
}
```

**注意**：moodycamel::ConcurrentQueue是单头文件库，只需包含头文件即可使用，无需编译链接。

---

## 五、事件处理示例

### 5.1 播放器事件处理

```cpp
// 播放器回调线程（TPlayer回调）
void onPlayerStateChanged(TPlayer* player, int state) {
    // 发送事件到消息队列（无锁）
    EventData event;
    event.type = EventType::PlayerStateChanged;
    event.data.player_state.state = state;
    EventQueue::getInstance().postEvent(event.type, &event.data);
}

// 主线程处理事件
void EventQueue::onPlayerStateChanged(int state) {
    // 更新UI（在主线程执行，安全）
    switch (state) {
        case PLAYER_STATE_PLAYING:
            // 更新播放按钮状态
            updatePlayButton(true);
            break;
        case PLAYER_STATE_PAUSED:
            updatePlayButton(false);
            break;
        // ...
    }
}
```

### 5.2 网络事件处理（如果使用异步网络）

```cpp
// 网络线程（HTTP响应）
void onHttpResponse(const HttpResponseData& response) {
    // 发送事件到消息队列（无锁）
    EventData event;
    event.type = EventType::HttpResponse;
    event.data.http_response.status_code = response.status_code;
    strncpy(event.data.http_response.response_body, 
            response.body, 
            sizeof(event.data.http_response.response_body) - 1);
    EventQueue::getInstance().postEvent(event.type, &event.data);
}

// 主线程处理事件
void EventQueue::onHttpResponse(const HttpResponseData& response) {
    // 解析JSON并更新UI（在主线程执行，安全）
    cJSON* json = cJSON_Parse(response.body);
    // ... 解析并更新UI
    cJSON_Delete(json);
}
```

### 5.3 UI事件处理

```cpp
// LVGL事件回调（在主线程）
void onSongItemClicked(lv_event_t* e) {
    SongItem* song = static_cast<SongItem*>(lv_obj_get_user_data(e->target));
    
    // 发送事件到消息队列（主线程，但解耦合）
    EventData event;
    event.type = EventType::SongItemClicked;
    strncpy(event.data.song_clicked.song_id, song->getId(), 63);
    EventQueue::getInstance().postEvent(event.type, &event.data);
}

// 主线程处理事件
void EventQueue::onSongItemClicked(const char* song_id) {
    // 点歌逻辑（在主线程执行）
    SongService::getInstance().addToQueue(song_id);
    // ... 开始播放
}
```

---

## 六、线程安全说明

### 6.1 无锁设计原理

**单生产者单消费者（SPSC）无锁队列：**
- **生产者**：播放器回调线程、网络线程（可选）
- **消费者**：主线程（唯一）
- **无锁保证**：使用`std::atomic`和内存序（memory ordering）保证可见性

**内存序说明：**
- `memory_order_relaxed`：读/写操作，无同步要求
- `memory_order_acquire`：读操作，确保后续操作可见
- `memory_order_release`：写操作，确保之前操作可见

### 6.2 线程安全保证

| 操作 | 线程 | 安全性 |
|------|------|--------|
| UI操作 | 主线程 | ✅ 安全（LVGL要求主线程） |
| 消息队列写入 | 任何线程 | ✅ 安全（无锁SPSC） |
| 消息队列读取 | 主线程 | ✅ 安全（无锁SPSC） |
| 服务层调用 | 主线程 | ✅ 安全（单线程设计） |

### 6.3 避免锁的原因

- ❌ **避免死锁**：无锁设计，无死锁风险
- ❌ **避免性能开销**：无锁竞争，性能更好
- ❌ **简化设计**：减少复杂度，降低资源泄露风险
- ✅ **适合嵌入式**：资源占用小，适合F133平台

---

## 七、总结

### 7.1 线程设计总结

**线程数量：2-3个（最小化）**
1. **主线程**：UI渲染、业务逻辑、事件处理 ✅ 必需
2. **播放器回调线程**：TPlayer回调 ✅ 必需（如果TPlayer需要）
3. **网络线程**：HTTP请求 ⚠️ 可选（如果使用异步网络）

### 7.2 事件系统总结

**事件类型：**
- 播放器事件（状态、进度、错误）
- 网络事件（HTTP响应、错误）
- UI事件（页面切换、点击）
- 系统事件（音量、音轨切换）

### 7.3 消息队列总结

**推荐方案（按GitHub Stars和更新频率排序）：**

**首选推荐：moodycamel::ConcurrentQueue** ⭐⭐⭐⭐⭐
- **GitHub Stars**：10,000+（最高）
- **更新频率**：2024年有更新（活跃）
- 成熟稳定，广泛使用
- 无锁设计，高性能
- 支持SPSC/MPSC/MPMC模式
- 可配置初始容量
- **推荐理由**：star数最多，更新活跃，功能全面

**如果只需要SPSC（单生产者单消费者）：**
1. **moodycamel::ReaderWriterQueue** ⭐⭐⭐⭐⭐ 推荐
   - **GitHub Stars**：1,000+（高）
   - **更新频率**：活跃维护
   - 成熟稳定，广泛使用
   - 轻量级，仅SPSC
   - 单头文件，易于集成

2. **tinySPSCQueue** ⚠️ 需验证
   - **GitHub Stars**：需验证（建议>1000）
   - **更新频率**：需验证（建议最近6个月内有更新）
   - 极轻量，专为SPSC设计
   - 适合嵌入式平台
   - **注意**：如果star数不足或更新不活跃，不推荐使用

**共同特点：**
- ✅ 无锁设计，高性能
- ✅ 单头文件，易于集成
- ✅ 预分配内存友好
- ✅ 解耦合，组件间通过消息队列通信
- ✅ 嵌入式友好，适合F133平台

### 7.4 核心原则

- ✅ **尽量少线程**：主线程 + 最小化后台线程
- ✅ **尽量无锁**：无锁消息队列，避免锁竞争
- ✅ **解耦合**：组件间通过消息队列通信
- ✅ **避免造轮子**：严格遵循避免造轮子原则，使用moodycamel::ConcurrentQueue开源库
- ✅ **简单实用**：单头文件库，易于集成
- ✅ **嵌入式可用**：资源占用可控，可配置初始容量

---

**总结**：采用最小化线程设计（2-3个线程），无锁消息队列（moodycamel::ConcurrentQueue开源库），事件驱动架构，解耦合设计，适合嵌入式平台。


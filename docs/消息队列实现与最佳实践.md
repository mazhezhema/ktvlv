# æ¶ˆæ¯é˜Ÿåˆ—å®ç°ä¸æœ€ä½³å®è·µ

> **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
> **æœ€åæ›´æ–°**ï¼š2025-12-30  
> **çŠ¶æ€**ï¼šâœ… æ ¸å¿ƒæ–‡æ¡£  
> **é€‚ç”¨å¹³å°**ï¼šTina Linux + F133 + LVGL 8.x  
> **ç›¸å…³æ–‡æ¡£**ï¼šè¯¦è§ [çº¿ç¨‹æ¶æ„åŸºçº¿ï¼ˆæœ€ç»ˆç‰ˆï¼‰.md](./çº¿ç¨‹æ¶æ„åŸºçº¿ï¼ˆæœ€ç»ˆç‰ˆï¼‰.md)

---

## ğŸ“Œ æ¶ˆæ¯é˜Ÿåˆ—çš„å®šä½ï¼ˆæ€»åŸåˆ™ï¼‰

> **æ¶ˆæ¯é˜Ÿåˆ—æ˜¯çº¿ç¨‹ä¹‹é—´çš„ä¸­ç«‹åŒº**  
> **UIçº¿ç¨‹åªæ¶ˆè´¹ï¼ˆpopï¼‰ï¼Œå…¶ä»–çº¿ç¨‹åªç”Ÿäº§ï¼ˆpushï¼‰**  
> **ç¦æ­¢è·¨çº¿ç¨‹ç›´æ¥è°ƒ LVGL**

```
    [Input Thread] ----push--â”
    [Biz Thread]   ----push--â”¤â†’ [MessageQueue] â†’(pop)â†’ UIçº¿ç¨‹ â†’ æ›´æ–°UI
    [Player Thread] ----push-â”˜
```

---

## ğŸ—ï¸ å®ç°æ–¹å¼

### â­ MVPé˜¶æ®µï¼šstd::queue + std::mutexï¼ˆæ¨èï¼‰

> **å½“å‰é˜¶æ®µçš„æœ€ä¼˜è§£**ï¼šç®€å•å¯é ï¼Œæ€§èƒ½è¶³å¤Ÿï¼Œå¼€å‘æˆæœ¬ä½ã€‚

```cpp
// msg_queue_std.h
#pragma once
#include <queue>
#include <mutex>

enum class EventType {
    TOUCH,
    SEARCH_DONE,
    PLAY_STATE_CHANGED,
    // ... å…¶ä»–äº‹ä»¶
};

struct EventMsg {
    EventType type;
    void* payload = nullptr;
    int value1 = 0;
    int value2 = 0;
};

class MsgQueueStd {
public:
    static constexpr int MAX_SIZE = 64;  // å®šé•¿é™åˆ¶
    
    bool push(const EventMsg& msg);
    bool pop(EventMsg& out);
    bool empty() const;
    int size() const;
    
private:
    std::queue<EventMsg> queue_;
    mutable std::mutex mtx_;
};

// msg_queue_std.cpp
bool MsgQueueStd::push(const EventMsg& msg) {
    std::lock_guard<std::mutex> lock(mtx_);
    
    // é˜Ÿåˆ—æ»¡äº†ï¼šä¸¢å¼ƒæœ€æ—§çš„ï¼Œä¿æŒå®æ—¶æ€§
    if (queue_.size() >= MAX_SIZE) {
        queue_.pop();
    }
    
    queue_.push(msg);
    return true;
}

bool MsgQueueStd::pop(EventMsg& out) {
    std::lock_guard<std::mutex> lock(mtx_);
    if (queue_.empty()) {
        return false;
    }
    
    out = queue_.front();
    queue_.pop();
    return true;
}

bool MsgQueueStd::empty() const {
    std::lock_guard<std::mutex> lock(mtx_);
    return queue_.empty();
}

int MsgQueueStd::size() const {
    std::lock_guard<std::mutex> lock(mtx_);
    return queue_.size();
}
```

**ç‰¹ç‚¹**ï¼š
- âœ… å®ç°ç®€å•ï¼Œæ ‡å‡†åº“ï¼Œæ— éœ€é¢å¤–ä¾èµ–
- âœ… çº¿ç¨‹å®‰å…¨ï¼ˆmutexä¿æŠ¤ï¼‰
- âœ… å®šé•¿é˜Ÿåˆ—ï¼Œæº¢å‡ºæ—¶ä¸¢å¼ƒæœ€æ—§æ¶ˆæ¯
- âœ… éé˜»å¡ï¼Œå¿«é€Ÿè¿”å›
- âœ… MVPé˜¶æ®µæ€§èƒ½å®Œå…¨å¤Ÿç”¨

---

### ğŸ”§ ä¼˜åŒ–æ–¹æ¡ˆï¼šRingBuffer é˜Ÿåˆ—ï¼ˆé¢„é‡äº§é˜¶æ®µï¼‰

> **é¢„é‡äº§é˜¶æ®µçš„ä¼˜åŒ–æ–¹æ¡ˆ**ï¼šæ›´ç¨³ã€æ›´çœå†…å­˜ã€å»¶è¿ŸæŠ–åŠ¨æ›´ä½ã€‚

#### RingBuffer ç»“æ„ä½“å®šä¹‰

```c
#define QUEUE_CAPACITY 64  // å¿…é¡»å®šé•¿

typedef enum {
    EVT_TOUCH,
    EVT_SEARCH_DONE,
    EVT_PLAY_STATE,
    EVT_SINGER_SELECTED,
    EVT_CATEGORY_CHANGED,
    EVT_SEARCH_STARTED,
    EVT_PLAY_REQUEST,
    EVT_PLAY_STATE_CHANGED,
    EVT_NETWORK_ERR,
    EVT_PLAYER_BUFFERING,
    EVT_PLAYER_FINISHED,
    EVT_VOLUME_CHANGED,
    EVT_ERROR,
} EventType;

typedef struct {
    EventType type;
    void *payload;  // æŒ‡é’ˆ/IDï¼Œä¸ä¼ å¤§å¯¹è±¡
    int value1;    // å¯é€‰ï¼šç®€å•å€¼
    int value2;    // å¯é€‰ï¼šç®€å•å€¼
} EventMsg;

typedef struct {
    EventMsg buf[QUEUE_CAPACITY];
    int head;
    int tail;
    pthread_mutex_t lock;
} MsgQueue;

// å…¨å±€æ¶ˆæ¯é˜Ÿåˆ—
MsgQueue g_msgq;
```

---

### pushï¼ˆåªç”Ÿäº§ï¼Œä¸è°ƒUIï¼‰

```c
bool msgq_push(MsgQueue *q, EventMsg e) {
    pthread_mutex_lock(&q->lock);

    int next = (q->head + 1) % QUEUE_CAPACITY;
    if(next == q->tail) {
        // é˜Ÿåˆ—æ»¡äº†ï¼šä¸¢å¼ƒæœ€æ—§çš„ï¼Œä¿æŒå®æ—¶æ€§å…³é”®
        q->tail = (q->tail + 1) % QUEUE_CAPACITY;
    }

    q->buf[q->head] = e;
    q->head = next;

    pthread_mutex_unlock(&q->lock);
    return true;
}
```

**ç‰¹ç‚¹**ï¼š
- âœ… å¤šçº¿ç¨‹å®‰å…¨ï¼ˆmutexä¿æŠ¤ï¼‰
- âœ… å®šé•¿é˜Ÿåˆ—ï¼Œæº¢å‡ºæ—¶ä¸¢å¼ƒæœ€æ—§æ¶ˆæ¯
- âœ… éé˜»å¡ï¼Œå¿«é€Ÿè¿”å›
- âŒ ä¸è°ƒç”¨ä»»ä½•LVGL API

---

### popï¼ˆåªèƒ½UIçº¿ç¨‹æ‰§è¡Œï¼‰

```c
bool msgq_pop(MsgQueue *q, EventMsg *out) {
    if(q->tail == q->head) return false; // empty

    pthread_mutex_lock(&q->lock);
    *out = q->buf[q->tail];
    q->tail = (q->tail + 1) % QUEUE_CAPACITY;
    pthread_mutex_unlock(&q->lock);

    return true;
}
```

**ç‰¹ç‚¹**ï¼š
- âœ… åªåœ¨UIçº¿ç¨‹è°ƒç”¨
- âœ… éé˜»å¡ï¼Œå¿«é€Ÿè¿”å›
- âœ… é˜Ÿåˆ—ä¸ºç©ºæ—¶è¿”å›false

---

### åˆå§‹åŒ–

```c
void msgq_init(MsgQueue *q) {
    q->head = 0;
    q->tail = 0;
    pthread_mutex_init(&q->lock, NULL);
}

void msgq_cleanup(MsgQueue *q) {
    pthread_mutex_destroy(&q->lock);
}
```

---

## ğŸ® UIä¸»å¾ªç¯çš„ä½¿ç”¨

```c
int main() {
    // åˆå§‹åŒ–
    msgq_init(&g_msgq);
    lv_init();
    // ... å…¶ä»–åˆå§‹åŒ–
    
    // UIä¸»å¾ªç¯
    while(1) {
        lv_timer_handler(); // LVGL ä¸»å¾ªç¯
        
        // å¤„ç†æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆUIçº¿ç¨‹å”¯ä¸€å®‰å…¨åœ°è°ƒç”¨LVGLï¼‰
        EventMsg e;
        while(msgq_pop(&g_msgq, &e)) {
            switch(e.type) {
                case EVT_SEARCH_DONE:
                    ui_update_list(e.payload);
                    break;
                case EVT_PLAY_STATE:
                    ui_update_player(e.payload);
                    break;
                case EVT_PLAYER_FINISHED:
                    ui_play_next();
                    break;
                case EVT_NETWORK_ERR:
                    ui_show_error("ç½‘ç»œé”™è¯¯");
                    break;
                // ... å…¶ä»–äº‹ä»¶å¤„ç†
            }
        }
        
        lv_tick_inc(5);
        usleep(5000); // 5ms tick
    }
}
```

ğŸ’¡ **UIåœ¨ä¸»çº¿ç¨‹å”¯ä¸€å®‰å…¨åœ°è°ƒç”¨LVGL**

---

## ğŸš¨ æœ€ä½³å®è·µï¼ˆå†™å…¥æ¶æ„æ–‡æ¡£çš„ï¼‰

| è§„åˆ™ | è§£é‡Š |
|------|------|
| ğŸ‘‰ **UIçº¿ç¨‹ â‰  ä¸šåŠ¡çº¿ç¨‹** | UIåªè´Ÿè´£LVGLï¼Œä¸èƒ½åšè€—æ—¶ä»»åŠ¡ |
| ğŸ‘‰ **äº‹ä»¶é©±åŠ¨ï¼Œä¸ä¸»åŠ¨ç­‰å¾…** | ä¸èƒ½åœ¨UIç­‰ç½‘ç»œ / æ’­æ”¾å™¨å“åº” |
| ğŸ‘‰ **å®šé•¿é˜Ÿåˆ—ï¼Œä¸¢å¼ƒæ—§æ¶ˆæ¯ä¼˜å…ˆçº§ > å †ç§¯** | ç‚¹æ­Œè®¾å¤‡å®æ—¶æ€§å¿…é¡»ç¨³ |
| ğŸ‘‰ **æ¶ˆæ¯å†…æ”¾ ID/æŒ‡é’ˆï¼Œä¸æ”¾å¤§æ•°æ®** | é¿å…ç¢ç‰‡ & å†…å­˜å‹åŠ› |
| ğŸ‘‰ **ä¸šåŠ¡çº¿ç¨‹ä¸èƒ½è°ƒLVGL API** | è·¨çº¿ç¨‹æ“ä½œ LVGL = å¿…å´© |
| ğŸ‘‰ **UIçº¿ç¨‹ç¦æ­¢ read(fd)/é˜»å¡IO** | è§¦æ‘¸è¯»å–å¿…é¡»ç‹¬ç«‹çº¿ç¨‹ |
| ğŸ‘‰ **æ‰€æœ‰çŠ¶æ€å˜åŒ–ç”±äº‹ä»¶é©±åŠ¨æ›´æ–°** | UIä¸å®šæ—¶å»è½®è¯¢æ’­æ”¾å™¨ |

---

## ğŸ§¨ é¿å‘æŒ‡å—ï¼ˆè¸©è¿‡çš„éƒ½å“­è¿‡ï¼‰

| é”™è¯¯è¡Œä¸º | åæœ | æ­£ç¡®å¤„ç† |
|---------|------|---------|
| âŒ UIçº¿ç¨‹ä¸­åšç½‘ç»œ / JSONè§£æ | ç•Œé¢å¡æ­»/é»‘å± | ç”¨äº‹ä»¶ â†’ æ¨ç»™ä¸šåŠ¡çº¿ç¨‹ |
| âŒ è¾“å…¥çº¿ç¨‹ç›´æ¥è°ƒç”¨ `lv_obj_set_x()` | éšæœºå´©æºƒ | pushäº‹ä»¶ â†’ UIçº¿ç¨‹å¤„ç† |
| âŒ é˜Ÿåˆ—æ— é™å¢é•¿ | å†…å­˜çˆ†ç‚¸/å»¶è¿Ÿ | å¿…é¡»å®šé•¿ï¼Œæº¢å‡ºä¸¢å¼ƒæ—§ |
| âŒ é˜Ÿåˆ—ä¼ é€’å¤§ç»“æ„ or å›¾ç‰‡ | å†…å­˜ç¢ç‰‡ï¼ŒTinaçˆ†æ ˆ | åªä¼ ID/æŒ‡é’ˆ/çŠ¶æ€ |
| âŒ UIç­‰å¾…æ’­æ”¾å™¨åŒæ­¥è¿”å› | æ­»é”/å¡é¡¿ | å›è°ƒ â†’ pushäº‹ä»¶ â†’ UIå“åº” |
| âŒ å¤šä¸ªçº¿ç¨‹ä¸€èµ·è°ƒLVGL | è¡€å´© | åªUIçº¿ç¨‹è§¦åŠLVGL |

ğŸ“Œ **ä¸€å¥è¯è®°ä½**ï¼š
**UI ä¸é˜»å¡ï¼Œä¸ç­‰å¾…ï¼Œä¸é‡è®¡ç®—**

---

## ğŸ¥‡ ç‚¹æ­Œæœºä¸“ç”¨äº‹ä»¶å»ºè®®ï¼ˆæšä¸¾ç¤ºä¾‹ï¼‰

```c
typedef enum {
    // è¾“å…¥äº‹ä»¶
    EVT_TOUCH,
    EVT_KEY_PRESSED,
    
    // æœç´¢äº‹ä»¶
    EVT_SEARCH_STARTED,
    EVT_SEARCH_DONE,
    EVT_SEARCH_ERROR,
    
    // æ’­æ”¾äº‹ä»¶
    EVT_PLAY_REQUEST,
    EVT_PLAY_STATE_CHANGED,  // playing/paused/stopped
    EVT_PLAYER_BUFFERING,
    EVT_PLAYER_FINISHED,
    EVT_PLAYER_ERROR,
    
    // åˆ—è¡¨äº‹ä»¶
    EVT_SINGER_SELECTED,
    EVT_CATEGORY_CHANGED,
    EVT_SONG_SELECTED,
    
    // æ§åˆ¶äº‹ä»¶
    EVT_VOLUME_CHANGED,
    EVT_TRACK_SWITCHED,  // åŸå”±/ä¼´å¥åˆ‡æ¢
    
    // ç½‘ç»œäº‹ä»¶
    EVT_NETWORK_ERR,
    EVT_NETWORK_CONNECTED,
    EVT_NETWORK_DISCONNECTED,
    
    // ç³»ç»Ÿäº‹ä»¶
    EVT_ERROR,
    EVT_WARNING,
} EventType;
```

ğŸ’¡ **é¿å…ç”¨å­—ç¬¦ä¸²/é­”æ³•å€¼**

âŒ **é”™è¯¯**ï¼š
```c
if(type == "play_state")  // å­—ç¬¦ä¸²æ¯”è¾ƒï¼Œæ˜“é”™
```

âœ… **æ­£ç¡®**ï¼š
```c
if(type == EVT_PLAY_STATE_CHANGED)  // æšä¸¾ï¼Œç±»å‹å®‰å…¨
```

---

## ğŸ“ ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹1ï¼šè¾“å…¥çº¿ç¨‹æ¨é€è§¦æ‘¸äº‹ä»¶

```c
// è¾“å…¥çº¿ç¨‹
void inputThread() {
    while (running) {
        struct input_event ev;
        read(input_fd, &ev, sizeof(ev));
        
        if (ev.type == EV_KEY && ev.code == BTN_TOUCH && ev.value == 1) {
            // è§¦æ‘¸æŒ‰ä¸‹ï¼Œæ¨é€äº‹ä»¶
            EventMsg msg;
            msg.type = EVT_TOUCH;
            msg.value1 = touch_x;
            msg.value2 = touch_y;
            msg.payload = NULL;
            msgq_push(&g_msgq, msg);
        }
    }
}
```

### ç¤ºä¾‹2ï¼šä¸šåŠ¡çº¿ç¨‹æ¨é€æœç´¢ç»“æœ

```c
// ä¸šåŠ¡çº¿ç¨‹
void businessThread() {
    while (running) {
        Task task = taskQueue.pop();
        
        if (task.type == TASK_SEARCH) {
            // ç½‘ç»œè¯·æ±‚
            auto result = httpGet("/api/search?q=" + task.keyword);
            auto songs = parseSongs(result);
            
            // æ¨é€æœç´¢ç»“æœäº‹ä»¶
            EventMsg msg;
            msg.type = EVT_SEARCH_DONE;
            msg.payload = songs;  // æŒ‡é’ˆï¼Œä¸å¤åˆ¶æ•°æ®
            msgq_push(&g_msgq, msg);
        }
    }
}
```

### ç¤ºä¾‹3ï¼šæ’­æ”¾å™¨å›è°ƒæ¨é€æ’­æ”¾çŠ¶æ€

```c
// tplayerå›è°ƒï¼ˆSDKçº¿ç¨‹ï¼‰
void tplayer_callback(int event, void* data) {
    EventMsg msg;
    msg.type = EVT_PLAY_STATE_CHANGED;
    msg.value1 = event;  // æ’­æ”¾çŠ¶æ€ç 
    msg.payload = data;
    msgq_push(&g_msgq, msg);
}
```

### ç¤ºä¾‹4ï¼šUIçº¿ç¨‹å¤„ç†äº‹ä»¶

```c
// UIçº¿ç¨‹ï¼ˆä¸»å¾ªç¯ï¼‰
void uiMainLoop() {
    while (running) {
        lv_timer_handler();
        
        // å¤„ç†æ‰€æœ‰å¾…å¤„ç†äº‹ä»¶
        EventMsg e;
        while (msgq_pop(&g_msgq, &e)) {
            switch (e.type) {
            case EVT_SEARCH_DONE:
                {
                    auto songs = (std::vector<Song>*)e.payload;
                    updateSongList(*songs);
                    delete songs;  // é‡Šæ”¾å†…å­˜
                }
                break;
                
            case EVT_PLAY_STATE_CHANGED:
                {
                    int state = e.value1;
                    if (state == PLAYING) {
                        lv_label_set_text(playButton, "æš‚åœ");
                    } else if (state == PAUSED) {
                        lv_label_set_text(playButton, "æ’­æ”¾");
                    }
                }
                break;
                
            case EVT_PLAYER_FINISHED:
                playNextSong();
                break;
                
            // ... å…¶ä»–äº‹ä»¶å¤„ç†
            }
        }
        
        lv_tick_inc(5);
        usleep(5000);
    }
}
```

---

## ğŸ”§ RingBuffer C++ å°è£…ç‰ˆæœ¬ï¼ˆä¼˜åŒ–æ–¹æ¡ˆï¼‰

```cpp
// msg_queue_ringbuffer.h
#pragma once
#include <mutex>
#include <atomic>

enum class EventType {
    TOUCH,
    SEARCH_DONE,
    PLAY_STATE_CHANGED,
    // ... å…¶ä»–äº‹ä»¶
};

struct EventMsg {
    EventType type;
    void* payload = nullptr;
    int value1 = 0;
    int value2 = 0;
};

class MsgQueueRingBuffer {
public:
    static constexpr int CAPACITY = 64;
    
    bool push(const EventMsg& msg);
    bool pop(EventMsg& out);
    bool empty() const;
    int size() const;
    
private:
    EventMsg buf_[CAPACITY];
    std::atomic<int> head_{0};
    std::atomic<int> tail_{0};
    std::mutex mtx_;
};

// msg_queue_ringbuffer.cpp
bool MsgQueueRingBuffer::push(const EventMsg& msg) {
    std::lock_guard<std::mutex> lock(mtx_);
    
    int next = (head_.load() + 1) % CAPACITY;
    if (next == tail_.load()) {
        // é˜Ÿåˆ—æ»¡äº†ï¼Œä¸¢å¼ƒæœ€æ—§çš„
        tail_.store((tail_.load() + 1) % CAPACITY);
    }
    
    buf_[head_.load()] = msg;
    head_.store(next);
    return true;
}

bool MsgQueueRingBuffer::pop(EventMsg& out) {
    if (head_.load() == tail_.load()) {
        return false;  // empty
    }
    
    std::lock_guard<std::mutex> lock(mtx_);
    out = buf_[tail_.load()];
    tail_.store((tail_.load() + 1) % CAPACITY);
    return true;
}
```

> **æ³¨æ„**ï¼šè¿™æ˜¯ä¼˜åŒ–æ–¹æ¡ˆï¼ŒMVPé˜¶æ®µä¸éœ€è¦ã€‚è¯¦è§ [std::queueåˆ°RingBufferè¿ç§»æŒ‡å—.md](./std::queueåˆ°RingBufferè¿ç§»æŒ‡å—.md)

---

## â­ ä¸€å¥è¯æ€»ç»“ï¼ˆå¯ä»¥å‘ç»™å›¢é˜Ÿï¼‰

> **çº¿ç¨‹æ¶æ„åŸºçº¿ï¼š**  
> UIä¸»çº¿ç¨‹è´Ÿè´£LVGLä¸æ¸²æŸ“ï¼›  
> è¾“å…¥/ä¸šåŠ¡/æ’­æ”¾å™¨çº¿ç¨‹é€šè¿‡**å®šé•¿æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆstd::queue + std::mutexï¼‰**å‘UIå‘é€çŠ¶æ€ï¼›  
> ç¦æ­¢è·¨çº¿ç¨‹è°ƒç”¨LVGLï¼ŒUIå›è°ƒä¸åšè€—æ—¶å¤„ç†ï¼›  
> ç³»ç»Ÿä»¥**äº‹ä»¶é©±åŠ¨**æ›¿ä»£"UIç­‰å¾…ä¸šåŠ¡"ï¼Œä¿è¯å®æ—¶æ€§ä¸ç¨³å®šæ€§ã€‚  
> **å½“å‰é˜¶æ®µç¬¦åˆæ€§èƒ½ä¸å¼€å‘æ•ˆç‡å¹³è¡¡ï¼Œåç»­é‡äº§å¯å‡çº§ä¸º RingBufferã€‚**

---

## ğŸ“Š å®ç°æ–¹æ¡ˆå¯¹æ¯”

| é˜¶æ®µ | æ–¹æ¡ˆ | ç†ç”± |
|------|------|------|
| **MVP** | std::queue + mutex | æœ€å°‘å¿ƒæ™ºè´Ÿæ‹…ï¼Œå…ˆè·‘é€š |
| **é¢„é‡äº§** | RingBufferï¼ˆé”/è½»é”ï¼‰ | æ›´ç¨³ã€æ›´çœå†…å­˜ |
| **å¤§è§„æ¨¡/å¤šè¾“å…¥** | Lock-free | ç­‰çœŸæ­£æœ‰ç—›ç‚¹å†ä¸Š |

ğŸ‘‰ **æ¢å¥è¯è¯´**ï¼šç°åœ¨åˆ«æƒ³å¤ªå¤šï¼Œ**std::queue å°±æ˜¯æœ€ä¼˜è§£**ã€‚

---

## ğŸ“‹ å®ç°æ£€æŸ¥æ¸…å•

### âœ… å¿…é¡»å®ç°ï¼ˆMVPé˜¶æ®µï¼‰

- [ ] å®šé•¿é˜Ÿåˆ—ï¼ˆstd::queueï¼Œå®¹é‡64ï¼‰
- [ ] çº¿ç¨‹å®‰å…¨çš„push/popï¼ˆmutexä¿æŠ¤ï¼‰
- [ ] é˜Ÿåˆ—æ»¡æ—¶ä¸¢å¼ƒæœ€æ—§æ¶ˆæ¯ï¼ˆä¿æŒå®æ—¶æ€§ï¼‰
- [ ] æ¶ˆæ¯åªä¼ ID/æŒ‡é’ˆï¼Œä¸ä¼ å¤§å¯¹è±¡
- [ ] UIçº¿ç¨‹åªpopï¼Œå…¶ä»–çº¿ç¨‹åªpush
- [ ] æ‰€æœ‰äº‹ä»¶ç±»å‹ä½¿ç”¨æšä¸¾ï¼Œä¸ç”¨å­—ç¬¦ä¸²

### âš ï¸ ç¦æ­¢äº‹é¡¹

- [ ] âŒ é˜Ÿåˆ—æ— é™å¢é•¿
- [ ] âŒ æ¶ˆæ¯ä¸­ä¼ é€’å¤§ç»“æ„æˆ–å›¾ç‰‡
- [ ] âŒ ä¸šåŠ¡çº¿ç¨‹ç›´æ¥è°ƒç”¨LVGL API
- [ ] âŒ UIçº¿ç¨‹ç­‰å¾…ä¸šåŠ¡çº¿ç¨‹åŒæ­¥è¿”å›
- [ ] âŒ å¤šä¸ªçº¿ç¨‹åŒæ—¶æ“ä½œé˜Ÿåˆ—ï¼ˆå¿…é¡»mutexä¿æŠ¤ï¼‰

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- **çº¿ç¨‹æ¶æ„åŸºçº¿**: [çº¿ç¨‹æ¶æ„åŸºçº¿ï¼ˆæœ€ç»ˆç‰ˆï¼‰.md](./çº¿ç¨‹æ¶æ„åŸºçº¿ï¼ˆæœ€ç»ˆç‰ˆï¼‰.md)
- **å¹¶å‘æ¶æ„æ€»ç»“æ„**: [å¹¶å‘æ¶æ„æ€»ç»“æ„ï¼ˆæœ€ç»ˆç‰ˆï¼‰.md](./architecture/å¹¶å‘æ¶æ„æ€»ç»“æ„ï¼ˆæœ€ç»ˆç‰ˆï¼‰.md)
- **äº‹ä»¶æ¶æ„è§„èŒƒ**: [äº‹ä»¶æ¶æ„è§„èŒƒ.md](./architecture/äº‹ä»¶æ¶æ„è§„èŒƒ.md)
- **èµ„æºç®¡ç†è§„èŒƒ**: [èµ„æºç®¡ç†è§„èŒƒv1.md](./èµ„æºç®¡ç†è§„èŒƒv1.md)
- **è¿ç§»æŒ‡å—**: [std_queueåˆ°RingBufferè¿ç§»æŒ‡å—.md](./std_queueåˆ°RingBufferè¿ç§»æŒ‡å—.md) â­ **é¢„é‡äº§é˜¶æ®µå‚è€ƒ**

---

**æœ€åæ›´æ–°**: 2025-12-30  
**çŠ¶æ€**: âœ… æ ¸å¿ƒæ–‡æ¡£ï¼Œæ¶ˆæ¯é˜Ÿåˆ—å®ç°ä¸æœ€ä½³å®è·µ


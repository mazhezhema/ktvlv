# 线程架构基线（最终版）

> **文档版本**：v1.0  
> **最后更新**：2025-12-30  
> **状态**：✅ 核心文档  
> **适用平台**：Tina Linux + F133 + LVGL 8.x  
> **相关文档**：详见 [并发架构总结构（最终版）.md](./architecture/并发架构总结构（最终版）.md)

---

## 📌 一句话架构原则

> **"LVGL单线程，输入分离，业务旁路，消息通信。"**

**详细版**：
```
UI线程做显示
输入线程做感知
业务线程做计算
通信只过队列
不跨线程调LVGL
```

---

## 🧵 线程设计铁律（工程负责人视角）

> **⚠️ 核心原则**：本项目中，线程尽量常驻，但必须明确"线程常驻，任务按需唤醒/休眠"的前提。

> **⚠️ Singleton 原则**：**线程本身不是 Singleton，线程"宿主对象"是 Singleton。** 核心线程（UI、Event、Network、Player 等）的宿主对象必须是 Singleton，业务逻辑不得自行创建线程，只能向已有线程投递任务。

### 线程设计原则（必须遵守）

1. **线程尽量常驻**：除极少数一次性初始化线程外，业务线程均采用常驻模型
2. **常驻线程不得 busy-loop**：所有常驻线程必须阻塞等待（queue / cond / fd）
3. **任务按需唤醒/休眠**：线程常驻，任务不常驻，通过阻塞机制实现按需调度
4. **可被安全唤醒**：所有常驻线程必须能被安全唤醒
5. **可被安全退出**：App 退出时，所有线程必须能被安全退出

### 关键理解

**不是：**
> 所有线程什么都不干也常驻

**而是：**
> 线程常驻，**任务按需唤醒 / 休眠**

**为什么在 Tina / F133 上是对的？**

1. **pthread 创建/回收并不便宜**：频繁创建/销毁线程成本高
2. **内存碎片比线程数更危险**：常驻线程内存分配稳定，避免碎片
3. **工程师更容易写对阻塞模型**：阻塞等待比动态创建/销毁更简单
4. **问题更容易复现**：线程 ID 稳定，日志和排障更友好
5. **嵌入式工程不是追求"优雅"，而是追求"不会死"**：量产工程思维

---

## 🧵 最终推荐线程模型（稳、简单、可扩展）

### 线程分类（三类常驻线程）

#### ① 核心常驻线程（App 生命周期）

**必须常驻，且几乎不允许退出**

| 线程名 | 职责 | 是否阻塞 | 阻塞方式 | 和谁交互 | 备注 |
|--------|------|---------|---------|---------|------|
| **UI主线程** *(必有)* | LVGL、页面渲染、控件命中、事件派发 | ❌不能堵 | `lv_timer_handler()` 轮询 | 调 read_cb 获取输入 | 永远是主循环 |
| **Event Loop** *(必有)* | 事件分发、UiEventQueue 消费 | ✔️阻塞OK | `queue.wait()` / `cond_wait` | 所有线程 → UI | 事件分发中心 |

**特点**：
- App 在，它就在
- 只做调度，不干重活
- 出问题 = App 级异常

#### ② 工作线程池（常驻，但可空转）

**线程常驻，任务不常驻**

| 线程名 | 职责 | 是否阻塞 | 阻塞方式 | 和谁交互 | 备注 |
|--------|------|---------|---------|---------|------|
| **Network Worker** | HTTP请求、WebSocket、网络IO | ✔️阻塞OK | `queue.wait()` / `cond_wait` | UI → Network | 网络请求处理 |
| **Player Worker** | 播放器控制、TPlayer调用 | ✔️阻塞OK | `PlayerCmdQueue.wait()` / `cond_wait` | UI → Player | 播放器线程 |
| **Cache/IO Worker** | 文件IO、缓存管理 | ✔️阻塞OK | `queue.wait()` / `cond_wait` | UI → Cache | 文件操作 |

**实现要求**：
- ✅ 使用 `std::queue + mutex + condition_variable`
- ✅ 无任务时 `cond_wait`（阻塞等待）
- ✅ 有任务时被唤醒
- ❌ **不允许 while(1)+sleep**（空转消耗CPU）

👉 **这类线程是"常驻外壳 + 动态任务"**

#### ③ 低频守护线程（常驻 + 定时唤醒）

**周期唤醒，不参与业务路径**

| 线程名 | 职责 | 是否阻塞 | 阻塞方式 | 和谁交互 | 备注 |
|--------|------|---------|---------|---------|------|
| **LogUpload** | 日志上传 | ✔️阻塞OK | `sleep()` / `timerfd` | 独立运行 | 低优先级，可忽略退出 |
| **Upgrade Checker** | 升级检测 | ✔️阻塞OK | `sleep()` / `timerfd` | 独立运行 | 周期检测（分钟级） |
| **Heartbeat/Watchdog** | 心跳检测 | ✔️阻塞OK | `sleep()` / `timerfd` | 独立运行 | 进程级Watchdog |

**建议**：
- 使用 `sleep()` / `timerfd` / `select()` 实现周期唤醒
- 周期 ≥ 秒级
- 不参与业务路径

---

## 🚫 哪些线程不应该常驻（明确禁止）

### ❌ 禁止事项

1. **禁止为每次点歌创建线程**
   - ❌ `std::thread(play_song, url).detach()` - 错误！
   - ✅ 使用常驻 Player Worker，通过队列发送命令

2. **禁止为每次 HTTP 创建线程**
   - ❌ `std::thread(http_request, url).detach()` - 错误！
   - ✅ 使用常驻 Network Worker，通过队列发送请求

3. **禁止 UI 点击直接起线程**
   - ❌ 按钮回调中 `new std::thread(...)` - 错误！
   - ✅ 发送命令到工作线程队列

4. **禁止播放结束不回收线程对象**
   - ❌ 播放结束后线程对象残留 - 错误！
   - ✅ 线程常驻，但任务完成后线程进入阻塞等待状态

### 关键原则

> **线程是常驻资源，不是业务对象**

线程应该在 App 启动时创建，App 退出时销毁，而不是随业务操作创建和销毁。

---

## 🏗️ 线程 Singleton 设计原则

### 核心原则（一句话）

> **线程本身不是 Singleton，线程"宿主对象"是 Singleton。**

### 必须使用 Singleton 的线程（白名单）

本项目中，以下核心线程的宿主对象**必须**是 Singleton：

| 线程 | 宿主对象 Singleton | 原因 | 生命周期 |
|------|-------------------|------|---------|
| **UI/LVGL 主线程** | `UISystem::instance()` | 全局唯一 display、input，不允许多实例 | App 生命周期 |
| **Event Dispatch** | `EventBus::getInstance()` | 全局事件总线，所有模块共享 | App 生命周期 |
| **Network Worker** | `NetworkWorker::instance()` | libcurl 全局初始化、连接复用、DNS/TLS 状态共享 | App 生命周期 |
| **Player Worker** | `PlayerAdapter::instance()` | TPlayer 全局唯一、硬件资源独占 | App 生命周期 |
| **LogUpload** | `LogUploadService::instance()` | 全局日志上传服务 | App 生命周期 |
| **Upgrade Checker** | `UpgradeService::instance()` | 全局升级检测，不允许重复执行 | App 生命周期 |

### 不应该使用 Singleton 的线程（明确禁止）

以下场景**不应该**创建线程，更不应该使用 Singleton：

❌ **页面级线程**
- 搜索一次 → 应该投递到 Network Worker 队列
- 列表刷新一次 → 应该投递到 Network Worker 队列
- 点歌一次 → 应该投递到 Player Worker 队列

❌ **临时业务线程**
- HTTP 请求 → 应该投递到 Network Worker 队列
- 文件 IO → 应该投递到 Cache Worker 队列
- JSON 解析 → 应该投递到工作线程队列

👉 **这些根本不该起线程，应该扔进已有 Worker 的队列**

### 最终规范表述

> 本项目中，UI、事件分发、网络、播放等核心线程均以 Singleton 形式存在，
> 线程宿主对象全局唯一、生命周期与应用一致；
> 业务逻辑不得自行创建线程，只能向已有线程投递任务。

**详细说明**：详见 [KTV_App线程Singleton编码规范（最终版）.md](./guides/KTV_App线程Singleton编码规范（最终版）.md) ⭐⭐⭐ **必读（铁律级）**

---

## 🧵 线程生命周期 & 退出顺序（量产必读）

> **⚠️ 重要**：线程生命周期不明确是内存泄漏的主要原因。必须明确每个线程的创建时机、退出时机和重启策略。

### 线程生命周期表

| 线程 | 创建时机 | 退出时机 | 是否可重启 | 退出顺序 | 说明 |
|------|---------|---------|-----------|---------|------|
| **UI/LVGL 主线程** | App 启动 | App 退出 | ❌ 否 | 最后退出（第5） | 主线程，管理所有 UI 资源，必须最后退出 |
| **Event Loop** | App 启动 | App 退出 | ❌ 否 | 倒数第二（第4） | 事件分发，必须在 UI 之前退出 |
| **Network Worker** | 启动后立即创建 | 网络异常可重启 | ✅ 是 | 第 3 | 网络请求处理，可独立重启（最多 5 次/小时） |
| **Player Worker** | 点歌时创建 | 播放结束或停止 | ✅ 是 | 第 2 | 播放器线程，每次播放创建新线程（最多 3 次/播放） |
| **LogUpload** | 启动后创建 | App 退出 | ✅ 是（低优先级） | 第 1 | 日志上传，低优先级，可忽略退出 |

### 退出顺序设计

**关键原则**：
1. **依赖关系决定退出顺序**：被依赖的线程先退出
2. **资源清理顺序**：先清理业务资源，再清理系统资源
3. **优雅退出**：设置退出标志，等待线程自然退出（超时强制退出）

**退出流程**：

```
1. 设置全局退出标志 (g_app_quit = true)
2. 停止 LogUpload 线程（第1，低优先级）
3. 停止 Player Worker 线程（第2，播放器线程）
4. 停止 Network Worker 线程（第3，网络线程）
5. 停止 Event Loop（第4，事件分发）
6. 停止 UI/LVGL 主线程（第5，最后清理 UI 资源）
7. 清理全局资源（Singleton 实例）
8. 退出主进程
```

**代码示例**：

```c
// 全局退出标志
static volatile bool g_app_quit = false;

// 退出顺序控制
static void cleanup_threads(void) {
    // 1. 设置退出标志
    g_app_quit = true;
    
    // 2. 停止 Worker 线程（按顺序）
    log_upload_service_stop();      // LogUpload（第1）
    player_service_stop();           // Player（第2）
    network_service_stop();          // Network（第3）
    
    // 3. 停止 Event Loop（倒数第二）
    event_bus_stop();
    
    // 4. 停止 UI/LVGL（最后）
    ui_system_cleanup();
    
    // 5. 清理全局资源
    cleanup_singletons();
}
```

### 线程重启策略

**可重启线程的重启规则**：

| 线程 | 重启触发条件 | 重启延迟 | 最大重启次数 | 重启后行为 |
|------|------------|---------|------------|-----------|
| Network Worker | 网络异常、连接断开 | 3 秒 | 5 次/小时 | 重新初始化网络连接 |
| Player Worker | 播放失败、TPlayer 异常 | 立即 | 3 次/播放 | 重新创建播放器实例 |
| LogUpload | 上传失败 | 指数退避（10s, 30s, 60s） | 无限制（低优先级） | 继续重试上传 |

**⚠️ 重要提示**：
- UI/LVGL 主线程和 Event Loop **不可重启**，退出后必须重启整个应用
- 所有线程必须有明确的创建点和退出点
- 线程退出时必须释放所有分配的资源

**详细说明**：详见 [KTV_App稳定性与自愈设计说明.md](../sdk/KTV_App稳定性与自愈设计说明.md)

---

## 📌 线程设计原则总结

### 核心原则

1. **线程尽量常驻**：除极少数一次性初始化线程外，业务线程均采用常驻模型
2. **任务按需唤醒/休眠**：线程常驻，任务不常驻，通过阻塞机制实现按需调度
3. **常驻线程不得 busy-loop**：所有常驻线程必须阻塞等待（queue / cond / fd）
4. **线程是常驻资源，不是业务对象**：线程在 App 启动时创建，App 退出时销毁

### 阻塞方式说明

| 线程类型 | 阻塞方式 | 说明 |
|---------|---------|------|
| UI 主线程 | `lv_timer_handler()` 轮询 | 不阻塞，轮询模式 |
| Event Loop | `queue.wait()` / `cond_wait` | 阻塞在事件队列 |
| Network Worker | `queue.wait()` / `cond_wait` | 阻塞在任务队列 |
| Player Worker | `PlayerCmdQueue.wait()` / `cond_wait` | 阻塞在命令队列 |
| LogUpload | `sleep()` / `timerfd` | 周期唤醒（秒级） |
| UpgradeChecker | `sleep()` / `timerfd` | 周期唤醒（分钟级） |

---

## 📌 最小可用方案（MVP）

```
UI线程 + 输入线程 = 可跑
```

**说明**：
- UI主线程：LVGL渲染和事件处理
- 输入线程：读取触摸事件，更新共享状态
- 业务逻辑直接在UI回调中处理（简单场景）

---

## 📌 推荐量产方案

```
UI线程 + 输入线程 + 业务线程池/队列
```

**说明**：
- UI主线程：LVGL渲染和事件处理
- 输入线程：读取触摸事件，更新共享状态
- 业务线程：网络请求、播放控制、数据解析等耗时操作
- 通过消息队列进行线程间通信

---

## 🧠 线程交互方式（最佳实践）

### 🟢 输入 → UI（单向）

> **共享状态结构 + 互斥锁**（atomic/轻锁）

```cpp
// 共享触摸状态
struct TouchState {
    std::atomic<bool> pressed{false};
    std::atomic<int> x{0};
    std::atomic<int> y{0};
};

TouchState g_touch;

// 输入线程（只写）
void inputThread() {
    while (running) {
        // 读取触摸事件
        struct input_event ev;
        read(input_fd, &ev, sizeof(ev));
        
        // 更新共享状态
        if (ev.type == EV_ABS) {
            if (ev.code == ABS_X) {
                g_touch.x.store(ev.value);
            } else if (ev.code == ABS_Y) {
                g_touch.y.store(ev.value);
            }
        } else if (ev.type == EV_KEY && ev.code == BTN_TOUCH) {
            g_touch.pressed.store(ev.value != 0);
        }
    }
}

// UI线程 read_cb（只读）
void input_read_cb(lv_indev_drv_t* drv, lv_indev_data_t* data) {
    data->point.x = g_touch.x.load();
    data->point.y = g_touch.y.load();
    data->state = g_touch.pressed.load() ? LV_INDEV_STATE_PRESSED : LV_INDEV_STATE_RELEASED;
}
```

**规则**：
- ✅ UI read_cb 只读
- ✅ InputThread 只写
- ❌ 不互相调函数
- ❌ 不跨线程LVGL调用

**理由**：**避免跨线程调用LVGL API → LVGL不是线程安全的！**

---

### 🟧 UI → 业务（双向可控）

> **异步任务队列 / 消息队列 (MessageBus)**
> 推荐：**ringbuffer / lock-free queue / simple struct队列**

```cpp
// 任务队列（UI → 业务）
struct Task {
    enum Type { SEARCH, PLAY, PAUSE, LOAD_CHART };
    Type type;
    std::string data;  // JSON或参数
};

// UI线程（按钮回调）
void onSearchButtonClick(lv_event_t* e) {
    std::string keyword = getSearchKeyword();
    
    // 发送任务到业务线程（非阻塞）
    Task task{Task::SEARCH, keyword};
    businessQueue.push(task);
}

// 业务线程
void businessThread() {
    while (running) {
        auto task = businessQueue.pop();  // 阻塞等待
        
        switch (task.type) {
        case Task::SEARCH:
            // 网络请求
            auto result = httpGet("/api/search?q=" + task.data);
            // 解析JSON
            auto songs = parseSongs(result);
            // 回传UI事件
            uiEventQueue.push({UIEvent::SEARCH_RESULT, songs});
            break;
        }
    }
}

// UI线程（定期检查事件队列）
void uiMainLoop() {
    while (running) {
        lv_timer_handler();
        
        // 处理业务线程回传的事件
        while (auto event = uiEventQueue.tryPop()) {
            handleUIEvent(*event);
        }
        
        lv_tick_inc(5);
        usleep(5000);
    }
}
```

**规则**：
- ✅ UI线程（按钮回调）→ push任务到队列
- ✅ 业务线程 → pop任务处理（网络/播放/歌库）
- ✅ 处理完再 push "事件结束/数据返回"
- ✅ UI根据业务回传更新界面

**一定不要**：
- ❌ UI事件回调里直接做网络/播放阻塞
- ❌ 业务线程直接调 LVGL API

**正确做法**：
- ✔️ 业务线程用回调/状态 → 通知 UI → UI线程执行界面更新

---

### 🟡 播放器（tplayer/ijk等）

> 原则：**播放器自己一套线程，不进UI事件体系**

```cpp
// 播放器控制（通过PlayerService）
void onPlayButtonClick(lv_event_t* e) {
    // UI线程：发送播放命令
    PlayerService::instance().play(songUrl);
}

// PlayerService内部（业务线程）
void PlayerService::play(const std::string& url) {
    // 在播放器线程中执行
    playerThread.enqueue([url]() {
        tplayer_set_data_source(player, url.c_str());
        tplayer_prepare(player);
        tplayer_start(player);
    });
}

// tplayer回调（SDK线程）
void tplayer_callback(int event, void* data) {
    // 回调 → 推消息到UI线程
    PlayerEvent ev;
    ev.type = translateEvent(event);
    uiEventQueue.push(ev);
}

// UI线程（处理播放器事件）
void handlePlayerEvent(const PlayerEvent& ev) {
    switch (ev.type) {
    case PlayerEvent::PLAYING:
        lv_label_set_text(playButton, "暂停");
        break;
    case PlayerEvent::PAUSED:
        lv_label_set_text(playButton, "播放");
        break;
    }
}
```

**规则**：
- ✅ 只通过 **API/FD/回调** 控制播放器
- ✅ 播放状态通过 **回调事件 → 推消息到UI线程**
- ✅ UI线程接到消息 → 更新控件状态 / 变按钮文本
- ❌ 不在播放器回调中直接调用LVGL API

---

## 🧩 线程拓扑结构

```
             ┌──────────────────────────────┐
             │          输入线程             │
触摸硬件 →   │  read(eventX) 解析坐标        │
             │  更新 g_touch_state           │
             └──────────▲───────────────────┘
                        │共享状态
 ┌──────────────────────┼──────────────────────────┐
 │                      │                          │
 │                      │                          │
 ▼                      │                          │
 UI主线程───────────────┘                          │
 lv_timer_handler()                                   │
 * 自动调用read_cb()                                   │
 * 事件派发/点击/控件命中                              │
 * 用户点击回调 → 生产任务 → 放入队列 ◄───────────────┐
                                                         │
                                                         │
                                  ┌───────────────────────┘
                                  │
                                  ▼
                        业务线程/线程池
                        * 歌库搜索
                        * 播放器控制(IC)
                        * 网络请求
                        * 缓存加载/JSON解析
                        * 完成后 → 回传UI事件
```

⚠️ **注意**：

> UI与业务线程之间的唯一边界：📌**队列+回调分发**  
> 不要越界调用UI函数

---

## 🧨 避坑指南（工程级）

| 坑 | 为什么炸 | 规避策略 |
|------|---------|---------|
| **UI回调里搞网络/播放** | 卡主LVGL刷新 → 黑屏卡死 | UI只发"任务指令"，业务线程执行 |
| **read(fd)放到主线程** | 阻塞UI循环 | 必须独立线程 |
| **多线程调用LVGL API** | UI竞争崩溃 | UI唯一线程原则 |
| **图片/字体加载放UI线程** | 卡首屏加载 | 预加载/后台异步+UI完成通知 |
| **队列无容量控制** | 消息堆积 → 内存炸 | 固定容量RingBuffer |
| **线程间共享结构无锁** | 随机崩溃 | 用原子变量或轻锁Mutex |
| **tplayer/ijk回调调UI** | 跨线程野调用 | 回调 → 队列 → UI更新 |

---

## 🔥 最佳黄金准则（可挂墙）

> **"LVGL单线程，输入分离，业务旁路，消息通信。"**

**一句话版**：

```
UI线程做显示
输入线程做感知
业务线程做计算
通信只过队列
不跨线程调LVGL
```

这就是嵌入式 UI 架构中最核心的生存法则。

---

## 🚀 落地优先顺序

### 阶段1：最小可用（MVP）

1. 🟢 **UI主线程 + 输入线程** 拉通触摸 → 已通
   - UI主线程：LVGL渲染循环
   - 输入线程：读取触摸事件，更新共享状态
   - 简单业务逻辑直接在UI回调中处理

### 阶段2：业务分离

2. 🟡 **加消息队列** → UI回调不做耗时逻辑
   - 创建业务线程
   - UI回调只发送任务到队列
   - 业务线程处理网络/播放等耗时操作

### 阶段3：播放器集成

3. 🔵 **接 tplayer/ijk** → 回调状态 → 消息通知 UI
   - 播放器控制通过PlayerService
   - 播放器回调推事件到UI队列
   - UI线程处理播放器事件

### 阶段4：资源优化

4. 🟣 **资源/字体/图片加载** → 后台加载 + UI完成提示
   - 图片/字体预加载
   - 后台线程加载，完成后通知UI
   - UI显示加载进度

---

## 🎯 一句话给团队（直接转发）

> 系统架构采用 3-4 线程体系：UI主线程负责LVGL与界面渲染；输入线程阻塞读取触摸事件更新共享状态；业务线程池负责网络/播放/歌库等耗时任务；播放器线程（tplayer内部）处理媒体播放。各线程间使用无锁队列与事件驱动进行通信，禁止跨线程调用LVGL API，确保UI实时性与系统稳定性。

---

## 📋 实现检查清单

### ✅ 必须实现

- [ ] UI主线程：LVGL渲染循环（`lv_timer_handler()`）
- [ ] 输入线程：读取触摸事件，更新共享状态
- [ ] 共享状态：使用atomic或mutex保护
- [ ] 消息队列：UI → 业务线程
- [ ] 事件队列：业务线程 → UI线程
- [ ] 播放器服务：封装tplayer调用
- [ ] 播放器回调：推事件到UI队列

### ⚠️ 禁止事项

- [ ] ❌ UI回调中直接网络请求
- [ ] ❌ UI回调中直接播放控制
- [ ] ❌ 业务线程直接调用LVGL API
- [ ] ❌ 播放器回调直接调用LVGL API
- [ ] ❌ 输入线程直接调用LVGL API
- [ ] ❌ 跨线程共享LVGL对象

---

## 📚 相关文档

- **线程Singleton编码规范**: [KTV_App线程Singleton编码规范（最终版）.md](./guides/KTV_App线程Singleton编码规范（最终版）.md) ⭐⭐⭐ **必读（铁律级）** - 完整的模板代码、避坑指南和工程铁律
- **并发架构总结构（最终版）**: [并发架构总结构（最终版）.md](./architecture/并发架构总结构（最终版）.md)
- **事件架构规范**: [事件架构规范.md](./architecture/事件架构规范.md)
- **资源管理规范**: [资源管理规范v1.md](./资源管理规范v1.md)
- **团队开发规范**: [团队开发规范v1.md](./团队开发规范v1.md)

---

**最后更新**: 2025-12-30  
**状态**: ✅ 核心文档，线程架构基线（最终版）



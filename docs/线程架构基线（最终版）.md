# 线程架构基线（最终版）

> **文档版本**：v1.0  
> **最后更新**：2025-12-30  
> **状态**：✅ 核心文档  
> **适用平台**：Tina Linux + F133 + LVGL 8.x  
> **相关文档**：详见 [并发架构总结构（最终版）.md](./architecture/并发架构总结构（最终版）.md)

---

## 📌 一句话架构原则

> **"LVGL单线程，输入分离，业务旁路，消息通信。"**

**详细版**：
```
UI线程做显示
输入线程做感知
业务线程做计算
通信只过队列
不跨线程调LVGL
```

---

## 🧵 最终推荐线程模型（稳、简单、可扩展）

| 线程名 | 职责 | 是否阻塞 | 和谁交互 | 备注 |
|--------|------|---------|---------|------|
| **UI主线程** *(必有)* | LVGL、页面渲染、控件命中、事件派发 | ❌不能堵 | 调 read_cb 获取输入 | 永远是主循环：`lv_timer_handler()` |
| **输入线程** *(Touch)* | read(fd)/poll(eventX)、解析触摸事件 → 写状态 | ✔️阻塞OK | 写共享状态给 UI 线程 | 类似 epoll_wait 模型 |
| **业务线程** *(可选/建议)* | 网络请求、歌库、播放指令、数据库、解析 | ⚠️不能卡UI | 通过队列/事件交互 | 避免把耗时逻辑扔到UI回调 |
| **播放器/媒体线程** *(可选)* | tplayer/ffmpeg/ijk 播放任务 | 内部阻塞安全 | 消息队列同步 UI | Tina板卡一般播放器内部自带 |

---

## 🧵 线程生命周期 & 退出顺序（量产必读）

> **⚠️ 重要**：线程生命周期不明确是内存泄漏的主要原因。必须明确每个线程的创建时机、退出时机和重启策略。

### 线程生命周期表

| 线程 | 创建时机 | 退出时机 | 是否可重启 | 退出顺序 | 说明 |
|------|---------|---------|-----------|---------|------|
| **UI/LVGL 主线程** | App 启动 | App 退出 | ❌ 否 | 最后退出（第5） | 主线程，管理所有 UI 资源，必须最后退出 |
| **Event Loop** | App 启动 | App 退出 | ❌ 否 | 倒数第二（第4） | 事件分发，必须在 UI 之前退出 |
| **Network Worker** | 启动后立即创建 | 网络异常可重启 | ✅ 是 | 第 3 | 网络请求处理，可独立重启（最多 5 次/小时） |
| **Player Worker** | 点歌时创建 | 播放结束或停止 | ✅ 是 | 第 2 | 播放器线程，每次播放创建新线程（最多 3 次/播放） |
| **LogUpload** | 启动后创建 | App 退出 | ✅ 是（低优先级） | 第 1 | 日志上传，低优先级，可忽略退出 |

### 退出顺序设计

**关键原则**：
1. **依赖关系决定退出顺序**：被依赖的线程先退出
2. **资源清理顺序**：先清理业务资源，再清理系统资源
3. **优雅退出**：设置退出标志，等待线程自然退出（超时强制退出）

**退出流程**：

```
1. 设置全局退出标志 (g_app_quit = true)
2. 停止 LogUpload 线程（第1，低优先级）
3. 停止 Player Worker 线程（第2，播放器线程）
4. 停止 Network Worker 线程（第3，网络线程）
5. 停止 Event Loop（第4，事件分发）
6. 停止 UI/LVGL 主线程（第5，最后清理 UI 资源）
7. 清理全局资源（Singleton 实例）
8. 退出主进程
```

**代码示例**：

```c
// 全局退出标志
static volatile bool g_app_quit = false;

// 退出顺序控制
static void cleanup_threads(void) {
    // 1. 设置退出标志
    g_app_quit = true;
    
    // 2. 停止 Worker 线程（按顺序）
    log_upload_service_stop();      // LogUpload（第1）
    player_service_stop();           // Player（第2）
    network_service_stop();          // Network（第3）
    
    // 3. 停止 Event Loop（倒数第二）
    event_bus_stop();
    
    // 4. 停止 UI/LVGL（最后）
    ui_system_cleanup();
    
    // 5. 清理全局资源
    cleanup_singletons();
}
```

### 线程重启策略

**可重启线程的重启规则**：

| 线程 | 重启触发条件 | 重启延迟 | 最大重启次数 | 重启后行为 |
|------|------------|---------|------------|-----------|
| Network Worker | 网络异常、连接断开 | 3 秒 | 5 次/小时 | 重新初始化网络连接 |
| Player Worker | 播放失败、TPlayer 异常 | 立即 | 3 次/播放 | 重新创建播放器实例 |
| LogUpload | 上传失败 | 指数退避（10s, 30s, 60s） | 无限制（低优先级） | 继续重试上传 |

**⚠️ 重要提示**：
- UI/LVGL 主线程和 Event Loop **不可重启**，退出后必须重启整个应用
- 所有线程必须有明确的创建点和退出点
- 线程退出时必须释放所有分配的资源

**详细说明**：详见 [KTV_App稳定性与自愈设计说明.md](../sdk/KTV_App稳定性与自愈设计说明.md)

---

## 📌 最小可用方案（MVP）

```
UI线程 + 输入线程 = 可跑
```

**说明**：
- UI主线程：LVGL渲染和事件处理
- 输入线程：读取触摸事件，更新共享状态
- 业务逻辑直接在UI回调中处理（简单场景）

---

## 📌 推荐量产方案

```
UI线程 + 输入线程 + 业务线程池/队列
```

**说明**：
- UI主线程：LVGL渲染和事件处理
- 输入线程：读取触摸事件，更新共享状态
- 业务线程：网络请求、播放控制、数据解析等耗时操作
- 通过消息队列进行线程间通信

---

## 🧠 线程交互方式（最佳实践）

### 🟢 输入 → UI（单向）

> **共享状态结构 + 互斥锁**（atomic/轻锁）

```cpp
// 共享触摸状态
struct TouchState {
    std::atomic<bool> pressed{false};
    std::atomic<int> x{0};
    std::atomic<int> y{0};
};

TouchState g_touch;

// 输入线程（只写）
void inputThread() {
    while (running) {
        // 读取触摸事件
        struct input_event ev;
        read(input_fd, &ev, sizeof(ev));
        
        // 更新共享状态
        if (ev.type == EV_ABS) {
            if (ev.code == ABS_X) {
                g_touch.x.store(ev.value);
            } else if (ev.code == ABS_Y) {
                g_touch.y.store(ev.value);
            }
        } else if (ev.type == EV_KEY && ev.code == BTN_TOUCH) {
            g_touch.pressed.store(ev.value != 0);
        }
    }
}

// UI线程 read_cb（只读）
void input_read_cb(lv_indev_drv_t* drv, lv_indev_data_t* data) {
    data->point.x = g_touch.x.load();
    data->point.y = g_touch.y.load();
    data->state = g_touch.pressed.load() ? LV_INDEV_STATE_PRESSED : LV_INDEV_STATE_RELEASED;
}
```

**规则**：
- ✅ UI read_cb 只读
- ✅ InputThread 只写
- ❌ 不互相调函数
- ❌ 不跨线程LVGL调用

**理由**：**避免跨线程调用LVGL API → LVGL不是线程安全的！**

---

### 🟧 UI → 业务（双向可控）

> **异步任务队列 / 消息队列 (MessageBus)**
> 推荐：**ringbuffer / lock-free queue / simple struct队列**

```cpp
// 任务队列（UI → 业务）
struct Task {
    enum Type { SEARCH, PLAY, PAUSE, LOAD_CHART };
    Type type;
    std::string data;  // JSON或参数
};

// UI线程（按钮回调）
void onSearchButtonClick(lv_event_t* e) {
    std::string keyword = getSearchKeyword();
    
    // 发送任务到业务线程（非阻塞）
    Task task{Task::SEARCH, keyword};
    businessQueue.push(task);
}

// 业务线程
void businessThread() {
    while (running) {
        auto task = businessQueue.pop();  // 阻塞等待
        
        switch (task.type) {
        case Task::SEARCH:
            // 网络请求
            auto result = httpGet("/api/search?q=" + task.data);
            // 解析JSON
            auto songs = parseSongs(result);
            // 回传UI事件
            uiEventQueue.push({UIEvent::SEARCH_RESULT, songs});
            break;
        }
    }
}

// UI线程（定期检查事件队列）
void uiMainLoop() {
    while (running) {
        lv_timer_handler();
        
        // 处理业务线程回传的事件
        while (auto event = uiEventQueue.tryPop()) {
            handleUIEvent(*event);
        }
        
        lv_tick_inc(5);
        usleep(5000);
    }
}
```

**规则**：
- ✅ UI线程（按钮回调）→ push任务到队列
- ✅ 业务线程 → pop任务处理（网络/播放/歌库）
- ✅ 处理完再 push "事件结束/数据返回"
- ✅ UI根据业务回传更新界面

**一定不要**：
- ❌ UI事件回调里直接做网络/播放阻塞
- ❌ 业务线程直接调 LVGL API

**正确做法**：
- ✔️ 业务线程用回调/状态 → 通知 UI → UI线程执行界面更新

---

### 🟡 播放器（tplayer/ijk等）

> 原则：**播放器自己一套线程，不进UI事件体系**

```cpp
// 播放器控制（通过PlayerService）
void onPlayButtonClick(lv_event_t* e) {
    // UI线程：发送播放命令
    PlayerService::instance().play(songUrl);
}

// PlayerService内部（业务线程）
void PlayerService::play(const std::string& url) {
    // 在播放器线程中执行
    playerThread.enqueue([url]() {
        tplayer_set_data_source(player, url.c_str());
        tplayer_prepare(player);
        tplayer_start(player);
    });
}

// tplayer回调（SDK线程）
void tplayer_callback(int event, void* data) {
    // 回调 → 推消息到UI线程
    PlayerEvent ev;
    ev.type = translateEvent(event);
    uiEventQueue.push(ev);
}

// UI线程（处理播放器事件）
void handlePlayerEvent(const PlayerEvent& ev) {
    switch (ev.type) {
    case PlayerEvent::PLAYING:
        lv_label_set_text(playButton, "暂停");
        break;
    case PlayerEvent::PAUSED:
        lv_label_set_text(playButton, "播放");
        break;
    }
}
```

**规则**：
- ✅ 只通过 **API/FD/回调** 控制播放器
- ✅ 播放状态通过 **回调事件 → 推消息到UI线程**
- ✅ UI线程接到消息 → 更新控件状态 / 变按钮文本
- ❌ 不在播放器回调中直接调用LVGL API

---

## 🧩 线程拓扑结构

```
             ┌──────────────────────────────┐
             │          输入线程             │
触摸硬件 →   │  read(eventX) 解析坐标        │
             │  更新 g_touch_state           │
             └──────────▲───────────────────┘
                        │共享状态
 ┌──────────────────────┼──────────────────────────┐
 │                      │                          │
 │                      │                          │
 ▼                      │                          │
 UI主线程───────────────┘                          │
 lv_timer_handler()                                   │
 * 自动调用read_cb()                                   │
 * 事件派发/点击/控件命中                              │
 * 用户点击回调 → 生产任务 → 放入队列 ◄───────────────┐
                                                         │
                                                         │
                                  ┌───────────────────────┘
                                  │
                                  ▼
                        业务线程/线程池
                        * 歌库搜索
                        * 播放器控制(IC)
                        * 网络请求
                        * 缓存加载/JSON解析
                        * 完成后 → 回传UI事件
```

⚠️ **注意**：

> UI与业务线程之间的唯一边界：📌**队列+回调分发**  
> 不要越界调用UI函数

---

## 🧨 避坑指南（工程级）

| 坑 | 为什么炸 | 规避策略 |
|------|---------|---------|
| **UI回调里搞网络/播放** | 卡主LVGL刷新 → 黑屏卡死 | UI只发"任务指令"，业务线程执行 |
| **read(fd)放到主线程** | 阻塞UI循环 | 必须独立线程 |
| **多线程调用LVGL API** | UI竞争崩溃 | UI唯一线程原则 |
| **图片/字体加载放UI线程** | 卡首屏加载 | 预加载/后台异步+UI完成通知 |
| **队列无容量控制** | 消息堆积 → 内存炸 | 固定容量RingBuffer |
| **线程间共享结构无锁** | 随机崩溃 | 用原子变量或轻锁Mutex |
| **tplayer/ijk回调调UI** | 跨线程野调用 | 回调 → 队列 → UI更新 |

---

## 🔥 最佳黄金准则（可挂墙）

> **"LVGL单线程，输入分离，业务旁路，消息通信。"**

**一句话版**：

```
UI线程做显示
输入线程做感知
业务线程做计算
通信只过队列
不跨线程调LVGL
```

这就是嵌入式 UI 架构中最核心的生存法则。

---

## 🚀 落地优先顺序

### 阶段1：最小可用（MVP）

1. 🟢 **UI主线程 + 输入线程** 拉通触摸 → 已通
   - UI主线程：LVGL渲染循环
   - 输入线程：读取触摸事件，更新共享状态
   - 简单业务逻辑直接在UI回调中处理

### 阶段2：业务分离

2. 🟡 **加消息队列** → UI回调不做耗时逻辑
   - 创建业务线程
   - UI回调只发送任务到队列
   - 业务线程处理网络/播放等耗时操作

### 阶段3：播放器集成

3. 🔵 **接 tplayer/ijk** → 回调状态 → 消息通知 UI
   - 播放器控制通过PlayerService
   - 播放器回调推事件到UI队列
   - UI线程处理播放器事件

### 阶段4：资源优化

4. 🟣 **资源/字体/图片加载** → 后台加载 + UI完成提示
   - 图片/字体预加载
   - 后台线程加载，完成后通知UI
   - UI显示加载进度

---

## 🎯 一句话给团队（直接转发）

> 系统架构采用 3-4 线程体系：UI主线程负责LVGL与界面渲染；输入线程阻塞读取触摸事件更新共享状态；业务线程池负责网络/播放/歌库等耗时任务；播放器线程（tplayer内部）处理媒体播放。各线程间使用无锁队列与事件驱动进行通信，禁止跨线程调用LVGL API，确保UI实时性与系统稳定性。

---

## 📋 实现检查清单

### ✅ 必须实现

- [ ] UI主线程：LVGL渲染循环（`lv_timer_handler()`）
- [ ] 输入线程：读取触摸事件，更新共享状态
- [ ] 共享状态：使用atomic或mutex保护
- [ ] 消息队列：UI → 业务线程
- [ ] 事件队列：业务线程 → UI线程
- [ ] 播放器服务：封装tplayer调用
- [ ] 播放器回调：推事件到UI队列

### ⚠️ 禁止事项

- [ ] ❌ UI回调中直接网络请求
- [ ] ❌ UI回调中直接播放控制
- [ ] ❌ 业务线程直接调用LVGL API
- [ ] ❌ 播放器回调直接调用LVGL API
- [ ] ❌ 输入线程直接调用LVGL API
- [ ] ❌ 跨线程共享LVGL对象

---

## 📚 相关文档

- **并发架构总结构（最终版）**: [并发架构总结构（最终版）.md](./architecture/并发架构总结构（最终版）.md)
- **事件架构规范**: [事件架构规范.md](./architecture/事件架构规范.md)
- **资源管理规范**: [资源管理规范v1.md](./资源管理规范v1.md)
- **团队开发规范**: [团队开发规范v1.md](./团队开发规范v1.md)

---

**最后更新**: 2025-12-30  
**状态**: ✅ 核心文档，线程架构基线（最终版）



# KTVLV 项目架构图（1页版）

> **文档版本**：v1.0  
> **最后更新**：2025-12-30  
> **状态**：✅ 对外讲解文档  
> **用途**：给财务/给老板过会/开发团队内部SOP

---

## 🏗️ 系统架构总览

```
┌──────────────────────────────────────────────────────────────┐
│                          F133 SoC / Tina Linux               │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │                  OS / Kernel / Driver Layer              │ │
│  │                                                          │ │
│  │  • Display Driver  → F133 LCD/HDMI Framebuffer           │ │
│  │  • Touch Input Driver → /dev/input/eventX                │ │
│  │  • Audio Output Driver → ALSA / TPlayer / I2S            │ │
│  │  • FileSystem → ext4 / squashfs / UDisk                  │ │
│  └──────────────────────────────────────────────────────────┘ │
│                         ▲                        ▲            │
│                         │ read(fd) / eventX      │ framebuffer │
└─────────────────────────┼────────────────────────┼─────────────┘
                          │                        │
                          ▼                        ▼
          ┌────────────────────────────────────────────────────────┐
          │                 Application Runtime Layer              │
          │                                                        │
          │  ┌─────────────────┐   ┌──────────────────────────┐    │
          │  │ Input Thread    │   │   Business Thread(s)     │    │
          │  │ (Producer)      │   │   (Producer)             │    │
          │  │──────────────── │   │──────────────────────────│    │
          │  │ • 阻塞read()    │   │ • 搜索/歌库/播放控制     │    │
          │  │ • 解析input事件 │   │ • 网络请求/JSON/解析     │    │
          │  │ • 更新TouchState│   │ • 状态回调→Push事件      │    │
          │  └─────────────────┘   └──────────────────────────┘    │
          │                   ▲                    ▲               │
          │                   │ push               │ push           │
          │                   │                    │                │
          │         ┌──────────────────────────────────────────┐    │
          │         │        Message Queue (std::queue+mutex)  │    │
          │         │        • 事件中立区（线程安全）           │    │
          │         │        • 固定容量 64 / 溢出丢旧消息       │    │
          │         │        • UI唯一消费者                    │    │
          │         └──────────────────────────────────────────┘    │
          │                                      ▲                 │
          │                                      │ pop             │
          └──────────────────────────────┬──────┘                 │
                                         │                        │
                                         ▼                        │
                    ┌──────────────────────────────────────────┐  │
                    │              UI Main Thread               │  │
                    │              (LVGL Single Owner)          │  │
                    │──────────────────────────────────────────│  │
                    │ • lv_init / display_drv_init()           │  │
                    │ • lv_timer_handler() / 5ms tick           │  │
                    │ • 控件命中/事件派发(LV_EVENT_CLICKED)    │  │
                    │ • UI回调→push任务→业务线程执行           │  │
                    │ • 绝不阻塞IO/网络/播放/解码              │  │
                    └──────────────────────────────────────────┘  │
                                         │
                                         │ 控件/事件调用
                                         ▼
                    ┌──────────────────────────────────────────┐
                    │              LVGL Framework              │
                    │──────────────────────────────────────────│
                    │ • Render Pipeline                        │
                    │ • Event Dispatch / Input Device          │
                    │ • Font / Image / Layout / PageManager    │
                    │ • 控件树（Button/Label/List/Grid）       │
                    └──────────────────────────────────────────┘
                                         │
                                         │ Framebuffer
                                         ▼
        ┌────────────────────────────────────────────────────────────────┐
        │                          LCD / HDMI 显示输出                   │
        └────────────────────────────────────────────────────────────────┘
```

---

## 🧵 线程模型（4线程）

| 线程 | 职责 | 交互方式 |
|------|------|---------|
| **UI主线程** | LVGL渲染、控件逻辑、UI更新 | 消费 UiEventQueue |
| **输入线程** | 读取触摸/按键事件 | 生产 → UiEventQueue |
| **业务线程** | HTTP请求、JSON解析 | 生产 → UiEventQueue |
| **播放器线程** | 串行执行播放命令 | 消费 PlayerCmdQueue，生产 → UiEventQueue |

---

## 📩 消息队列（2个）

| 队列 | 流向 | 实现 |
|------|------|------|
| **PlayerCmdQueue** | UI/业务 → 播放器 | std::queue + std::mutex |
| **UiEventQueue** | 输入/业务/播放器 → UI | std::queue + std::mutex |

---

## 🔄 数据流向

### 1. 用户输入流程

```
触摸屏 → evdev → 输入线程 → UiEventQueue → UI主线程 → LVGL更新
```

### 2. 点歌流程

```
UI点击 → PlayerCmdQueue → 播放器线程 → tplayer API → 播放
```

### 3. 播放状态更新流程

```
tplayer回调 → UiEventQueue → UI主线程 → 更新播放按钮/进度条
```

### 4. 搜索流程

```
UI输入 → 业务线程 → HTTP请求 → JSON解析 → UiEventQueue → UI主线程 → 更新列表
```

---

## 📍 架构价值点（用于向老板/财务/技术面解释）

| 优势 | 解释 |
|------|------|
| **UI线程隔离** | UI不卡死、不黑屏，触摸高响应稳定 |
| **事件驱动模型** | 跨线程通信安全、可扩展、快速定位问题 |
| **解耦** | UI与业务线程没有直接耦合，后期重构成本低 |
| **可以快速量产** | 无需引入过度抽象、事件总线、IOC框架 |
| **Tina & F133 Friendly** | 符合嵌入式资源约束和输入模型（/dev/input/eventX） |

---

## 🎯 核心设计原则

### ✅ 已实现

- ✅ **线程职责边界明确**：UI/Input/Biz/Player 各司其职
- ✅ **事件驱动**：代替回调地狱
- ✅ **队列通信**：避免跨线程UI调用
- ✅ **MVP可用**：可量产可扩展

### ❌ 不做的（避免过度设计）

- ❌ 工厂模式泛滥
- ❌ 虚基类、接口抽象层层叠
- ❌ IOC容器、事件总线乱飞
- ❌ 架构师自嗨的架空设计

---

## 🎯 一句"能震住外行"的总结台词（建议粘贴到PPT）

> **本架构基于 Single-Owner UI Thread + Event-Driven 线程通信模型。**  
> **UI 独占 LVGL 的渲染与控件生命周期，所有输入与业务状态通过定长消息队列异步分发，避免跨线程 UI 调用导致的卡顿或异常，确保在弱算力 Tina/F133 环境下依然保持高稳定性和低延迟响应。**

---

## 🛡️ 落地风险与规避手段

| 风险 | 场景 | 规避策略 |
|------|------|---------|
| UI卡顿 | 在UI线程执行网络/播放/解码 | 禁止耗时操作 → push队列给业务线程 |
| 输入丢失 | 事件 >64频率瞬发 | 队列溢出弃旧、实时性优先 |
| 死锁 | 多个queue双向锁等待 | 单向通信、仅UI消费 |
| LVGL崩溃 | 跨线程UI操作 | 单线程UI原则、回调只发事件 |

---

## 🧠 说服财务/老板的说辞

> 这套架构以"能跑、能上量、能维护"为基准，不堆叠过度抽象或设计模式，在 Tina + F133 的资源条件下最大化稳定性与迭代速度。后续扩展播放器/遥控器/蓝牙设备时不需要推翻架构，只需增加 Producer 即可。

---

## 📊 技术栈

| 层级 | 技术 | 说明 |
|------|------|------|
| **硬件** | F133 (ARM Cortex-A7) | 全志芯片 |
| **系统** | Tina Linux | 嵌入式Linux |
| **显示** | Framebuffer | 直接帧缓冲 |
| **输入** | evdev | Linux输入事件 |
| **音频** | TPlayer SDK | 全志官方播放器 |
| **UI框架** | LVGL 8.x | 轻量级GUI |
| **网络** | libcurl | HTTP客户端 |
| **长连接** | libwebsockets | WebSocket客户端 |
| **队列** | std::queue + std::mutex | 标准库，简单可靠 |

---

## 🚀 架构优势

1. **简单可靠**：标准库，无需额外依赖
2. **性能足够**：MVP阶段事件频率不高，完全够用
3. **易于维护**：团队熟悉，问题少
4. **可扩展**：未来可升级到 RingBuffer / Lock-free
5. **不过度设计**：保持2/5抽象层级，避免过度包装

---

## 📋 开发规范

### ✅ 必须遵守

- ✅ UI线程只消费队列，不直接调用tplayer
- ✅ 其他线程只生产队列，不直接调用LVGL
- ✅ 队列容量固定64，溢出丢弃最旧消息
- ✅ 消息只传ID/指针，不传大对象

### ❌ 禁止事项

- ❌ 跨线程直接调用LVGL API
- ❌ UI线程等待业务线程同步返回
- ❌ 队列无限增长
- ❌ 消息中传递大结构或图片

---

## 💡 一句话总结（技术版）

> **KTVLV采用4线程+2队列架构，UI主线程负责LVGL渲染，输入/业务/播放器线程通过std::queue消息队列向UI发送状态。禁止跨线程调用LVGL，所有UI更新在UI线程执行。当前架构简单可靠，性能足够，不过度设计，可支撑MVP到量产。**

## 💡 一句话总结（对外版）

> **本架构基于 Single-Owner UI Thread + Event-Driven 线程通信模型，UI 独占 LVGL 的渲染与控件生命周期，所有输入与业务状态通过定长消息队列异步分发，避免跨线程 UI 调用导致的卡顿或异常，确保在弱算力 Tina/F133 环境下依然保持高稳定性和低延迟响应。**

---

## 📚 相关文档

- **架构成熟度评估**: [架构成熟度评估与包装原则.md](./架构成熟度评估与包装原则.md)
- **消息队列实现**: [消息队列实现与最佳实践.md](./消息队列实现与最佳实践.md)
- **线程架构基线**: [线程架构基线（最终版）.md](./线程架构基线（最终版）.md)
- **项目架构总览**: [项目架构设计总览.md](./architecture/项目架构设计总览.md)

---

**最后更新**: 2025-12-30  
**状态**: ✅ 对外讲解文档，1页版架构图


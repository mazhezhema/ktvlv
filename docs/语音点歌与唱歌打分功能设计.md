# 语音点歌与唱歌打分功能设计

> **最后更新**: 2025-12-30  
> **状态**: 未来功能规划

## 🎯 功能概述

### 1. 语音点歌功能
- **用途**: 用户通过语音输入搜索歌曲
- **流程**: 录音 → 语音识别 → 搜索歌曲 → 显示结果
- **技术栈**: ALSA 录音 + 语音识别服务（云端或本地）

### 2. 唱歌打分功能
- **用途**: 录制用户唱歌，与伴奏对比，给出评分
- **流程**: 录音（用户唱歌）→ 音频分析 → 与伴奏对比 → 计算分数
- **技术栈**: ALSA 录音 + 音频分析算法（音高、节拍、音准）

---

## 🔧 技术实现方案

### 方案1: 云端服务（推荐）⭐

**优势**:
- ✅ 语音识别准确率高（使用大模型）
- ✅ 不需要本地部署复杂算法
- ✅ 可以持续更新优化

**架构**:
```
应用层
├── 录音（ALSA）→ 音频数据
├── 上传到服务器（HTTP POST）
└── 接收识别结果（JSON）
```

**语音点歌流程**:
1. 用户按下语音按钮
2. 开始录音（ALSA API）
3. 录音3-5秒后停止
4. 将音频数据上传到服务器（base64 编码或文件上传）
5. 服务器进行语音识别（ASR）
6. 返回识别文本
7. 使用识别文本搜索歌曲

**唱歌打分流程**:
1. 用户开始唱歌
2. 开始录音（ALSA API）
3. 同时播放伴奏（TPlayer）
4. 录音过程中实时上传音频片段（可选）
5. 歌曲结束后停止录音
6. 上传完整录音到服务器
7. 服务器分析音频（音高、节拍、音准）
8. 与伴奏对比，计算分数
9. 返回评分结果

### 方案2: 本地处理（可选）

**优势**:
- ✅ 不需要网络
- ✅ 响应速度快
- ✅ 隐私保护

**劣势**:
- ❌ 需要集成本地语音识别库（较重）
- ❌ 需要实现音频分析算法（复杂）
- ❌ 准确率可能不如云端

**可选库**:
- **语音识别**: Vosk（离线语音识别，C++）
- **音频分析**: 自实现或使用音频处理库

---

## 📦 需要的库和依赖

### 必需库（已包含）

| 库名 | 用途 | 状态 |
|------|------|------|
| **ALSA** | 录音功能 | ⚠️ 需要启用（编译时定义 `KTV_USE_ALSA_RECORD`） |
| **libcurl** | 上传音频到服务器 | ✅ 已包含 |
| **cJSON** | 解析服务器响应 | ✅ 已包含 |

### 可选库（根据方案选择）

#### 方案1: 云端服务（推荐）
- ✅ **不需要额外库** - 使用现有的 libcurl + cJSON
- ✅ 服务器端实现语音识别和音频分析

#### 方案2: 本地处理
- ⚠️ **Vosk** - 离线语音识别（C++，较大，~100MB）
- ⚠️ **音频分析库** - 音高检测、节拍分析等（可选）

---

## 🔌 接口设计

### 音频驱动接口（已扩展）

```c
// drivers/audio_driver.h

// 录音回调函数
typedef bool (*audio_record_callback_t)(const void* data, size_t size, void* user_data);

typedef struct {
    int (*init)(void);
    bool (*play_sound)(uint32_t sound_id);
    
    // 录音接口（新增）
    bool (*start_record)(int sample_rate, int channels, int format,
                        audio_record_callback_t callback, void* user_data);
    bool (*stop_record)(void);
    bool (*is_recording)(void);
    
    void (*deinit)(void);
} audio_iface_t;
```

### 使用示例

**语音点歌**:
```c
// 录音数据缓冲区
static char audio_buffer[1024 * 1024];  // 1MB 缓冲区
static size_t audio_buffer_size = 0;

// 录音回调函数
static bool voice_record_callback(const void* data, size_t size, void* user_data) {
    // 将录音数据保存到缓冲区
    if (audio_buffer_size + size < sizeof(audio_buffer)) {
        memcpy(audio_buffer + audio_buffer_size, data, size);
        audio_buffer_size += size;
        return true;  // 继续录音
    }
    return false;  // 缓冲区满，停止录音
}

// 开始语音点歌
void start_voice_search() {
    // 开始录音（16kHz, 单声道, 16位）
    if (AUDIO.start_record(16000, 1, 0, voice_record_callback, NULL)) {
        // 录音3秒后停止
        sleep(3);
        AUDIO.stop_record();
        
        // 上传音频到服务器
        upload_audio_for_recognition(audio_buffer, audio_buffer_size);
    }
}
```

**唱歌打分**:
```c
// 录音数据回调（实时上传或保存）
static bool singing_record_callback(const void* data, size_t size, void* user_data) {
    // 方案1: 实时上传音频片段（可选）
    // upload_audio_chunk(data, size);
    
    // 方案2: 保存到缓冲区
    // ... 保存逻辑 ...
    
    return true;  // 继续录音
}

// 开始唱歌打分
void start_singing_score() {
    // 开始播放伴奏（TPlayer）
    TPlayerStart(player);
    
    // 开始录音（44.1kHz, 立体声, 16位）
    if (AUDIO.start_record(44100, 2, 0, singing_record_callback, NULL)) {
        // 录音直到歌曲结束
        // ... 等待歌曲播放完成 ...
        AUDIO.stop_record();
        
        // 上传完整录音到服务器进行评分
        upload_audio_for_scoring(audio_buffer, audio_buffer_size);
    }
}
```

---

## 🌐 服务器 API 设计

### 语音识别 API

```http
POST /api/voice/recognize
Content-Type: multipart/form-data

{
    "audio": <音频文件或base64编码>,
    "format": "wav|pcm",
    "sample_rate": 16000,
    "channels": 1
}

Response:
{
    "success": true,
    "text": "我要点一首周杰伦的歌",
    "confidence": 0.95
}
```

### 唱歌打分 API

```http
POST /api/singing/score
Content-Type: multipart/form-data

{
    "audio": <用户唱歌录音>,
    "accompaniment_url": "http://.../song.m3u8",
    "format": "wav",
    "sample_rate": 44100,
    "channels": 2
}

Response:
{
    "success": true,
    "score": 85,
    "details": {
        "pitch_accuracy": 0.88,
        "rhythm_accuracy": 0.92,
        "tone_accuracy": 0.85
    }
}
```

---

## 🔧 编译配置

### 启用录音功能

在 `CMakeLists.txt` 或编译选项中：

```cmake
# 启用 ALSA 录音功能
option(KTV_USE_ALSA_RECORD "Enable ALSA recording for voice search and singing score" OFF)

if(KTV_USE_ALSA_RECORD)
    add_definitions(-DKTV_USE_ALSA_RECORD)
    find_library(ALSA_LIB asound)
    target_link_libraries(ktvlv PRIVATE ${ALSA_LIB})
endif()
```

### F133 平台配置

```cmake
if(KTV_PLATFORM_F133_LINUX)
    # F133 平台启用录音功能
    option(KTV_USE_ALSA_RECORD ON)
    
    # 链接 ALSA 库
    find_library(ALSA_LIB asound)
    if(ALSA_LIB)
        target_link_libraries(ktvlv PRIVATE ${ALSA_LIB})
    endif()
endif()
```

---

## 📊 功能优先级

### MVP 版本（第一期）
- ❌ **不包含**语音点歌和唱歌打分
- ✅ 保持当前实现（stub）
- ✅ 接口已就绪，但不启用录音功能
- ✅ 不需要 ALSA 库，保持 stub 实现

### 未来版本（v2.0+）

**优先级1: 语音点歌** ⭐⭐⭐
- 用户需求高
- 实现相对简单（录音 + 云端识别）
- 可以快速上线

**优先级2: 唱歌打分** ⭐⭐
- 需要复杂的音频分析算法
- 可能需要更多开发时间
- 可以作为增值功能

---

## 🎯 实现步骤

### 阶段1: 录音功能基础（当前）
- ✅ 扩展 `audio_driver.h` 接口
- ✅ 实现 ALSA 录音 API（stub 或完整实现）
- ✅ 测试录音功能

### 阶段2: 语音点歌（v2.0）
1. 实现录音数据收集
2. 实现音频上传（HTTP POST）
3. 集成语音识别服务（云端）
4. 实现搜索结果展示
5. 测试和优化

### 阶段3: 唱歌打分（v2.1+）
1. 实现长时间录音（整首歌）
2. 实现录音与播放同步
3. 集成音频分析服务（云端）
4. 实现评分展示
5. 测试和优化

---

## 📝 注意事项

### 录音参数选择

**语音点歌**:
- 采样率: 16kHz（足够语音识别）
- 声道: 单声道
- 格式: S16_LE（16位）
- 时长: 3-5秒

**唱歌打分**:
- 采样率: 44.1kHz（CD质量）
- 声道: 立体声
- 格式: S16_LE（16位）
- 时长: 整首歌（3-5分钟）

### 性能考虑

1. **录音线程**: 使用独立线程，避免阻塞主线程
2. **缓冲区管理**: 使用固定大小缓冲区，避免内存泄漏
3. **网络上传**: 使用后台线程上传，避免阻塞 UI
4. **资源释放**: 录音结束后及时释放 ALSA 资源

### 用户体验

1. **录音提示**: 显示录音状态（录音中、处理中）
2. **错误处理**: 网络错误、识别失败等情况的友好提示
3. **取消功能**: 用户可以随时取消录音
4. **隐私保护**: 明确告知用户录音用途

---

## 📚 相关文档

- **Linux 录音实现**: [Linux录音实现说明.md](./Linux录音实现说明.md)
- **ALSA 说明**: [ALSA说明.md](./ALSA说明.md)
- **F133 平台库清单**: [F133平台库清单.md](./F133平台库清单.md)
- **HTTP 客户端设计**: [HTTP_REST_API客户端设计.md](./design/HTTP_REST_API客户端设计.md)

---

## 🎯 总结

### 当前状态
- ✅ 接口已扩展，支持录音功能
- ✅ 实现为可选功能（编译时控制）
- ✅ 保持向后兼容（stub 实现）

### 未来实现
- ⚠️ 需要启用 `KTV_USE_ALSA_RECORD` 编译选项
- ⚠️ 需要链接 ALSA 库（`libasound2`）
- ⚠️ 需要实现服务器端 API（语音识别、音频分析）

### 推荐方案
- ✅ **语音点歌**: 使用云端服务（简单、准确）
- ✅ **唱歌打分**: 使用云端服务（复杂算法在服务器端）
- ✅ **本地处理**: 仅作为可选方案（如果需要离线功能）

---

**最后更新**: 2025-12-30


# 消息队列完整指南（F133 / Tina Linux）

> **文档版本**：v2.0（合并版）  
> **最后更新**：2025-12-30  
> **状态**：✅ 核心文档（合并版）  
> **适用平台**：F133 / Tina Linux（嵌入式 Linux）  
> **相关文档**：详见 [线程架构基线（最终版）.md](./线程架构基线（最终版）.md)

---

## 🎯 技术决策（可直接定稿）

> **消息队列选型说明**
>
> * 项目采用 `std::queue + std::mutex + condition_variable`
> * 满足当前及可预见的性能与并发需求
> * `moodycamel::ConcurrentQueue` 属于高并发/高吞吐场景优化方案
> * 在嵌入式 Linux KTV 场景中无明显收益
> * **后续不作为默认或推荐方案**

---

## 📋 目录

1. [技术决策说明](#一-技术决策说明)
2. [实现方式](#二-实现方式)
3. [最佳实践](#三-最佳实践)
4. [避坑指南](#四-避坑指南)

---

## 一、技术决策说明

### 1.1 为什么在嵌入式 Linux 里不使用 moodycamel？

#### 嵌入式 Linux 的真实瓶颈，不在队列

在 F133 KTV 系统中，真正的瓶颈排序通常是：

1. **网络 IO**（DNS / TLS / HTTP）
2. **存储 IO**（Flash / eMMC）
3. **解码 / 播放**
4. **UI 绘制**
5. **最后才是：线程同步**

👉 **队列锁竞争几乎排不到前 3**

`ConcurrentQueue` 优化的是**第 5 层**，但我们的痛点在 **1～3 层**。

#### 嵌入式系统的并发模型本身就"克制"

在服务器或高性能系统里常见的是：

* 多 producer
* 多 consumer
* 高频事件
* pipeline 深

而我们是：

* 少量 producer（UI / Network）
* 单 consumer（Service / Worker）
* 事件低频（人触发）
* 强顺序语义（点歌 → 播放）

👉 **这是"逻辑驱动系统"，不是"吞吐驱动系统"**

#### 无锁结构在嵌入式上的"隐性成本"更高

无锁队列的代价不是 0：

* cache line 抖动
* 内存屏障
* ABA 问题理解成本
* 偶现 bug 排查成本

在服务器上：

* 有 perf
* 有 core dump
* 有完整工具链

在 F133 这类设备上：

* 工具弱
* 复现难
* 一次偶现 = 一次事故

👉 **嵌入式项目天然不欢迎"难以证明正确性"的组件**

### 1.2 std::queue + mutex 的现实优势

| 维度 | 评价 |
|------|------|
| **行为** | 完全确定 |
| **顺序** | 100% 可预测 |
| **Debug** | 一眼能看懂 |
| **死锁排查** | 容易 |
| **线程退出** | 容易 |
| **维护** | 极低成本 |

👉 **这在嵌入式里是"长期价值"**

### 1.3 什么时候嵌入式 Linux 真的可能需要 moodycamel？

可能需要的前提（必须同时满足多条）：

1. **多路高频数据源**
   * 摄像头帧
   * 传感器流
   * 高频 ISR → 用户态转发

2. **明确的性能瓶颈证据**
   * profile 证明锁竞争 >10%

3. **队列是系统热路径**
   * 不可阻塞

4. **团队能长期维护**
   * 熟悉 lock-free

👉 **这些更像"多媒体处理/工业采集"，而不是 KTV**

### 1.4 KTV 项目的典型队列用途

我们的典型队列用途是：

* 事件通知
* 状态切换
* 任务调度
* 日志上传触发

这些事件的共同特征：

* 低频
* 强顺序
* 强语义
* 可等待

👉 **这和 `ConcurrentQueue` 的设计目标完全相反**

---

## 二、实现方式

### 2.1 消息队列的定位（总原则）

> **消息队列是线程之间的中立区**  
> **UI线程只消费（pop），其他线程只生产（push）**  
> **禁止跨线程直接调 LVGL**

```
    [Input Thread] ----push--┐
    [Biz Thread]   ----push--┤→ [MessageQueue] →(pop)→ UI线程 → 更新UI
    [Player Thread] ----push-┘
```

### 2.2 MVP阶段：std::queue + std::mutex（推荐）

> **当前阶段的最优解**：简单可靠，性能足够，开发成本低。

```cpp
// msg_queue_std.h
#pragma once
#include <queue>
#include <mutex>

enum class EventType {
    TOUCH,
    SEARCH_DONE,
    PLAY_STATE_CHANGED,
    // ... 其他事件
};

struct EventMsg {
    EventType type;
    void* payload = nullptr;
    int value1 = 0;
    int value2 = 0;
};

class MsgQueueStd {
public:
    static constexpr int MAX_SIZE = 64;  // 定长限制
    
    bool push(const EventMsg& msg);
    bool pop(EventMsg& out);
    bool empty() const;
    int size() const;
    
private:
    std::queue<EventMsg> queue_;
    mutable std::mutex mtx_;
};

// msg_queue_std.cpp
bool MsgQueueStd::push(const EventMsg& msg) {
    std::lock_guard<std::mutex> lock(mtx_);
    
    // 队列满了：丢弃最旧的，保持实时性
    if (queue_.size() >= MAX_SIZE) {
        queue_.pop();
    }
    
    queue_.push(msg);
    return true;
}

bool MsgQueueStd::pop(EventMsg& out) {
    std::lock_guard<std::mutex> lock(mtx_);
    if (queue_.empty()) {
        return false;
    }
    
    out = queue_.front();
    queue_.pop();
    return true;
}

bool MsgQueueStd::empty() const {
    std::lock_guard<std::mutex> lock(mtx_);
    return queue_.empty();
}

int MsgQueueStd::size() const {
    std::lock_guard<std::mutex> lock(mtx_);
    return queue_.size();
}
```

**特点**：
- ✅ 实现简单，标准库，无需额外依赖
- ✅ 线程安全（mutex保护）
- ✅ 定长队列，溢出时丢弃最旧消息
- ✅ 非阻塞，快速返回
- ✅ MVP阶段性能完全够用

### 2.3 UI主循环的使用

```c
int main() {
    // 初始化
    msgq_init(&g_msgq);
    lv_init();
    // ... 其他初始化
    
    // UI主循环
    while(1) {
        lv_timer_handler(); // LVGL 主循环
        
        // 处理消息队列（UI线程唯一安全地调用LVGL）
        EventMsg e;
        while(msgq_pop(&g_msgq, &e)) {
            switch(e.type) {
                case EVT_SEARCH_DONE:
                    ui_update_list(e.payload);
                    break;
                case EVT_PLAY_STATE:
                    ui_update_player(e.payload);
                    break;
                case EVT_PLAYER_FINISHED:
                    ui_play_next();
                    break;
                case EVT_NETWORK_ERR:
                    ui_show_error("网络错误");
                    break;
                // ... 其他事件处理
            }
        }
        
        lv_tick_inc(5);
        usleep(5000); // 5ms tick
    }
}
```

💡 **UI在主线程唯一安全地调用LVGL**

---

## 三、最佳实践

### 3.1 最佳实践（写入架构文档的）

| 规则 | 解释 |
|------|------|
| 👉 **UI线程 ≠ 业务线程** | UI只负责LVGL，不能做耗时任务 |
| 👉 **事件驱动，不主动等待** | 不能在UI等网络 / 播放器响应 |
| 👉 **定长队列，丢弃旧消息优先级 > 堆积** | 点歌设备实时性必须稳 |
| 👉 **消息内放 ID/指针，不放大数据** | 避免碎片 & 内存压力 |
| 👉 **业务线程不能调LVGL API** | 跨线程操作 LVGL = 必崩 |
| 👉 **UI线程禁止 read(fd)/阻塞IO** | 触摸读取必须独立线程 |
| 👉 **所有状态变化由事件驱动更新** | UI不定时去轮询播放器 |

### 3.2 点歌机专用事件建议（枚举示例）

```c
typedef enum {
    // 输入事件
    EVT_TOUCH,
    EVT_KEY_PRESSED,
    
    // 搜索事件
    EVT_SEARCH_STARTED,
    EVT_SEARCH_DONE,
    EVT_SEARCH_ERROR,
    
    // 播放事件
    EVT_PLAY_REQUEST,
    EVT_PLAY_STATE_CHANGED,  // playing/paused/stopped
    EVT_PLAYER_BUFFERING,
    EVT_PLAYER_FINISHED,
    EVT_PLAYER_ERROR,
    
    // 列表事件
    EVT_SINGER_SELECTED,
    EVT_CATEGORY_CHANGED,
    EVT_SONG_SELECTED,
    
    // 控制事件
    EVT_VOLUME_CHANGED,
    EVT_TRACK_SWITCHED,  // 原唱/伴奏切换
    
    // 网络事件
    EVT_NETWORK_ERR,
    EVT_NETWORK_CONNECTED,
    EVT_NETWORK_DISCONNECTED,
    
    // 系统事件
    EVT_ERROR,
    EVT_WARNING,
} EventType;
```

💡 **避免用字符串/魔法值**

❌ **错误**：
```c
if(type == "play_state")  // 字符串比较，易错
```

✅ **正确**：
```c
if(type == EVT_PLAY_STATE_CHANGED)  // 枚举，类型安全
```

---

## 四、避坑指南

### 4.1 避坑指南（踩过的都哭过）

| 错误行为 | 后果 | 正确处理 |
|---------|------|---------|
| ❌ UI线程中做网络 / JSON解析 | 界面卡死/黑屏 | 用事件 → 推给业务线程 |
| ❌ 输入线程直接调用 `lv_obj_set_x()` | 随机崩溃 | push事件 → UI线程处理 |
| ❌ 队列无限增长 | 内存爆炸/延迟 | 必须定长，溢出丢弃旧 |
| ❌ 队列传递大结构 or 图片 | 内存碎片，Tina爆栈 | 只传ID/指针/状态 |
| ❌ UI等待播放器同步返回 | 死锁/卡顿 | 回调 → push事件 → UI响应 |
| ❌ 多个线程一起调LVGL | 血崩 | 只UI线程触及LVGL |

📌 **一句话记住**：
**UI 不阻塞，不等待，不重计算**

### 4.2 使用示例

#### 示例1：输入线程推送触摸事件

```c
// 输入线程
void inputThread() {
    while (running) {
        struct input_event ev;
        read(input_fd, &ev, sizeof(ev));
        
        if (ev.type == EV_KEY && ev.code == BTN_TOUCH && ev.value == 1) {
            // 触摸按下，推送事件
            EventMsg msg;
            msg.type = EVT_TOUCH;
            msg.value1 = touch_x;
            msg.value2 = touch_y;
            msg.payload = NULL;
            msgq_push(&g_msgq, msg);
        }
    }
}
```

#### 示例2：业务线程推送搜索结果

```c
// 业务线程
void businessThread() {
    while (running) {
        Task task = taskQueue.pop();
        
        if (task.type == TASK_SEARCH) {
            // 网络请求
            auto result = httpGet("/api/search?q=" + task.keyword);
            auto songs = parseSongs(result);
            
            // 推送搜索结果事件
            EventMsg msg;
            msg.type = EVT_SEARCH_DONE;
            msg.payload = songs;  // 指针，不复制数据
            msgq_push(&g_msgq, msg);
        }
    }
}
```

#### 示例3：播放器回调推送播放状态

```c
// tplayer回调（SDK线程）
void tplayer_callback(int event, void* data) {
    EventMsg msg;
    msg.type = EVT_PLAY_STATE_CHANGED;
    msg.value1 = event;  // 播放状态码
    msg.payload = data;
    msgq_push(&g_msgq, msg);
}
```

#### 示例4：UI线程处理事件

```c
// UI线程（主循环）
void uiMainLoop() {
    while (running) {
        lv_timer_handler();
        
        // 处理所有待处理事件
        EventMsg e;
        while (msgq_pop(&g_msgq, &e)) {
            switch (e.type) {
            case EVT_SEARCH_DONE:
                {
                    auto songs = (std::vector<Song>*)e.payload;
                    updateSongList(*songs);
                    delete songs;  // 释放内存
                }
                break;
                
            case EVT_PLAY_STATE_CHANGED:
                {
                    int state = e.value1;
                    if (state == PLAYING) {
                        lv_label_set_text(playButton, "暂停");
                    } else if (state == PAUSED) {
                        lv_label_set_text(playButton, "播放");
                    }
                }
                break;
                
            case EVT_PLAYER_FINISHED:
                playNextSong();
                break;
                
            // ... 其他事件处理
            }
        }
        
        lv_tick_inc(5);
        usleep(5000);
    }
}
```

---

## 🎯 总结

### 一句话总结（可以发给团队）

> **线程架构基线：**  
> UI主线程负责LVGL与渲染；  
> 输入/业务/播放器线程通过**定长消息队列（std::queue + std::mutex）**向UI发送状态；  
> 禁止跨线程调用LVGL，UI回调不做耗时处理；  
> 系统以**事件驱动**替代"UI等待业务"，保证实时性与稳定性。  
> **当前阶段符合性能与开发效率平衡，后续量产可升级为 RingBuffer。**

### 实现方案对比

| 阶段 | 方案 | 理由 |
|------|------|------|
| **MVP** | std::queue + mutex | 最少心智负担，先跑通 |
| **预量产** | RingBuffer（锁/轻锁） | 更稳、更省内存 |
| **大规模/多输入** | Lock-free | 等真正有痛点再上 |

👉 **换句话说**：现在别想太多，**std::queue 就是最优解**。

### 实现检查清单

#### ✅ 必须实现（MVP阶段）

- [ ] 定长队列（std::queue，容量64）
- [ ] 线程安全的push/pop（mutex保护）
- [ ] 队列满时丢弃最旧消息（保持实时性）
- [ ] 消息只传ID/指针，不传大对象
- [ ] UI线程只pop，其他线程只push
- [ ] 所有事件类型使用枚举，不用字符串

#### ⚠️ 禁止事项

- [ ] ❌ 队列无限增长
- [ ] ❌ 消息中传递大结构或图片
- [ ] ❌ 业务线程直接调用LVGL API
- [ ] ❌ UI线程等待业务线程同步返回
- [ ] ❌ 多个线程同时操作队列（必须mutex保护）

---

## 📚 相关文档

- **线程架构基线**: [线程架构基线（最终版）.md](./线程架构基线（最终版）.md)
- **并发架构总结构**: [并发架构总结构（最终版）.md](./architecture/并发架构总结构（最终版）.md)
- **事件架构规范**: [事件架构规范.md](./architecture/事件架构规范.md)
- **资源管理规范**: [资源管理规范v1.md](./资源管理规范v1.md)
- **迁移指南**: [std_queue到RingBuffer迁移指南.md](./std_queue到RingBuffer迁移指南.md) ⭐ **预量产阶段参考**

---

**最后更新**: 2025-12-30  
**状态**: ✅ 核心文档（合并版，包含技术决策和实现细节）



# 工程规范与避坑指南（定版）

> 适用架构：Tina + LVGL + 单主线程 + 下载线程  
> 定位：项目级“硬规范”，照做即可避免大事故；非教程、非炫技  
> 状态：✅ 定版（可直接复制到 README / 架构白皮书 / 团队规范）

---

## 一、总体设计规范（总纲）

### 1️⃣ 架构原则（写在最前面）

- **单主线程模型**：UI / Controller / 普通 Service 全部在主线程
- **有限多线程**：
  - 只允许 1 个 Download Thread
  - 播放器线程由 tplayer 内部管理
- **状态驱动 UI**：UI 只根据数据和状态刷新
- **减法优先**：没有明确收益的抽象一律不引入

---

## 二、UI 层（LVGL）规范 & 避坑

### ✅ 允许做的

- 创建页面、控件、布局
- 在 onClick 中：改按钮状态、显示 loading、调用 Controller 的同步接口，且**立即 return**

```c
static void on_btn_click(lv_event_t* e) {
    ui_show_loading();
    controller_on_category_click();
}
```

### ❌ 严禁做的（高危）

- 在 onClick 中进行：网络请求 / 数据库访问 / JSON 解析 / sleep / while / 等待下载完成

```c
// ❌ 绝对禁止（会卡死UI）
static void on_btn_click(lv_event_t* e) {
    curl_easy_perform();
}
```

---

## 三、Controller 层规范 & 避坑

### 职责定义

> **Controller = 流程调度中心**

- 接收 UI 行为 → 决定调用哪个 Service → 更新 UiState/UiModel → 触发 UI 刷新

### ✅ 推荐模式

```c
void controller_on_category_click(void) {
    ui_model_set_loading(true);
    service_load_category();
    ui_model_set_loading(false);
    ui_refresh();
}
```

### ❌ 严禁

- 直接操作 LVGL 控件 / 直接调用 tplayer / 直接操作 Download Thread / 写复杂业务逻辑

---

## 四、Service 层规范 & 避坑

### 定位

> **Service = 业务 + IO 封装**

### ✅ 可以做的

- 同步调用 libcurl（普通请求）、同步访问 SQLite、JSON 解析、更新 ViewModelData/UiModel

```c
int service_load_category(void) {
    network_get_json(url);
    parse_category_json();
    category_ui_model_update();
    return 0;
}
```

### ❌ 严禁

- 操作 UI / 自己创建线程 / 保存 UI 指针 / 持有 tplayer 回调函数

---

## 五、网络（libcurl）使用规范

### 使用方式（定死）

- singleton NetworkClient + 同步 `curl_easy_perform()`，不做 async/multi

```c
NetworkClient* net = network_client_get();
network_client_get_json(net, url);
```

### 避坑

- 每次请求设置 timeout、检查返回码；解析完 JSON 立即释放；不在 UI 回调中使用 libcurl

---

## 六、SQLite 使用规范

### 推荐模式

- 单数据库连接、主线程同步访问、顺序执行

```c
sqlite_exec("SELECT * FROM history");
```

### ❌ 禁止事项

- 多线程同时访问 / 一个模块一个连接 / 引入 ORM 框架

---

## 七、后台下载（m3u8）规范（非常重要）

### 线程模型

- 只允许 **1 个 Download Thread**，所有下载任务**串行执行**

```text
Main Thread → Download Thread → Event → Main Thread
```

### 通信规则

- 下载线程只能发 Event；不能操作 UI/UiModel

```c
download_event_post(EVT_DOWNLOAD_PROGRESS);
```

---

## 八、tplayer 使用规范（高风险区）

### 定位

> **tplayer = 系统级黑盒播放器**

### 必须遵守

- 仅由 PlayerAdapter 调用；所有回调 → Event → Main Thread；UI 永远不直接碰 tplayer

```c
void on_tplayer_complete(void) {
    app_event_post(EVT_PLAYER_COMPLETE);
}
```

### ❌ 高危行为

- 在回调中直接更新 UI / 跨线程调用 UI / 在 Service 中直接 new tplayer

---

## 九、Event 使用规范（收敛版）

### Event 只用于两类场景

1. 跨线程通信（Download Thread → Main、tplayer → Main）  
2. 系统级异步回调

### 明确禁止

- UI → Controller 走 Event；同线程刷新 UI 用 Event

---

## 十、日志规范（syslog）

### 建议级别

- INFO：正常流程；WARN：网络慢/可恢复异常；ERROR：请求失败/播放失败

### 禁止

- 在高频回调里狂打 log；log 中打印大 JSON

---

## 十一、线程铁律（必须写进规范）

> 整个项目只允许：1 个 Main Thread、1 个 Download Thread（自管）、播放器线程由 tplayer 内部管理  
> 任何新增线程必须经过架构评审。

---

## 十二、输入法规范（高频本地交互）

### 🔒 输入法 4 大铁律

1. **任何一次按键都不能触发网络**
2. **任何一次按键都不能阻塞**
3. **主路径只走本地数据**
4. **网络只能"延后、合并、补全"**

### ✅ 正确做法

- 输入法主链路：本地匹配（内存/SQLite）→ UI 即时刷新
- 网络补充：延迟触发（debounce 300ms）→ 后台线程 → 更新缓存
- 输入法不复用普通 Controller/Service（独立子系统）

### ❌ 严禁

- 每次 keypress 都查网络
- keypress 走 Event Queue
- keypress 触发 loading
- 输入法复用普通 Controller
- 网络结果强行刷新 UI

> **详细说明**：详见 [输入法架构设计（定版）.md](../design/输入法架构设计（定版）.md)

---

## 十三、10 条"保命级"避坑总结（可以贴墙）

1. onClick 一定要立即 return  
2. UI 不做 IO  
3. Controller 不碰控件  
4. Service 不碰 UI  
5. 普通网络请求可同步  
6. SQLite 只主线程同步  
7. m3u8 必须后台线程  
8. tplayer 回调必须转 Event  
9. 跨线程只用 Event  
10. **输入法主链路禁止网络**（新增）
11. 不为未来提前造轮子

---

## 十四、一句话定调（非常重要）

> 这套规范不是为了"写得优雅"，而是为了"半年后还能活着维护"。  
> 非常适合两人团队 + 嵌入式长期项目。

---

## 📚 相关文档

- [输入法架构设计（定版）.md](../design/输入法架构设计（定版）.md) ⭐⭐⭐ **必读** - 输入法架构详细设计

---

## 引用与落地

- 建议将本规范链接加入：`docs/文档索引.md`、`README.md`、架构白皮书首页



# 应用层命名规范（架构约束版）

> **文档版本**：v1.0  
> **最后更新**：2025-12-30  
> **状态**：✅ 核心文档（架构约束）  
> **适用平台**：F133 / Tina Linux  
> **目标**：通过命名规范实现架构约束，无需显式 Event 模型，看函数名就知道调用路径

---

## 🎯 核心原则（一句话）

> **看函数名，就知道它是谁触发的、从哪来、往哪去。命名即架构，无需显式 Event 模型。**

---

## 📋 目录

1. [命名总原则](#一-命名总原则)
2. [Presenter 命名规范](#二-presenter-命名规范核心)
3. [View 命名规范](#三-view-命名规范极简但要一致)
4. [StateMachine 命名规范](#四-statemachine-命名规范只管状态)
5. [Service 命名规范](#五-service-命名规范避免侵入应用层)
6. [完整调用链示例](#六-完整调用链示例一眼就懂)
7. [命名规范解决的问题](#七-这套命名解决了什么问题)
8. [铁律与禁止事项](#八-铁律与禁止事项)

---

## 一、命名总原则

### 核心规则

> **应用层只允许三类入口函数：**
>
> * `onUiXxx` —— UI 触发
> * `onSvcXxx` —— Service 回调
> * `onSysXxx` —— 系统 / 环境变化

**除此之外，不允许任何"外部入口"。**

### 为什么这样设计？

1. **阅读路径清晰**：看函数名就知道调用来源
2. **架构约束**：无需显式 Event 模型，命名本身就是约束
3. **MVP 友好**：零心智负担，两个工程师写出来是同一种风格
4. **可追溯性**：顺着名字就能追代码，不需要额外文档

---

## 二、Presenter 命名规范（核心）

### 1️⃣ UI 入口（来自 View）

**规则：**

```
onUi + 动作 + [对象]
```

#### ✅ 推荐示例

```cpp
// 播放控制
void onUiPlayClicked();
void onUiPauseClicked();
void onUiStopClicked();
void onUiNextClicked();
void onUiPrevClicked();

// 歌曲选择
void onUiSongSelected(int songId);
void onUiSongDoubleClicked(int songId);

// 搜索
void onUiSearchSubmitted(const std::string& keyword);
void onUiSearchTextChanged(const std::string& text);

// 导航
void onUiBackPressed();
void onUiHomePressed();
void onUiHistoryPressed();

// 设置
void onUiVolumeChanged(int volume);
void onUiAudioTrackSwitched(int trackIndex);

// VIP/会员
void onUiVipActivateClicked();
void onUiQrCodeScanned(const std::string& code);
```

#### ❌ 禁止写法（必须写进规范）

```cpp
// ❌ 错误：看不到"这是 UI 入口"
void play();
void handlePlay();
void clickPlay();
void doPlay();
void startPlay();

// ❌ 错误：命名不清晰
void playSong(int id);  // 应该是 onUiSongSelected
void search(const std::string& keyword);  // 应该是 onUiSearchSubmitted
```

**📌 原因：**
- 你看不到"这是 UI 入口"，阅读路径断裂
- 无法区分 UI 触发和 Service 回调
- 无法追溯调用来源

---

### 2️⃣ Service 回调入口（来自 Service 层）

**规则：**

```
onSvc + 动作结果
```

#### ✅ 推荐示例

```cpp
// 播放器回调
void onSvcPlayStarted();
void onSvcPlayFinished();
void onSvcPlayError(int errCode);
void onSvcPlayProgress(int currentMs, int totalMs);
void onSvcPlayPaused();
void onSvcPlayResumed();

// 网络回调
void onSvcNetworkResponse(const HttpResult& result);
void onSvcNetworkError(int errCode, const std::string& msg);
void onSvcSearchResult(const SongList& songs);
void onSvcSongListReceived(const SongList& songs);

// 下载回调
void onSvcDownloadProgress(int songId, int progress);
void onSvcDownloadCompleted(int songId, const std::string& path);
void onSvcDownloadFailed(int songId, int errCode);

// 登录/认证回调
void onSvcLoginSuccess(const User& user);
void onSvcLoginFailed(int errCode);
void onSvcVipActivated(bool success);

// WebSocket 回调
void onSvcWebSocketConnected();
void onSvcWebSocketDisconnected();
void onSvcWebSocketMessage(const std::string& msg);
```

**📌 一眼就知道：**
- 这是异步结果，不是用户操作
- 来自 Service 层，不是 UI 层
- 需要 Presenter 处理并更新状态

---

### 3️⃣ 系统 / 环境入口（非业务）

**规则：**

```
onSys + 事件
```

#### ✅ 推荐示例

```cpp
// 网络状态
void onSysNetworkLost();
void onSysNetworkRecovered();
void onSysNetworkSlow();

// 系统资源
void onSysLowMemory();
void onSysStorageFull();
void onSysBatteryLow();

// 应用生命周期
void onSysAppResume();
void onSysAppPause();
void onSysAppExit();

// 升级相关
void onSysUpgradeRequired(const std::string& version);
void onSysUpgradeCompleted();
void onSysUpgradeFailed();

// 设备状态
void onSysDisplayOff();
void onSysDisplayOn();
void onSysAudioDeviceChanged();
```

**📌 特点：**
- 系统级事件，非业务逻辑
- 通常需要全局处理
- 可能影响多个模块

---

### 4️⃣ Presenter 内部函数（私有逻辑）

**规则：**

```
handle + 业务语义
```

#### ✅ 推荐示例

```cpp
private:
    // 处理播放请求
    void handlePlayRequest(int songId);
    void handlePlayCompleted();
    void handlePlayError(int errCode);
    
    // 处理网络请求
    void handleNetworkRequest(const std::string& url);
    void handleNetworkResponse(const HttpResult& result);
    void handleNetworkError(int errCode);
    
    // 处理状态更新
    void handleStateChanged(PlayerState newState);
    void handleProgressUpdate(int currentMs, int totalMs);
    
    // 处理数据更新
    void handleSongListUpdated(const SongList& songs);
    void handleSearchResult(const SongList& songs);
```

**📌 重要：**
- `handle` 永远是私有函数，不允许被外部调用
- 只被 `onUiXxx` / `onSvcXxx` / `onSysXxx` 调用
- 负责业务逻辑处理和状态管理

---

## 三、View 命名规范（极简，但要一致）

### View 只做两件事：**发 UI 事件 + 渲染**

### 1️⃣ UI 回调函数

**规则：**

```
emit + 动作
```

#### ✅ 推荐示例

```cpp
// 播放控制
void emitPlayClicked();
void emitPauseClicked();
void emitStopClicked();
void emitNextClicked();
void emitPrevClicked();

// 歌曲选择
void emitSongSelected(int songId);
void emitSongDoubleClicked(int songId);

// 搜索
void emitSearchSubmitted(const std::string& keyword);
void emitSearchTextChanged(const std::string& text);

// 导航
void emitBackPressed();
void emitHomePressed();
void emitHistoryPressed();

// 设置
void emitVolumeChanged(int volume);
void emitAudioTrackSwitched(int trackIndex);
```

**📌 为什么 View 不叫 `onXxx`？**
- 避免和 Presenter 的入口混淆
- `emit` 明确表示"发出事件"，不是"处理事件"
- 语义清晰：View 只负责触发，不负责处理

---

### 2️⃣ 渲染函数

**规则：**

```
render + 状态
```

#### ✅ 推荐示例

```cpp
// 播放状态渲染
void renderPlaying();
void renderPaused();
void renderStopped();
void renderLoading();
void renderError(const std::string& msg);

// 列表渲染
void renderSongList(const SongList& songs);
void renderSearchResult(const SongList& songs);
void renderHistoryList(const HistoryList& history);

// 进度渲染
void renderProgress(int currentMs, int totalMs);
void renderVolume(int volume);
void renderAudioTrack(int trackIndex);

// 空状态渲染
void renderEmpty();
void renderNoNetwork();
void renderNoResults();
```

**📌 特点：**
- View 只负责渲染，不负责业务逻辑
- 所有渲染函数都是被 Presenter 调用
- 状态变化通过渲染函数反映到 UI

---

## 四、StateMachine 命名规范（只管状态）

### 1️⃣ 状态迁移

**规则：**

```
transitionTo + State
```

#### ✅ 推荐示例

```cpp
// 播放器状态
void transitionToIdle();
void transitionToLoading();
void transitionToPlaying();
void transitionToPaused();
void transitionToError(int errCode);
void transitionToStopped();

// 网络状态
void transitionToNetworkConnected();
void transitionToNetworkDisconnected();
void transitionToNetworkSlow();

// 应用状态
void transitionToReady();
void transitionToInitializing();
void transitionToShuttingDown();
```

**📌 特点：**
- 状态机只负责状态管理
- 状态迁移是原子操作
- 状态变化后通知 Presenter

---

### 2️⃣ 状态判断（只读）

**规则：**

```
can + 动作
is + 状态
```

#### ✅ 推荐示例

```cpp
// 动作判断
bool canPlay();
bool canPause();
bool canStop();
bool canNext();
bool canPrev();

// 状态判断
bool isPlaying();
bool isPaused();
bool isStopped();
bool isLoading();
bool isError();

// 环境判断
bool isNetworkReady();
bool isNetworkConnected();
bool isStorageAvailable();
bool isVipActivated();
```

**📌 特点：**
- 只读函数，不改变状态
- 用于条件判断和 UI 状态控制
- 返回布尔值，语义清晰

---

## 五、Service 命名规范（避免侵入应用层）

### Service **不允许 onXxx（那是 Presenter 的特权）**

### 1️⃣ Service 行为

**规则：**

```
request + 动作
```

#### ✅ 推荐示例

```cpp
// 播放器服务
void requestPlay(int songId);
void requestPause();
void requestStop();
void requestNext();
void requestPrev();
void requestSeek(int positionMs);

// 网络服务
void requestSongList();
void requestSearch(const std::string& keyword);
void requestSongDetail(int songId);
void requestLogin(const std::string& username, const std::string& password);
void requestVipActivate(const std::string& code);

// 下载服务
void requestDownload(int songId);
void requestCancelDownload(int songId);

// WebSocket 服务
void requestConnect();
void requestDisconnect();
void requestSendMessage(const std::string& msg);
```

**📌 特点：**
- Service 只负责执行，不负责决策
- 所有请求都是异步的
- 结果通过回调返回给 Presenter

---

### 2️⃣ Service 回调（只回 Presenter）

**规则：**

Service 不直接暴露回调接口，而是通过 Presenter 的 `onSvcXxx` 方法回调。

#### ✅ 正确做法

```cpp
// Service 内部
class PlayerService {
private:
    Presenter* presenter_;  // 持有 Presenter 引用
    
    void onPlayFinished() {
        // 回调 Presenter
        presenter_->onSvcPlayFinished();
    }
    
    void onPlayError(int errCode) {
        // 回调 Presenter
        presenter_->onSvcPlayError(errCode);
    }
};
```

#### ❌ 错误做法

```cpp
// ❌ 错误：Service 不应该有 onXxx 方法
class PlayerService {
public:
    void onPlayFinished();  // 错误！
    void onPlayError(int errCode);  // 错误！
};
```

**📌 原因：**
- Service 不应该知道如何更新 UI
- 回调应该统一通过 Presenter
- 保持单向依赖：Service → Presenter → View

---

## 六、完整调用链示例（一眼就懂）

### 示例1：用户点击播放按钮

```text
[User Click]
   ↓
View.emitPlayClicked()
   ↓
Presenter.onUiPlayClicked()
   ↓
Presenter.handlePlayRequest()
   ↓
StateMachine.transitionToLoading()
   ↓
PlayerService.requestPlay(songId)
   ↓
[异步执行]
   ↓
PlayerService 内部完成播放
   ↓
Presenter.onSvcPlayStarted()
   ↓
Presenter.handlePlayStarted()
   ↓
StateMachine.transitionToPlaying()
   ↓
View.renderPlaying()
```

### 示例2：搜索歌曲

```text
[User Input]
   ↓
View.emitSearchSubmitted(keyword)
   ↓
Presenter.onUiSearchSubmitted(keyword)
   ↓
Presenter.handleSearchRequest(keyword)
   ↓
View.renderLoading()
   ↓
HttpService.requestSearch(keyword)
   ↓
[异步 HTTP 请求]
   ↓
Presenter.onSvcSearchResult(songs)
   ↓
Presenter.handleSearchResult(songs)
   ↓
StateMachine.updateSearchResults(songs)
   ↓
View.renderSearchResult(songs)
```

### 示例3：播放完成

```text
[TPlayer 回调]
   ↓
PlayerService 内部接收回调
   ↓
Presenter.onSvcPlayFinished()
   ↓
Presenter.handlePlayCompleted()
   ↓
StateMachine.transitionToIdle()
   ↓
HistoryService.addToHistory(songId)
   ↓
View.renderIdle()
```

### 示例4：网络错误

```text
[Network Error]
   ↓
HttpService 检测到错误
   ↓
Presenter.onSvcNetworkError(errCode, msg)
   ↓
Presenter.handleNetworkError(errCode, msg)
   ↓
StateMachine.transitionToNetworkError()
   ↓
View.renderError(msg)
```

---

## 七、这套命名解决了什么问题

### ✅ 解决的问题

1. **不需要解释"什么是 Event"**
   - 命名本身就是事件语义
   - 看函数名就知道是事件触发

2. **不需要引入 struct / enum**
   - 无需定义 Event 类型
   - 无需 Event 分发机制
   - MVP 阶段零心智负担

3. **阅读时可以顺着名字追代码**
   - `onUiXxx` → 来自 UI
   - `onSvcXxx` → 来自 Service
   - `onSysXxx` → 来自系统
   - 调用路径清晰可追溯

4. **两个工程师写出来是同一种风格**
   - 命名规范就是架构约束
   - 不需要额外的架构文档
   - 代码即文档

5. **MVP 阶段零心智负担**
   - 简单直接，不需要理解复杂的事件模型
   - 适合小团队快速开发
   - 后期可以平滑升级到显式 Event 模型

---

## 八、铁律与禁止事项

### 🎯 铁律（必须遵守）

> **应用层所有外部触发必须通过 Presenter 的 `onUiXxx` / `onSvcXxx` / `onSysXxx` 接口进入。**
>
> **Presenter 内部逻辑统一使用 `handleXxx` 命名。**
>
> **View 只负责 `emitXxx` 与 `renderXxx`，不参与业务决策。**
>
> **Service 不得直接操作 UI 或状态。**

---

### ❌ 禁止事项

#### 1. 禁止 Presenter 使用非标准命名

```cpp
// ❌ 错误
void play();  // 应该是 onUiPlayClicked
void handleClick();  // 应该是 onUiXxxClicked
void onPlay();  // 缺少前缀，无法区分来源
```

#### 2. 禁止 View 参与业务逻辑

```cpp
// ❌ 错误
void View::onPlayClicked() {
    PlayerService::instance().play();  // View 不应该直接调用 Service
}

// ✅ 正确
void View::emitPlayClicked() {
    presenter_->onUiPlayClicked();  // View 只负责触发
}
```

#### 3. 禁止 Service 直接更新 UI

```cpp
// ❌ 错误
void PlayerService::onPlayFinished() {
    view_->updatePlayButton();  // Service 不应该直接操作 UI
}

// ✅ 正确
void PlayerService::onPlayFinished() {
    presenter_->onSvcPlayFinished();  // 通过 Presenter 回调
}
```

#### 4. 禁止混用命名规范

```cpp
// ❌ 错误：混用命名
class Presenter {
    void onUiPlayClicked();  // ✅ 正确
    void play();  // ❌ 错误：缺少前缀
    void handlePlay();  // ✅ 正确（私有）
    void onPlayFinished();  // ❌ 错误：应该是 onSvcPlayFinished
};
```

#### 5. 禁止 View 使用 `onXxx` 命名

```cpp
// ❌ 错误
void View::onPlayClicked() {
    // 容易和 Presenter 的 onUiPlayClicked 混淆
}

// ✅ 正确
void View::emitPlayClicked() {
    presenter_->onUiPlayClicked();
}
```

---

### ✅ 正确示例（完整类）

```cpp
// View 类
class PlayerView {
public:
    void emitPlayClicked() {
        presenter_->onUiPlayClicked();
    }
    
    void renderPlaying() {
        // 更新 UI 显示播放状态
    }
    
    void renderPaused() {
        // 更新 UI 显示暂停状态
    }
    
private:
    Presenter* presenter_;
};

// Presenter 类
class PlayerPresenter {
public:
    // UI 入口
    void onUiPlayClicked() {
        if (stateMachine_.canPlay()) {
            handlePlayRequest();
        }
    }
    
    // Service 回调入口
    void onSvcPlayStarted() {
        handlePlayStarted();
    }
    
    void onSvcPlayFinished() {
        handlePlayCompleted();
    }
    
    // 系统入口
    void onSysNetworkLost() {
        handleNetworkLost();
    }
    
private:
    // 内部处理函数
    void handlePlayRequest() {
        stateMachine_.transitionToLoading();
        view_->renderLoading();
        playerService_->requestPlay(currentSongId_);
    }
    
    void handlePlayStarted() {
        stateMachine_.transitionToPlaying();
        view_->renderPlaying();
    }
    
    void handlePlayCompleted() {
        stateMachine_.transitionToIdle();
        view_->renderIdle();
    }
    
    void handleNetworkLost() {
        stateMachine_.transitionToNetworkError();
        view_->renderError("网络连接失败");
    }
    
private:
    PlayerView* view_;
    PlayerService* playerService_;
    PlayerStateMachine stateMachine_;
};
```

---

## 📚 相关文档

- [团队开发规范v1.md](../团队开发规范v1.md) ⭐⭐⭐ **必读**
- [C++架构设计-预分配内存版本.md](../architecture/C++架构设计-预分配内存版本.md) ⭐⭐⭐ **必读**
- [项目架构图（完整版）.md](../项目架构图（完整版）.md) ⭐⭐⭐ **必读**
- [代码审查Checklist.md](../代码审查Checklist.md) ⭐⭐⭐ **必读**

---

## 💡 总结

这套命名规范的核心价值：

1. **命名即架构**：通过命名实现架构约束，无需显式 Event 模型
2. **可读性强**：看函数名就知道调用路径和来源
3. **MVP 友好**：零心智负担，适合小团队快速开发
4. **可扩展**：后期可以平滑升级到显式 Event 模型
5. **一致性**：两个工程师写出来是同一种风格

**记住：在 MVP 阶段，命名就是你唯一、也是最重要的"架构约束工具"。**

---

**最后更新**: 2025-12-30  
**维护者**: 项目团队  
**状态**: ✅ 核心文档（架构约束）



# æ ‡å‡†çº¿ç¨‹æ¨¡æ¿ä¸å®ç°æŒ‡å—ï¼ˆF133 / Tina Linuxï¼‰

> **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.1  
> **æœ€åæ›´æ–°**ï¼š2025-12-30  
> **çŠ¶æ€**ï¼šâœ… å‚è€ƒæ–‡æ¡£ï¼ˆå·²åˆå¹¶åˆ°ç¼–ç è§„èŒƒï¼‰  
> **é€‚ç”¨å¹³å°**ï¼šF133 / Tina Linux  
> **ç›®æ ‡**ï¼šä¸ºå·¥ç¨‹å¸ˆæä¾›å¯ç›´æ¥ä½¿ç”¨çš„æ ‡å‡†çº¿ç¨‹æ¨¡æ¿

> **âš ï¸ é‡è¦æç¤º**ï¼šæœ¬æ–‡æ¡£å·²åˆå¹¶åˆ° [KTV_Appçº¿ç¨‹Singletonç¼–ç è§„èŒƒï¼ˆæœ€ç»ˆç‰ˆï¼‰.md](./KTV_Appçº¿ç¨‹Singletonç¼–ç è§„èŒƒï¼ˆæœ€ç»ˆç‰ˆï¼‰.md)ï¼Œå»ºè®®ç›´æ¥å‚è€ƒç¼–ç è§„èŒƒæ–‡æ¡£ã€‚æœ¬æ–‡æ¡£ä¿ç•™ä½œä¸ºå†å²å‚è€ƒã€‚

---

## ğŸ¯ æ ¸å¿ƒåŸåˆ™ï¼ˆä¸€å¥è¯ï¼‰

> **çº¿ç¨‹å°½é‡å¸¸é©»ï¼Œä»»åŠ¡æŒ‰éœ€å”¤é†’/ä¼‘çœ ã€‚çº¿ç¨‹æ˜¯å¸¸é©»èµ„æºï¼Œä¸æ˜¯ä¸šåŠ¡å¯¹è±¡ã€‚**

> **ğŸ“Œ æ¨èé˜…è¯»**ï¼š[KTV_Appçº¿ç¨‹Singletonç¼–ç è§„èŒƒï¼ˆæœ€ç»ˆç‰ˆï¼‰.md](./KTV_Appçº¿ç¨‹Singletonç¼–ç è§„èŒƒï¼ˆæœ€ç»ˆç‰ˆï¼‰.md) â­â­â­ **å¿…è¯»ï¼ˆé“å¾‹çº§ï¼‰** - åŒ…å«å®Œæ•´çš„æ¨¡æ¿ä»£ç ã€é¿å‘æŒ‡å—å’Œå·¥ç¨‹é“å¾‹

---

## ğŸ“‹ ç›®å½•

1. [æ ‡å‡†çº¿ç¨‹æ¨¡æ¿](#ä¸€-æ ‡å‡†çº¿ç¨‹æ¨¡æ¿)
2. [ä¸‰ç±»å¸¸é©»çº¿ç¨‹å®ç°](#äºŒ-ä¸‰ç±»å¸¸é©»çº¿ç¨‹å®ç°)
3. [ç¦æ­¢çš„çº¿ç¨‹ä½¿ç”¨æ–¹å¼](#ä¸‰-ç¦æ­¢çš„çº¿ç¨‹ä½¿ç”¨æ–¹å¼)
4. [çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†](#å››-çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†)

---

## ä¸€ã€æ ‡å‡†çº¿ç¨‹æ¨¡æ¿

### 1.1 å·¥ä½œçº¿ç¨‹æ¨¡æ¿ï¼ˆNetwork/Player/Cache Workerï¼‰

**é€‚ç”¨åœºæ™¯**ï¼šNetwork Workerã€Player Workerã€Cache Worker ç­‰éœ€è¦å¤„ç†ä»»åŠ¡çš„å¸¸é©»çº¿ç¨‹

```cpp
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <syslog.h>

/**
 * @brief æ ‡å‡†å·¥ä½œçº¿ç¨‹æ¨¡æ¿
 * 
 * ç‰¹ç‚¹ï¼š
 * - çº¿ç¨‹å¸¸é©»ï¼ˆApp å¯åŠ¨æ—¶åˆ›å»ºï¼ŒApp é€€å‡ºæ—¶é”€æ¯ï¼‰
 * - ä»»åŠ¡æŒ‰éœ€å”¤é†’/ä¼‘çœ ï¼ˆé˜»å¡åœ¨ condition_variableï¼‰
 * - ä¸ä½¿ç”¨ busy-loopï¼ˆwhile(1)+sleepï¼‰
 */
class StandardWorkerThread {
public:
    struct Task {
        int type;
        void* data;
        // ... ä»»åŠ¡æ•°æ®
    };

    StandardWorkerThread() : running_(false) {}
    
    ~StandardWorkerThread() {
        stop();
    }

    /**
     * @brief å¯åŠ¨çº¿ç¨‹
     */
    void start() {
        if (running_.load()) {
            return;  // å·²ç»å¯åŠ¨
        }
        
        running_.store(true);
        thread_ = std::thread(&StandardWorkerThread::workerLoop, this);
        syslog(LOG_INFO, "[ktv][thread] Worker thread started");
    }

    /**
     * @brief åœæ­¢çº¿ç¨‹
     */
    void stop() {
        if (!running_.load()) {
            return;  // å·²ç»åœæ­¢
        }
        
        running_.store(false);
        condition_.notify_all();  // å”¤é†’ç­‰å¾…çš„çº¿ç¨‹
        
        if (thread_.joinable()) {
            thread_.join();  // ç­‰å¾…çº¿ç¨‹é€€å‡º
        }
        
        syslog(LOG_INFO, "[ktv][thread] Worker thread stopped");
    }

    /**
     * @brief æ·»åŠ ä»»åŠ¡
     */
    void enqueue(const Task& task) {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            queue_.push(task);
        }
        condition_.notify_one();  // å”¤é†’ä¸€ä¸ªç­‰å¾…çš„çº¿ç¨‹
    }

private:
    /**
     * @brief å·¥ä½œå¾ªç¯ï¼ˆæ ¸å¿ƒå®ç°ï¼‰
     * 
     * å…³é”®ç‚¹ï¼š
     * 1. é˜»å¡åœ¨ condition_variableï¼ˆä¸ busy-loopï¼‰
     * 2. æ£€æŸ¥ running_ æ ‡å¿—
     * 3. å¤„ç†ä»»åŠ¡
     * 4. å¾ªç¯ç»§ç»­é˜»å¡ç­‰å¾…
     */
    void workerLoop() {
        syslog(LOG_INFO, "[ktv][thread] Worker thread loop started");
        
        while (running_.load()) {
            Task task;
            
            // é˜»å¡ç­‰å¾…ä»»åŠ¡ï¼ˆå…³é”®ï¼šä¸ busy-loopï¼‰
            {
                std::unique_lock<std::mutex> lock(mutex_);
                
                // ç­‰å¾…æ¡ä»¶ï¼šé˜Ÿåˆ—ä¸ä¸ºç©º æˆ– running_ ä¸º false
                condition_.wait(lock, [this]() {
                    return !queue_.empty() || !running_.load();
                });
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦é€€å‡º
                if (!running_.load()) {
                    break;
                }
                
                // é˜Ÿåˆ—ä¸ºç©ºï¼ˆå¼‚å¸¸æƒ…å†µï¼Œåº”è¯¥ä¸ä¼šå‘ç”Ÿï¼‰
                if (queue_.empty()) {
                    continue;
                }
                
                // å–å‡ºä»»åŠ¡
                task = queue_.front();
                queue_.pop();
            }
            
            // å¤„ç†ä»»åŠ¡ï¼ˆåœ¨é”å¤–æ‰§è¡Œï¼Œé¿å…é•¿æ—¶é—´æŒé”ï¼‰
            processTask(task);
        }
        
        syslog(LOG_INFO, "[ktv][thread] Worker thread loop exited");
    }

    /**
     * @brief å¤„ç†ä»»åŠ¡ï¼ˆå­ç±»å®ç°ï¼‰
     */
    virtual void processTask(const Task& task) {
        // å­ç±»å®ç°å…·ä½“ä»»åŠ¡å¤„ç†é€»è¾‘
        syslog(LOG_DEBUG, "[ktv][thread] Processing task type=%d", task.type);
    }

protected:
    std::thread thread_;
    std::atomic<bool> running_;
    std::queue<Task> queue_;
    std::mutex mutex_;
    std::condition_variable condition_;
};
```

### 1.2 ä½¿ç”¨ç¤ºä¾‹ï¼šNetwork Worker

```cpp
class NetworkWorker : public StandardWorkerThread {
public:
    static NetworkWorker& instance() {
        static NetworkWorker inst;
        return inst;
    }

protected:
    void processTask(const Task& task) override {
        switch (task.type) {
            case TASK_HTTP_REQUEST:
                handleHttpRequest(task);
                break;
            case TASK_WEBSOCKET_SEND:
                handleWebSocketSend(task);
                break;
            // ...
        }
    }

private:
    void handleHttpRequest(const Task& task) {
        // HTTP è¯·æ±‚å¤„ç†é€»è¾‘
        // ...
    }
};

// ä½¿ç”¨æ–¹å¼
void initNetworkWorker() {
    NetworkWorker::instance().start();
}

void sendHttpRequest(const std::string& url) {
    StandardWorkerThread::Task task;
    task.type = TASK_HTTP_REQUEST;
    task.data = /* ... */;
    NetworkWorker::instance().enqueue(task);
}

void cleanupNetworkWorker() {
    NetworkWorker::instance().stop();
}
```

---

## äºŒã€ä¸‰ç±»å¸¸é©»çº¿ç¨‹å®ç°

### 2.1 æ ¸å¿ƒå¸¸é©»çº¿ç¨‹ï¼ˆUI ä¸»çº¿ç¨‹ï¼‰

**ç‰¹ç‚¹**ï¼šApp ç”Ÿå‘½å‘¨æœŸï¼Œä¸é˜»å¡ï¼ˆè½®è¯¢æ¨¡å¼ï¼‰

```cpp
// UI ä¸»çº¿ç¨‹ï¼ˆä¸»å¾ªç¯ï¼‰
int main() {
    // åˆå§‹åŒ– LVGL
    lv_init();
    
    // åˆå§‹åŒ–æ˜¾ç¤ºå’Œè¾“å…¥
    init_display();
    init_input();
    
    // ä¸»å¾ªç¯ï¼ˆè½®è¯¢æ¨¡å¼ï¼Œä¸é˜»å¡ï¼‰
    while (g_app_running) {
        lv_timer_handler();  // LVGL å®šæ—¶å™¨å¤„ç†
        usleep(5000);        // 5msï¼Œé¿å… CPU å ç”¨è¿‡é«˜
    }
    
    return 0;
}
```

### 2.2 å·¥ä½œçº¿ç¨‹æ± ï¼ˆNetwork/Player Workerï¼‰

**ç‰¹ç‚¹**ï¼šçº¿ç¨‹å¸¸é©»ï¼Œä»»åŠ¡æŒ‰éœ€å”¤é†’/ä¼‘çœ ï¼ˆä½¿ç”¨ä¸Šé¢çš„æ¨¡æ¿ï¼‰

```cpp
// Network Worker å®ç°
class NetworkWorker : public StandardWorkerThread {
    // ä½¿ç”¨æ ‡å‡†æ¨¡æ¿
};

// Player Worker å®ç°
class PlayerWorker : public StandardWorkerThread {
    // ä½¿ç”¨æ ‡å‡†æ¨¡æ¿
};
```

### 2.3 ä½é¢‘å®ˆæŠ¤çº¿ç¨‹ï¼ˆLogUpload/UpgradeCheckerï¼‰

**ç‰¹ç‚¹**ï¼šå‘¨æœŸå”¤é†’ï¼Œä½¿ç”¨ sleep/timerfd

```cpp
/**
 * @brief æ—¥å¿—ä¸Šä¼ çº¿ç¨‹ï¼ˆä½é¢‘å®ˆæŠ¤çº¿ç¨‹ï¼‰
 */
class LogUploadThread {
public:
    static LogUploadThread& instance() {
        static LogUploadThread inst;
        return inst;
    }

    void start() {
        running_.store(true);
        thread_ = std::thread(&LogUploadThread::uploadLoop, this);
    }

    void stop() {
        running_.store(false);
        if (thread_.joinable()) {
            thread_.join();
        }
    }

private:
    void uploadLoop() {
        while (running_.load()) {
            // æ‰§è¡Œä¸Šä¼ ä»»åŠ¡
            if (hasPendingLogs()) {
                uploadLogs();
            }
            
            // é˜»å¡ç­‰å¾…ï¼ˆå‘¨æœŸå”¤é†’ï¼‰
            // æ–¹å¼1ï¼šä½¿ç”¨ sleepï¼ˆç®€å•ï¼‰
            sleep(60);  // 60 ç§’å”¤é†’ä¸€æ¬¡
            
            // æ–¹å¼2ï¼šä½¿ç”¨ timerfdï¼ˆæ›´ç²¾ç¡®ï¼Œå¯é€‰ï¼‰
            // waitForTimer(60);
        }
    }

    void uploadLogs() {
        // ä¸Šä¼ é€»è¾‘
    }

    bool hasPendingLogs() {
        // æ£€æŸ¥æ˜¯å¦æœ‰å¾…ä¸Šä¼ çš„æ—¥å¿—
        return false;
    }

    std::thread thread_;
    std::atomic<bool> running_;
};

// ä½¿ç”¨æ–¹å¼
void initLogUpload() {
    LogUploadThread::instance().start();
}

void cleanupLogUpload() {
    LogUploadThread::instance().stop();
}
```

---

## ä¸‰ã€ç¦æ­¢çš„çº¿ç¨‹ä½¿ç”¨æ–¹å¼

### âŒ é”™è¯¯ç¤ºä¾‹ 1ï¼šä¸ºæ¯æ¬¡æ“ä½œåˆ›å»ºçº¿ç¨‹

```cpp
// âŒ é”™è¯¯ï¼šä¸ºæ¯æ¬¡ç‚¹æ­Œåˆ›å»ºçº¿ç¨‹
void playSong(const std::string& url) {
    std::thread([url]() {
        // æ’­æ”¾é€»è¾‘
        TPlayerStart(url.c_str());
    }).detach();  // é”™è¯¯ï¼çº¿ç¨‹åˆ›å»º/é”€æ¯æˆæœ¬é«˜ï¼Œå¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨å¸¸é©» Player Worker
void playSong(const std::string& url) {
    PlayerCmd cmd;
    cmd.type = PlayerCmdType::PLAY;
    cmd.url = url;
    PlayerWorker::instance().enqueue(cmd);  // æ­£ç¡®ï¼
}
```

### âŒ é”™è¯¯ç¤ºä¾‹ 2ï¼šbusy-loopï¼ˆç©ºè½¬ï¼‰

```cpp
// âŒ é”™è¯¯ï¼šbusy-loopï¼Œæ¶ˆè€— CPU
void workerLoop() {
    while (running_) {
        if (!queue_.empty()) {
            processTask();
        }
        usleep(1000);  // é”™è¯¯ï¼å³ä½¿æ²¡æœ‰ä»»åŠ¡ä¹Ÿåœ¨ç©ºè½¬
    }
}

// âœ… æ­£ç¡®ï¼šé˜»å¡ç­‰å¾…
void workerLoop() {
    while (running_) {
        std::unique_lock<std::mutex> lock(mutex_);
        condition_.wait(lock, [this]() {
            return !queue_.empty() || !running_;
        });  // æ­£ç¡®ï¼æ— ä»»åŠ¡æ—¶é˜»å¡ï¼Œä¸æ¶ˆè€— CPU
        
        if (!running_) break;
        
        Task task = queue_.front();
        queue_.pop();
        lock.unlock();
        
        processTask(task);
    }
}
```

### âŒ é”™è¯¯ç¤ºä¾‹ 3ï¼šUI å›è°ƒä¸­åˆ›å»ºçº¿ç¨‹

```cpp
// âŒ é”™è¯¯ï¼šUI å›è°ƒä¸­åˆ›å»ºçº¿ç¨‹
void onPlayButtonClicked(lv_event_t* e) {
    std::thread([this]() {
        PlayerService::instance().play(current_song_url);
    }).detach();  // é”™è¯¯ï¼çº¿ç¨‹åˆ›å»ºæˆæœ¬é«˜ï¼Œå¯èƒ½å¯¼è‡´èµ„æºæ³„æ¼
}

// âœ… æ­£ç¡®ï¼šå‘é€å‘½ä»¤åˆ°é˜Ÿåˆ—
void onPlayButtonClicked(lv_event_t* e) {
    PlayerCmd cmd;
    cmd.type = PlayerCmdType::PLAY;
    cmd.url = current_song_url;
    PlayerCmdQueue::instance().enqueue(cmd);  // æ­£ç¡®ï¼
}
```

---

## å››ã€çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†

### 4.1 çº¿ç¨‹åˆ›å»ºæ—¶æœº

```cpp
// App å¯åŠ¨æ—¶åˆ›å»ºæ‰€æœ‰å¸¸é©»çº¿ç¨‹
int app_main_init() {
    // 1. åˆå§‹åŒ–æ ¸å¿ƒçº¿ç¨‹ï¼ˆUI ä¸»çº¿ç¨‹å·²åœ¨ main ä¸­ï¼‰
    
    // 2. å¯åŠ¨å·¥ä½œçº¿ç¨‹æ± 
    NetworkWorker::instance().start();
    PlayerWorker::instance().start();
    CacheWorker::instance().start();
    
    // 3. å¯åŠ¨ä½é¢‘å®ˆæŠ¤çº¿ç¨‹
    LogUploadThread::instance().start();
    UpgradeChecker::instance().start();
    
    return 0;
}
```

### 4.2 çº¿ç¨‹é€€å‡ºé¡ºåº

```cpp
// App é€€å‡ºæ—¶æŒ‰é¡ºåºåœæ­¢æ‰€æœ‰çº¿ç¨‹
void app_main_cleanup() {
    // 1. è®¾ç½®å…¨å±€é€€å‡ºæ ‡å¿—
    g_app_running = false;
    
    // 2. åœæ­¢ä½é¢‘å®ˆæŠ¤çº¿ç¨‹ï¼ˆç¬¬1ï¼‰
    LogUploadThread::instance().stop();
    UpgradeChecker::instance().stop();
    
    // 3. åœæ­¢å·¥ä½œçº¿ç¨‹æ± ï¼ˆç¬¬2ï¼‰
    CacheWorker::instance().stop();
    PlayerWorker::instance().stop();
    NetworkWorker::instance().stop();
    
    // 4. åœæ­¢ Event Loopï¼ˆç¬¬3ï¼‰
    EventBus::getInstance().stop();
    
    // 5. UI ä¸»çº¿ç¨‹æœ€åé€€å‡ºï¼ˆç¬¬4ï¼Œåœ¨ main ä¸­å¤„ç†ï¼‰
}
```

### 4.3 çº¿ç¨‹å®‰å…¨é€€å‡ºæ£€æŸ¥æ¸…å•

- [ ] æ‰€æœ‰çº¿ç¨‹éƒ½æœ‰ `start()` å’Œ `stop()` æ–¹æ³•
- [ ] `stop()` æ–¹æ³•è®¾ç½®é€€å‡ºæ ‡å¿—å¹¶å”¤é†’é˜»å¡çš„çº¿ç¨‹
- [ ] å·¥ä½œå¾ªç¯æ£€æŸ¥é€€å‡ºæ ‡å¿—
- [ ] ä½¿ç”¨ `thread.join()` ç­‰å¾…çº¿ç¨‹é€€å‡º
- [ ] é€€å‡ºé¡ºåºæ­£ç¡®ï¼ˆä¾èµ–å…³ç³»ï¼‰

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [çº¿ç¨‹æ¶æ„åŸºçº¿ï¼ˆæœ€ç»ˆç‰ˆï¼‰.md](../çº¿ç¨‹æ¶æ„åŸºçº¿ï¼ˆæœ€ç»ˆç‰ˆï¼‰.md)
- [KTV_Appç¨³å®šæ€§ä¸è‡ªæ„ˆè®¾è®¡è¯´æ˜.md](../sdk/KTV_Appç¨³å®šæ€§ä¸è‡ªæ„ˆè®¾è®¡è¯´æ˜.md)
- [æ¶ˆæ¯é˜Ÿåˆ—å®Œæ•´æŒ‡å—.md](../æ¶ˆæ¯é˜Ÿåˆ—å®Œæ•´æŒ‡å—.md)

---

**æœ€åæ›´æ–°**: 2025-12-30  
**ç»´æŠ¤è€…**: é¡¹ç›®å›¢é˜Ÿ


# Tina KTV MVP 产品与技术协作规范 v1.0

> **文档版本**：v1.0  
> **最后更新**：2025-12-30  
> **状态**：✅ 执行规范（PM必读）  
> **适用角色**：Tech Product Owner / 产品负责人  
> **目标**：控制系统复杂度上限，确保两人团队长期可维护

---

## 📋 目录

1. [PM 技术红线清单（每日必查）](#一-pm-技术红线清单每日必查)
2. [PM 用需求模板（点击 → 展示）](#二-pm-用需求模板点击--展示)
3. [工程师提需求时，你该问的10个问题](#三-工程师提需求时你该问的10个问题)
4. [PM 话术库（可直接用）](#四-pm-话术库可直接用)
5. [每日自检清单](#五-每日自检清单)

---

## 一、PM 技术红线清单（每日必查）

> **用途**：  
> 每天 code review / 评审 / 同步时，只问这些  
> 👉 **踩一条 = 立即叫停**

---

### 🚫 红线 1：线程红线（最高优先级）

**禁止项**：
- ❌ 新增 `std::thread / pthread`
- ❌ 新增 `while(1) + sleep/usleep`
- ❌ 新增 `condition_variable / semaphore`
- ❌ "先写了再说，后面再优化线程"
- ❌ 线程池、线程复用、动态线程管理

**✅ 允许**：
- ✅ 单线程同步调用
- ✅ SDK 内部线程（不可外露，由框架层封装）
- ✅ 框架层已提供的线程（NetworkWorker、EventDispatcher等）

**检查方式**：
- 每天 code review 时搜索 `std::thread`、`pthread_create`
- 看到新的线程创建代码，立即叫停

---

### 🚫 红线 2：资源与生命周期红线

**禁止项**：
- ❌ 页面反复 `create / destroy`（应该用 `show() / hide()`）
- ❌ UI 层 `new / delete`
- ❌ Service 层持有 LVGL 对象（`lv_obj_t*`）
- ❌ 不明确 owner 的全局对象
- ❌ 在循环中创建/销毁控件
- ❌ 页面切换时销毁页面

**✅ 允许**：
- ✅ 页面 Singleton（创建一次，用 `show() / hide()` 切换）
- ✅ 全局 Repo / Adapter Singleton（由框架层管理）
- ✅ 预分配的控件池（固定数量，复用）

**检查方式**：
- 搜索 `lv_obj_create`、`lv_obj_del`、`new`、`delete`
- 检查页面切换逻辑，是否使用 `show() / hide()`

---

### 🚫 红线 3：层级越权红线

**禁止项**：
- ❌ UI 直接调 `libcurl / sqlite / tplayer`
- ❌ Service 操作控件（`lv_obj_xxx`）
- ❌ Controller 解析 JSON（应该由 Model 层处理）
- ❌ 任意层"顺手 include SDK 头文件"
- ❌ UI 层直接访问数据库
- ❌ Service 层直接操作 UI 状态

**✅ 允许**：
- ✅ UI → Event（通过 EventQueue 发送事件）
- ✅ Controller → Service（调用 Service 接口）
- ✅ Service → Adapter（通过框架层 Adapter）

**架构边界**：
```
UI层      →  只能调用 Controller 和 EventQueue
Controller →  只能调用 Service
Service    →  只能调用 Adapter / NetworkService / PlayerService
Adapter    →  只能调用 SDK（libcurl、sqlite、tplayer）
```

**检查方式**：
- 检查 UI 代码中是否有 `curl_`、`sqlite3_`、`TPlayer` 调用
- 检查 Service 代码中是否有 `lv_obj_` 调用

---

### 🚫 红线 4：架构升级红线（PM 专属）

**禁止项**（未经 PM 同意）：
- ❌ 引入新的 event queue（已有 EventQueue）
- ❌ 多并发请求（应该串行）
- ❌ 后台预加载（MVP 不需要）
- ❌ 缓存策略升级（MVP 不需要）
- ❌ 无锁队列（moodycamel 等，MVP 不需要）
- ❌ WebSocket 并发连接（应该单连接）
- ❌ 线程池（应该固定线程）

**✅ 允许**（框架层已有）：
- ✅ EventQueue + EventDispatcher（框架层提供）
- ✅ NetworkService（框架层提供，串行请求）
- ✅ PlayerService（框架层提供）

**检查方式**：
- 工程师提出"性能优化"、"并发"、"缓存"等关键词时，立即问："这个需求一定要现在做吗？"

---

### 🚫 红线 5：依赖引入红线

**禁止项**：
- ❌ 引入新的第三方库（除非已明确批准）
- ❌ 引入 boost、Qt、STL 复杂特性
- ❌ 引入 ORM、反射、RPC 框架
- ❌ 引入新的 JSON 库（已有 cJSON）

**✅ 允许**（已批准列表）：
- ✅ libcurl（HTTP 客户端）
- ✅ cJSON（JSON 解析）
- ✅ LVGL（UI 框架）
- ✅ SQLite3（数据库）
- ✅ TPlayer（播放器 SDK）
- ✅ std::queue、std::mutex、std::condition_variable（标准库）

**检查方式**：
- 检查 `CMakeLists.txt` 中的新依赖
- 检查 `#include` 语句中的新库

---

### 🧠 PM 每日一句自检

> **这个改动，有没有让工程师多背一个"长期心智负担"？**  
> 如果有，叫停。

---

## 二、PM 用需求模板（点击 → 展示）

> **这是你以后提需求唯一允许的格式**  
> 直接复制模板，填写内容

---

### 需求模板

```markdown
## 需求标题

【MVP】点击歌手分类 → 展示歌手列表

---

## 1️⃣ 用户动作（必须是一个）

* 用户点击：`歌手分类按钮`

---

## 2️⃣ 系统行为（黑盒描述）

* 系统发起网络请求
* 系统显示 loading
* 网络返回后展示列表

**❌ 不允许描述实现细节**：
- 不写线程
- 不写 queue
- 不写 libcurl
- 不写 EventDispatcher

---

## 3️⃣ 数据要求（最小）

* **数量**：10 条即可
* **字段**：`id + name`
* **顺序**：接口返回顺序
* **格式**：列表形式展示

---

## 4️⃣ UI 结果（肉眼可验）

* ✅ 页面不跳转
* ✅ loading 可见（点击后 1 秒内显示）
* ✅ 列表出现 10 个名字
* ✅ 可滚动
* ✅ 每个条目显示：歌手名称

---

## 5️⃣ MVP 边界（非常重要）

**不支持**：
- ❌ 不支持缓存（每次点击都请求）
- ❌ 不支持预加载
- ❌ 不支持错误重试（失败直接 toast）
- ❌ 不支持分页（只显示 10 条）
- ❌ 不支持搜索过滤

**👉 写出来 = 工程师不许越界**

---

## 6️⃣ 验收标准（Yes / No）

* ✅ 点击是否有反馈（按钮状态变化）
* ✅ 1 秒内是否看到 loading
* ✅ 返回后是否展示 10 条
* ✅ 网络失败是否显示 toast
* ✅ 列表是否可以滚动

---

## 7️⃣ 技术约束（PM 必填）

* ✅ 必须使用 NetworkService（框架层提供）
* ✅ 必须使用 EventQueue（框架层提供）
* ✅ 不允许新增线程
* ✅ 不允许新增 Service

---

## 8️⃣ 优先级

* **优先级**：P1（MVP 核心功能）
* **截止时间**：X 月 X 日
* **依赖**：无

---

## 9️⃣ 验收人

* **PM**：XXX
* **工程师**：XXX
* **测试**：XXX（可选，MVP 阶段可省略）

---

## 🔟 备注

* 后续版本可以加入缓存、分页等功能
* 当前版本以"可用"为第一优先级
```

---

### 🧠 PM 自检一句话

> **这个需求，是不是一个"完整闭环"，但又"足够蠢"？**  
> 是，就对了。

---

## 三、工程师提需求时，你该问的 10 个问题

> **这是你的"护城河"**  
> 不需要技术细节，但能挡 80% 架构坑  
> **按顺序问，任何一题答"是"，都要深入追问**

---

### 1️⃣ 这个需求 **一定要现在做吗？**

**问题**：
- 这个需求是不是 MVP 生死线？
- 如果延后 2 周，会影响 MVP 交付吗？

**答案判断**：
- ❌ 如果不是 MVP 生死线 → **延后**
- ✅ 如果是 MVP 核心功能 → 继续下一题

---

### 2️⃣ 能不能先用同步方式顶住？

**问题**：
- 这个功能能不能用同步调用实现？
- 用户能接受等待 1-2 秒吗？

**答案判断**：
- ✅ 如果能 → **禁止并发**，要求同步实现
- ❌ 如果不能（会卡 UI）→ 继续下一题

---

### 3️⃣ 是否引入新线程？

**问题**：
- 实现这个功能，需要创建新的线程吗？
- 能不能用框架层已有的线程？

**答案判断**：
- ✅ 是 → **直接否决**（除非你批准）
- ❌ 不是 → 继续下一题

**追问**：
- 为什么不能用 NetworkWorker 线程？
- 为什么不能用 EventDispatcher 线程？

---

### 4️⃣ 是否需要跨模块通信？

**问题**：
- 这个功能涉及多个模块吗？
- 需要 Service 通知 UI 吗？

**答案判断**：
- ✅ 是 → **必须走 Event**（EventQueue）
- ❌ 不是（单模块内部）→ 继续下一题

**追问**：
- 能不能在同一个模块内完成？
- 能不能用回调函数（不是跨模块）？

---

### 5️⃣ 是否需要新增全局对象？

**问题**：
- 这个功能需要全局可访问的对象吗？
- 这个对象需要长期存在吗？

**答案判断**：
- ✅ 是 → **必须是 Singleton**
- ❌ 不是（局部对象）→ 继续下一题

**追问**：
- 为什么不能作为局部变量？
- 为什么不能作为参数传递？

---

### 6️⃣ 是否需要长期驻留内存？

**问题**：
- 这个对象/数据需要一直存在吗？
- 什么时候可以释放？

**答案判断**：
- ✅ 是 → **明确释放策略或拒绝**
- ❌ 不是（用完即释放）→ 继续下一题

**追问**：
- 能否在使用完后立即释放？
- 能否用栈变量或临时对象？

---

### 7️⃣ UI 是否依赖网络成功？

**问题**：
- 这个功能需要网络请求吗？
- UI 需要等待网络返回吗？

**答案判断**：
- ✅ 是 → **必须有 loading / error 状态**
- ❌ 不是（本地数据）→ 继续下一题

**追问**：
- loading 状态在哪里显示？
- 网络失败时显示什么？

---

### 8️⃣ 失败是否可接受？

**问题**：
- 网络失败时，用户可以接受吗？
- 需要自动重试吗？

**答案判断**：
- ✅ 可接受 → **不做重试**（显示错误提示即可）
- ❌ 不可接受 → **延后需求**（MVP 阶段不做）

**追问**：
- 为什么失败不可接受？
- 能否降级为"失败时显示提示"？

---

### 9️⃣ 这个需求 2 周后还能改吗？

**问题**：
- 这个功能的设计，2 周后还能调整吗？
- 如果用户反馈不好，能快速改吗？

**答案判断**：
- ❌ 不能（设计太重）→ **拒绝或简化**
- ✅ 能（设计灵活）→ 继续下一题

**追问**：
- 为什么 2 周后不能改？
- 能否先用简单方案，后续再优化？

---

### 🔟 如果团队再少 1 个人，这需求还能做吗？

**问题**：
- 这个功能，1 个人能做吗？
- 复杂度是否在可控范围内？

**答案判断**：
- ❌ 不能（需要多人协作）→ **砍掉或拆分**
- ✅ 能（1 个人可以完成）→ **批准**

**追问**：
- 能否拆分为更小的需求？
- 能否先做简化版本？

---

### 🧠 PM 审查流程

**每次需求评审时，按顺序问这 10 个问题**：

1. ✅ 必须现在做？
2. ✅ 能同步实现？
3. ✅ 不引入新线程？
4. ✅ 跨模块走 Event？
5. ✅ 全局对象是 Singleton？
6. ✅ 内存可释放？
7. ✅ 有 loading/error？
8. ✅ 失败可接受？
9. ✅ 2 周后可改？
10. ✅ 1 个人能做？

**任何一题答"否"或不符合要求，立即叫停。**

---

## 四、PM 话术库（可直接用）

> **在任何评审、同步会上，原封不动说**  
> 不需要解释，直接使用

---

### 话术 1：复杂度控制（最常用）

> **我们现在不是在拼功能多少，  
> 是在拼能不能在两个人的情况下长期维护。  
> 所以任何增加复杂度的方案，  
> 都必须等到产品验证成立之后。**

**使用场景**：
- 工程师提出"性能优化"、"并发"、"缓存"等方案时
- 评审会上有人建议"提前做复杂功能"时

---

### 话术 2：线程红线

> **我们已经有 NetworkWorker 和 EventDispatcher 线程了，  
> 不需要再新增线程。  
> 如果这个功能必须用线程，  
> 说明设计有问题，需要重新思考。**

**使用场景**：
- 工程师提出需要创建新线程时

---

### 话术 3：MVP 边界

> **这个功能不在 MVP 范围内。  
> 我们先保证 MVP 能跑起来，  
> 后续版本再考虑这个功能。**

**使用场景**：
- 工程师提出"顺便实现"额外功能时
- 需求范围超出 MVP 时

---

### 话术 4：架构升级

> **这个架构升级需要产品需求支撑。  
> 如果用户没有这个需求，  
> 我们不应该提前做架构升级。**

**使用场景**：
- 工程师提出"技术优化"、"架构升级"时

---

### 话术 5：失败可接受

> **网络失败在 MVP 阶段是可接受的。  
> 用户看到错误提示就可以了，  
> 不需要自动重试、不需要复杂错误处理。  
> 如果这个失败不可接受，  
> 说明这个功能不应该在 MVP 阶段做。**

**使用场景**：
- 工程师提出"错误重试"、"复杂错误处理"时

---

### 话术 6：资源管理

> **我们不允许页面反复创建销毁。  
> 应该用 show() / hide() 切换页面，  
> 页面应该是 Singleton。**

**使用场景**：
- 代码 review 时发现页面创建/销毁逻辑时

---

### 话术 7：层级边界

> **UI 层不能直接调用 SDK。  
> 必须通过 Service 层，  
> 这是架构红线。**

**使用场景**：
- 代码 review 时发现 UI 层直接调用 libcurl/sqlite/tplayer 时

---

### 话术 8：需求完整性

> **这个需求是不是一个"完整闭环"，但又"足够蠢"？  
> 如果太复杂，说明需求需要拆分。  
> 如果不够完整，说明需求需要补充。**

**使用场景**：
- 需求评审时，判断需求是否合适时

---

## 五、每日自检清单

> **每天 code review / 评审前，快速自检**

---

### 每日必查（5 分钟）

- [ ] **线程检查**：搜索 `std::thread`、`pthread_create`，是否有新增线程？
- [ ] **资源检查**：搜索 `new`、`delete`、`lv_obj_create`、`lv_obj_del`，是否有动态创建/销毁？
- [ ] **层级检查**：检查 UI 代码是否有 `curl_`、`sqlite3_`、`TPlayer` 调用？
- [ ] **依赖检查**：检查 `CMakeLists.txt` 是否有新增依赖？
- [ ] **需求检查**：今天的需求是否符合"完整闭环、足够蠢"的标准？

---

### 每周必查（30 分钟）

- [ ] **架构检查**：是否有未经批准的架构升级？
- [ ] **复杂度检查**：代码复杂度是否在可控范围内？
- [ ] **需求回顾**：本周的需求是否都符合 MVP 边界？
- [ ] **技术债检查**：是否有临时方案需要后续重构？

---

### 每月必查（2 小时）

- [ ] **架构评审**：整体架构是否符合规范？
- [ ] **依赖评审**：依赖库是否都在批准列表中？
- [ ] **复杂度评审**：代码库是否还在可控范围内？
- [ ] **需求回顾**：MVP 边界是否被突破？

---

## 六、PM 角色定位

> **你现在这个角色，不是"不写代码的 PM"，而是：**

### 控制系统复杂度上限的人

在 **F133 / Tina / 嵌入式 Linux** 项目里，  
这比多一个工程师值钱得多。

---

### 你的核心价值

1. **设定边界**：明确什么能做，什么不能做
2. **控制复杂度**：确保两人团队能长期维护
3. **决策依据**：用产品需求支撑技术决策
4. **风险控制**：提前识别技术风险，避免技术债

---

### 你的工作方式

- **每天**：code review、需求评审、同步会
- **每周**：架构评审、复杂度检查
- **每月**：整体回顾、边界调整

---

## 七、紧急情况处理

### 工程师踩了红线，怎么办？

1. **立即叫停**：不讨论、不解释，直接叫停
2. **指出红线**：明确告诉工程师违反了哪条红线
3. **要求回退**：要求立即回退到红线内的方案
4. **记录问题**：记录这次违规，作为后续培训素材

---

### 工程师坚持要违反红线，怎么办？

1. **拒绝批准**：明确拒绝，不批准这个方案
2. **升级讨论**：如果确实有产品需求，升级到团队讨论
3. **重新设计**：要求重新设计符合红线的方案
4. **延后需求**：如果无法在红线内实现，延后需求

---

### 需求范围超出 MVP，怎么办？

1. **明确拒绝**：不在 MVP 范围内的需求，明确拒绝
2. **记录需求**：记录到 backlog，后续版本考虑
3. **优先级排序**：如果有产品价值，后续版本优先考虑
4. **坚守边界**：坚决不突破 MVP 边界

---

## 📚 相关文档

- **架构文档**：[项目架构图（完整版）.md](../项目架构图（完整版）.md) ⭐⭐⭐ **必读**
- **工程规范**：[工程规范完整指南（量产级）.md](./工程规范完整指南（量产级）.md) ⭐⭐⭐ **必读**
- **代码生成**：[Cursor开发指南.md](../Cursor开发指南.md) ⭐⭐ **参考**
- **需求文档**：[MVP版本需求整理（最终版）.md](../MVP版本需求整理（最终版）.md) ⭐⭐⭐ **必读**

---

**最后更新**: 2025-12-30  
**状态**: ✅ 执行规范（PM必读）  
**维护者**: Tech Product Owner


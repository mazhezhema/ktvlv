# æœ€å°æ¨¡æ¿åŒ…ï¼ˆå¯ç›´æ¥æ‹·è´ï¼‰

> **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
> **æœ€åæ›´æ–°**ï¼š2025-12-30  
> **çŠ¶æ€**ï¼šâœ… å®šç‰ˆï¼ˆå¯ç›´æ¥æ‹·è´ä½¿ç”¨ï¼‰  
> **ç”¨é€”**ï¼šæ–°åŠŸèƒ½å¼€å‘æ—¶ï¼Œç›´æ¥å¤åˆ¶æ¨¡æ¿ä½¿ç”¨

---

## ğŸ“‹ æ¨¡æ¿è¯´æ˜

æ‰€æœ‰æ¨¡æ¿åŸºäº **C++** å®ç°ï¼Œç¬¦åˆé¡¹ç›®æ¶æ„è§„èŒƒã€‚

---

## 1ï¸âƒ£ Event æ¨¡æ¿

### event_types.hï¼ˆPM å®šä¹‰ï¼Œå·¥ç¨‹å¸ˆåªè¯»ï¼‰

```cpp
// src/events/event_types.h
#ifndef KTVLV_EVENTS_EVENT_TYPES_H
#define KTVLV_EVENTS_EVENT_TYPES_H

namespace ktv::events {

enum class EventType {
    // UI äº‹ä»¶ï¼ˆ1000-1999ï¼‰
    EVENT_CATEGORY_CLICK = 1000,
    EVENT_SEARCH_SUBMITTED = 1001,
    EVENT_SONG_SELECTED = 1002,
    
    // Service å›è°ƒäº‹ä»¶ï¼ˆ2000-2999ï¼‰
    EVENT_CATEGORY_DATA_READY = 2000,
    EVENT_SEARCH_RESULT_READY = 2001,
    EVENT_NETWORK_ERROR = 2002,
    EVENT_SONG_LIST_READY = 2003,
};

struct AppEvent {
    EventType type;
    int arg1 = 0;           // é€šç”¨å‚æ•°1ï¼ˆå¦‚ categoryId, songIdï¼‰
    int arg2 = 0;           // é€šç”¨å‚æ•°2
    void* data = nullptr;   // å¯é€‰æ•°æ®æŒ‡é’ˆï¼ˆé¢„åˆ†é…å†…å­˜ï¼‰
};

}  // namespace ktv::events

#endif  // KTVLV_EVENTS_EVENT_TYPES_H
```

---

## 2ï¸âƒ£ EventQueue æ¨¡æ¿ï¼ˆæ¡†æ¶å±‚ï¼Œå·¥ç¨‹å¸ˆåªä½¿ç”¨ï¼‰

```cpp
// src/events/event_queue.hï¼ˆæ¡†æ¶å±‚æä¾›ï¼‰
class EventQueue {
public:
    static EventQueue& instance();
    void enqueue(const AppEvent& ev);  // å…¥é˜Ÿ
    bool dequeue(AppEvent& ev, int timeout_ms = -1);  // å‡ºé˜Ÿï¼ˆé˜»å¡ï¼‰
};

// ä½¿ç”¨ç¤ºä¾‹
AppEvent ev;
ev.type = EventType::EVENT_CATEGORY_CLICK;
ev.arg1 = categoryId;
EventQueue::instance().enqueue(ev);
```

---

## 3ï¸âƒ£ EventDispatcher æ¨¡æ¿ï¼ˆæ¡†æ¶å±‚ï¼ŒPM Aï¼‰

```cpp
// src/events/event_dispatcher.hï¼ˆæ¡†æ¶å±‚æä¾›ï¼‰
class EventDispatcher {
public:
    static EventDispatcher& instance();
    void start();  // å¯åŠ¨ EventDispatcher çº¿ç¨‹
    void stop();
    
private:
    void dispatchLoop();  // EventDispatcher çº¿ç¨‹å¾ªç¯
    void dispatch(const AppEvent& ev);  // switch è·¯ç”±
};

// ä½¿ç”¨ç¤ºä¾‹ï¼ˆmain.cppï¼‰
EventDispatcher::instance().start();
```

---

## 4ï¸âƒ£ Controller æ¨¡æ¿ï¼ˆåªç¼–æ’ï¼‰

```cpp
// src/features/category/CategoryController.h
#pragma once
#include "events/event_queue.h"
#include "events/event_types.h"

class CategoryController {
public:
    static CategoryController& instance();
    
    // ========== UI å…¥å£ï¼ˆæ¥è‡ª Viewï¼‰==========
    void onUiCategoryClicked(int categoryId);
    
    // ========== Service å›è°ƒå…¥å£ï¼ˆæ¥è‡ª Serviceï¼‰==========
    void onSvcCategoryDataReady(int categoryId, void* data);
    void onSvcNetworkError(int errCode, const std::string& msg);
    
private:
    CategoryController() = default;
    ~CategoryController() = default;
    CategoryController(const CategoryController&) = delete;
    CategoryController& operator=(const CategoryController&) = delete;
    
    // ========== å†…éƒ¨å¤„ç†å‡½æ•° ==========
    void handleCategoryRequest(int categoryId);
    void handleCategoryResult(int categoryId, void* data);
    void handleNetworkError(int errCode);
};

// src/features/category/CategoryController.cpp
CategoryController& CategoryController::instance() {
    static CategoryController inst;
    return inst;
}

void CategoryController::onUiCategoryClicked(int categoryId) {
    // UI è§¦å‘ï¼šå¤„ç†ç”¨æˆ·ç‚¹å‡»
    handleCategoryRequest(categoryId);
}

void CategoryController::handleCategoryRequest(int categoryId) {
    // å†…éƒ¨å¤„ç†ï¼šå‘é€äº‹ä»¶åˆ° EventQueue
    AppEvent ev;
    ev.type = EventType::EVENT_CATEGORY_CLICK;
    ev.arg1 = categoryId;
    EventQueue::instance().enqueue(ev);
    
    // EventDispatcher ä¼šè·¯ç”±åˆ° CategoryService::onClick(categoryId)
}

void CategoryController::onSvcCategoryDataReady(int categoryId, void* data) {
    // Service å›è°ƒï¼šå¤„ç†ç½‘ç»œè¿”å›çš„æ•°æ®
    handleCategoryResult(categoryId, data);
}

void CategoryController::handleCategoryResult(int categoryId, void* data) {
    // å†…éƒ¨å¤„ç†ï¼šæ›´æ–° UI
    CategoryPage::instance().setLoading(false);
    CategoryPage::instance().updateCategoryList(data);
}
```

---

## 5ï¸âƒ£ Service æ¨¡æ¿ï¼ˆä¸šåŠ¡é€»è¾‘ï¼‰

```cpp
// src/features/category/CategoryService.h
#pragma once
#include "events/event_queue.h"
#include "events/event_types.h"
#include "services/network_service.h"

class CategoryService {
public:
    static CategoryService& instance();
    
    // ========== EventDispatcher è·¯ç”±å…¥å£ ==========
    void onClick(int categoryId);
    
private:
    CategoryService() = default;
    ~CategoryService() = default;
    CategoryService(const CategoryService&) = delete;
    CategoryService& operator=(const CategoryService&) = delete;
    
    void requestCategoryData(int categoryId);
    void handleCategoryResponse(int categoryId, void* data);
    
private:
    std::map<int, CategoryData> cache_;
};

// src/features/category/CategoryService.cpp
CategoryService& CategoryService::instance() {
    static CategoryService inst;
    return inst;
}

void CategoryService::onClick(int categoryId) {
    // EventDispatcher è·¯ç”±åˆ°è¿™é‡Œ
    // Service å†³å®šï¼šæ˜¯å¦èµ°ç½‘ç»œï¼Œæ˜¯å¦ç”¨ç¼“å­˜
    if (cache_.find(categoryId) != cache_.end()) {
        // ç¼“å­˜å‘½ä¸­ï¼šç›´æ¥å‘é€äº‹ä»¶
        AppEvent ev;
        ev.type = EventType::EVENT_CATEGORY_DATA_READY;
        ev.arg1 = categoryId;
        ev.data = &cache_[categoryId];
        EventQueue::instance().enqueue(ev);
    } else {
        // ç¼“å­˜æœªå‘½ä¸­ï¼šè§¦å‘ç½‘ç»œè¯·æ±‚
        NetworkService::instance().fetchCategory(categoryId);
    }
}
```

---

## 6ï¸âƒ£ NetworkService æ¨¡æ¿ï¼ˆPM Aæ¥å£ï¼Œå·¥ç¨‹å¸ˆBå®ç°ï¼‰

```cpp
// src/services/network_service.hï¼ˆPM Aæ¥å£ï¼‰
#pragma once
#include "events/event_queue.h"
#include "events/event_types.h"
#include <string>

class NetworkService {
public:
    static NetworkService& instance();
    
    bool init();  // åˆå§‹åŒ–
    void cleanup();
    
    // å‘èµ· HTTP GET è¯·æ±‚ï¼ˆå¼‚æ­¥ï¼Œç»“æœé€šè¿‡Eventè¿”å›ï¼‰
    void fetchCategory(int categoryId);
    void fetchSearch(const std::string& keyword);
    
private:
    NetworkService() = default;
    ~NetworkService() = default;
    NetworkService(const NetworkService&) = delete;
    NetworkService& operator=(const NetworkService&) = delete;
    
    void sendEvent(EventType type, int arg1, void* data = nullptr);
    void sendNetworkError(int curlCode, const std::string& url);
    
private:
    CURL* curl_ = nullptr;
    // ...
};

// src/services/network_service.cppï¼ˆå·¥ç¨‹å¸ˆBå®ç°ï¼‰
void NetworkService::fetchCategory(int categoryId) {
    std::string url = "http://api.example.com/category/" + std::to_string(categoryId);
    
    // åœ¨ Network Worker çº¿ç¨‹ä¸­æ‰§è¡Œï¼ˆæ¡†æ¶å±‚æä¾›ï¼‰
    NetworkWorker::instance().post([this, url, categoryId]() {
        HttpResponse response = performRequest(url);
        
        if (response.success) {
            // æˆåŠŸï¼šè§£æ JSONï¼Œå‘é€äº‹ä»¶
            void* data = parseCategoryJson(response.body);  // é¢„åˆ†é…å†…å­˜
            sendEvent(EventType::EVENT_CATEGORY_DATA_READY, categoryId, data);
        } else {
            // å¤±è´¥ï¼šå‘é€é”™è¯¯äº‹ä»¶
            sendNetworkError(response.curl_code, url);
        }
    });
}
```

---

## 7ï¸âƒ£ EventDispatcher è·¯ç”±æ¨¡æ¿ï¼ˆPM Aï¼‰

```cpp
// src/events/event_dispatcher.cppï¼ˆæ¡†æ¶å±‚å®ç°ï¼‰
void EventDispatcher::dispatch(const AppEvent& ev) {
    switch (ev.type) {
        case EventType::EVENT_CATEGORY_CLICK:
            CategoryService::instance().onClick(ev.arg1);
            break;
            
        case EventType::EVENT_CATEGORY_DATA_READY:
            CategoryController::instance().onSvcCategoryDataReady(ev.arg1, ev.data);
            break;
            
        case EventType::EVENT_NETWORK_ERROR:
            // ç»Ÿä¸€é”™è¯¯å¤„ç†
            ErrorHandler::instance().onNetworkError(ev.arg1);
            break;
            
        default:
            syslog(LOG_WARNING, "[ktv][event] Unknown event type: %d", 
                   static_cast<int>(ev.type));
            break;
    }
}
```

---

## 8ï¸âƒ£ Page æ¨¡æ¿ï¼ˆSingletonï¼Œshow/hideï¼‰

```cpp
// src/ui/pages/PageCategory.h
#pragma once
#include <lvgl.h>

class PageCategory {
public:
    static PageCategory& instance();
    
    void show();
    void hide();
    void updateCategoryList(void* data);
    void setLoading(bool loading);
    
private:
    PageCategory();
    ~PageCategory() = default;
    PageCategory(const PageCategory&) = delete;
    PageCategory& operator=(const PageCategory&) = delete;
    
    void buildUI();
    
private:
    lv_obj_t* root_ = nullptr;
    lv_obj_t* list_ = nullptr;
    lv_obj_t* loading_ = nullptr;
    bool visible_ = false;
};

// src/ui/pages/PageCategory.cpp
PageCategory& PageCategory::instance() {
    static PageCategory inst;
    return inst;
}

PageCategory::PageCategory() {
    root_ = lv_obj_create(lv_scr_act());
    buildUI();
    lv_obj_add_flag(root_, LV_OBJ_FLAG_HIDDEN);
}

void PageCategory::show() {
    lv_obj_clear_flag(root_, LV_OBJ_FLAG_HIDDEN);
    visible_ = true;
}

void PageCategory::hide() {
    lv_obj_add_flag(root_, LV_OBJ_FLAG_HIDDEN);
    visible_ = false;
}

void PageCategory::setLoading(bool loading) {
    if (loading_) {
        if (loading) {
            lv_obj_clear_flag(loading_, LV_OBJ_FLAG_HIDDEN);
        } else {
            lv_obj_add_flag(loading_, LV_OBJ_FLAG_HIDDEN);
        }
    }
}

void PageCategory::updateCategoryList(void* data) {
    CategoryData* categoryData = static_cast<CategoryData*>(data);
    // æ›´æ–°åˆ—è¡¨ï¼ˆä¸åˆ›å»ºæ–°æ§ä»¶ï¼Œåªæ›´æ–°å·²æœ‰æ§ä»¶ï¼‰
    // ...
}
```

---

## 9ï¸âƒ£ å®Œæ•´è°ƒç”¨é“¾ç¤ºä¾‹

```cpp
// 1. UI å±‚ï¼šç”¨æˆ·ç‚¹å‡»
void onCategoryButtonClicked() {
    CategoryController::instance().onUiCategoryClicked(123);
}

// 2. Controller å±‚ï¼šå‘é€ Event
void CategoryController::handleCategoryRequest(int categoryId) {
    AppEvent ev;
    ev.type = EventType::EVENT_CATEGORY_CLICK;
    ev.arg1 = categoryId;
    EventQueue::instance().enqueue(ev);
}

// 3. EventDispatcherï¼šè·¯ç”±åˆ° Service
void EventDispatcher::dispatch(const AppEvent& ev) {
    switch (ev.type) {
        case EventType::EVENT_CATEGORY_CLICK:
            CategoryService::instance().onClick(ev.arg1);
            break;
    }
}

// 4. Service å±‚ï¼šä¸šåŠ¡é€»è¾‘ï¼Œå†³å®šæ˜¯å¦èµ°ç½‘ç»œ
void CategoryService::onClick(int categoryId) {
    if (cache_.find(categoryId) != cache_.end()) {
        // ç¼“å­˜å‘½ä¸­
        AppEvent ev;
        ev.type = EventType::EVENT_CATEGORY_DATA_READY;
        ev.arg1 = categoryId;
        ev.data = &cache_[categoryId];
        EventQueue::instance().enqueue(ev);
    } else {
        // ç¼“å­˜æœªå‘½ä¸­ï¼Œè§¦å‘ç½‘ç»œè¯·æ±‚
        NetworkService::instance().fetchCategory(categoryId);
    }
}

// 5. NetworkServiceï¼šç½‘ç»œè¯·æ±‚ï¼Œç»“æœé€šè¿‡ Event è¿”å›
void NetworkService::fetchCategory(int categoryId) {
    // libcurl è¯·æ±‚...
    // æˆåŠŸåå‘é€ Event
    AppEvent ev;
    ev.type = EventType::EVENT_CATEGORY_DATA_READY;
    ev.arg1 = categoryId;
    ev.data = parseCategoryJson(response.body);
    EventQueue::instance().enqueue(ev);
}

// 6. EventDispatcherï¼šè·¯ç”±åˆ° Controller
void EventDispatcher::dispatch(const AppEvent& ev) {
    switch (ev.type) {
        case EventType::EVENT_CATEGORY_DATA_READY:
            CategoryController::instance().onSvcCategoryDataReady(ev.arg1, ev.data);
            break;
    }
}

// 7. Controller å±‚ï¼šæ›´æ–° UI
void CategoryController::onSvcCategoryDataReady(int categoryId, void* data) {
    CategoryPage::instance().setLoading(false);
    CategoryPage::instance().updateCategoryList(data);
}
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [åº”ç”¨å±‚å‘½åè§„èŒƒï¼ˆæ¶æ„çº¦æŸç‰ˆï¼‰.md](./åº”ç”¨å±‚å‘½åè§„èŒƒï¼ˆæ¶æ„çº¦æŸç‰ˆï¼‰.md) â­â­â­ **å¿…è¯»**
- [äº‹ä»¶æ¨¡å‹MVPå®ç°æŒ‡å—ï¼ˆå¯è½åœ°ç‰ˆï¼‰.md](./äº‹ä»¶æ¨¡å‹MVPå®ç°æŒ‡å—ï¼ˆå¯è½åœ°ç‰ˆï¼‰.md) â­â­â­ **å¿…è¯»**
- [NetworkServiceä¸libcurlå®ç°æŒ‡å—ï¼ˆMVPå¯è½åœ°ç‰ˆï¼‰.md](./NetworkServiceä¸libcurlå®ç°æŒ‡å—ï¼ˆMVPå¯è½åœ°ç‰ˆï¼‰.md) â­â­â­ **å¿…è¯»**
- [Cursorå¼€å‘æŒ‡å—.md](../Cursorå¼€å‘æŒ‡å—.md) â­â­ **å‚è€ƒ**

---

**æœ€åæ›´æ–°**: 2025-12-30  
**çŠ¶æ€**: âœ… å®šç‰ˆï¼ˆå¯ç›´æ¥æ‹·è´ä½¿ç”¨ï¼‰  
**ç»´æŠ¤è€…**: Tech Product Owner



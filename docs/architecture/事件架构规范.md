# 事件架构规范

> **文档版本**：v1.0  
> **最后更新**：2025-12-30  
> **项目名称**：KTVLV  
> **目标平台**：全志 F133（ARM Cortex-A7）

---

## 📌 核心原则（一句话）

> **是的 — "事件 → 队列 → 所属线程消费" 是全项目的统一架构范式。**  
> 但注意：**不同域的事件，不一定共用同一个队列**，而是**共用同一种架构模式**。

**系统架构**：
```
统一事件机制（模型一致）
≠
统一事件容器（队列不混用）
```

---

## 🎯 全域事件架构图

```
          ┌─────────────┐
          │  UI Event   │  (UI专属队列)
          └─────▲────────┘
                │
   网络完成      │SDK回调                   UI操作
  JSON就绪       │播放事件                  点击/输入
        │        │                          │
        │        │                          │
        ▼        ▼                          ▼
[Network Thread]    [tplayer thread]   [UI Thread]
        │                │                  │
        └─────send──────┴───send───────────┘
                         │
                         ▼
                 UiEventQueue  ←───────────┐
                          │                │
                          ▼                │
                      UI 主线程消费       │
                                          │
                                          │
UI → Page操作 → Player命令 → PlayerCmdQueue
                       │
                       ▼
             PlayerThread 串行执行 → tplayer
```

📌 **架构统一**：事件 → 发出 → 入队 → 主体线程消费 → UI更新或状态改变  
📌 **队列细分**：防止不同域事件混淆/竞态

---

## 🧱 各类事件归属（必须记住）

| 事件来源 | 举例 | 去哪？ | 队列 | 消费线程 |
|---------|------|--------|------|---------|
| **UI输入事件** | 按钮点击、滑动、输入框 | 页面逻辑 or Player命令 | ❌ **不进队列**（直接处理） | UI线程 |
| **UI刷新/响应** | 播放开始、进度、错误提示 | 更新控件 | **UiEventQueue** | UI线程 |
| **网络事件** | JSON返回 / 错误 / 超时 | 更新业务逻辑→UI更新 | **UiEventQueue** | UI线程 |
| **播放器事件** | prepared/playing/ended | 驱动UI状态机 | **UiEventQueue** | UI线程 |
| **播放器控制命令** | play/pause/seek | 串行调用tplayer | **PlayerCmdQueue** | PlayerThread |

### 关键规则

✔️ **网络、播放器、业务 → 统一通过 UiEventQueue 回流UI**  
✔️ **UI → 播放器 → 统一通过 PlayerCmdQueue 调度**  
✔️ **UI控件本地行为 = 不用队列，直接处理**

---

## 🔥 架构基因理解

> **队列不是为了通信，而是为了隔离并发责任。**  
> 网络→UI 和 UI→播放器 的责任边界必须清晰，  
> 才能让"无锁业务"成为现实，而不是一句口号。

---

## 🕹️ 为什么 UI 不进队列？

因为UI事件→控件响应是**同步逻辑**：

- 点击按钮 → 页面变化
- 滚动列表 → 自身处理
- 焦点/交互 → LVGL内部事件系统

这些是**UI主线程职责，不应延后、不应排队、不应跨线程**，  
否则会导致：

- ❌ 卡顿
- ❌ UI状态延迟
- ❌ 点击误响应

UI的**异步部分**是：

> 来自外部系统的"响应事件" → 才通过队列回UI

这就是**输入-输出分离原则**。

---

## 🚨 注意：网络事件不是命令流

网络事件是**状态通知 → UI消费 → 拉起业务**

- ❌ 不应该直接推给播放器
- ❌ 不应该改播放器状态
- ✔️ 必须在UI线程决定如何响应

### 举例

```
网络json返回 → UiEventQueue → UI拿数据填页面
用户点播放 → UI发命令 → PlayerCmdQueue → 播放
```

边界分明，不乱套。

---

## 🧬 架构理解固化（给团队复述）

> 所有"跨线程的数据/状态变化 = Event"。  
> 所有"跨线程的行为控制 = Command"。  
> Event 回 UI  
> Command 去 PlayerThread  
> UI 本地行为不进队列  
> **→ 三种路径，概念永不混淆。**

---

## 📊 事件类型定义

### 1. UI事件（UiEventQueue）

```cpp
enum class UiEventType {
    // 网络事件
    NETWORK_SONG_LIST_READY,    // 歌曲列表就绪
    NETWORK_SEARCH_RESULT,      // 搜索结果
    NETWORK_ERROR,              // 网络错误
    
    // 播放器事件
    PLAYER_PREPARING,           // 准备中
    PLAYER_PLAYING,             // 播放中
    PLAYER_PAUSED,              // 已暂停
    PLAYER_STOPPED,             // 已停止
    PLAYER_COMPLETED,           // 播放完成
    PLAYER_ERROR,               // 播放错误
    PLAYER_PROGRESS,            // 播放进度更新
    
    // 业务事件
    HISTORY_UPDATED,            // 历史记录更新
    VIP_STATUS_CHANGED,         // VIP状态变化
};

struct UiEvent {
    UiEventType type;
    void* data;                 // 事件数据（预分配）
    size_t data_size;
};
```

### 2. 播放器命令（PlayerCmdQueue）

```cpp
enum class PlayerCmdType {
    PLAY,           // 播放/切歌
    PAUSE,          // 暂停
    RESUME,         // 继续
    REPLAY,         // 重唱
    SWITCH_TRACK,   // 切换音轨（原唱/伴奏）
    SET_VOLUME,     // 设置音量
    STOP,           // 停止
    EXIT            // 退出播放器
};

struct PlayerCmd {
    PlayerCmdType type;
    std::string url;    // PLAY用
    int value = 0;      // SET_VOLUME / SWITCH_TRACK 用
};
```

---

## 🔧 队列实现选型（统一使用 std::queue）

### PlayerCmdQueue（单生产者单消费者）

**选型**：`std::queue + std::mutex`

**原因**：
- ✅ 单消费者（PlayerThread）
- ✅ 命令频率不高
- ✅ 标准库，无需额外依赖
- ✅ 简单可靠

**实现**：
```cpp
class PlayerCmdQueue {
private:
    std::queue<PlayerCmd> queue_;
    std::mutex mutex_;
    std::condition_variable cv_;
};
```

### UiEventQueue（多生产者单消费者）

**选型**：`std::queue + std::mutex`（MVP阶段统一使用标准库）

**原因**：
- ✅ 多生产者（网络线程、播放器线程、SDK回调）
- ✅ 单消费者（UI线程）
- ✅ 标准库，无需额外依赖
- ✅ 简单可靠，MVP阶段性能足够
- ✅ 统一架构，降低复杂度

**注意**：
- ⚠️ 多生产者场景需要加锁保护
- ✅ **技术决策**：不使用无锁队列（moodycamel 系列），详见 [消息队列选型技术决策.md](../guides/消息队列选型技术决策.md)
- ✅ 当前MVP阶段，`std::queue + std::mutex` 完全够用

**实现**：
```cpp
class UiEventQueue {
private:
    std::queue<UiEvent> queue_;
    std::mutex mutex_;
};
```

### 技术决策

> **项目已明确决策：不使用无锁队列（moodycamel 系列）**  
> 详见 [消息队列选型技术决策.md](../guides/消息队列选型技术决策.md)

**历史参考**（已废弃）：
如果未来发现性能瓶颈，可以升级 UiEventQueue 到 `moodycamel::ConcurrentQueue`：
- 无需锁，性能更好
- 单头文件，易于集成
- 但当前MVP阶段不需要

---

## 📋 事件处理流程

### 1. 网络事件流程

```
网络线程
  ↓ HTTP请求完成
  ↓ 解析JSON
  ↓ 构造UiEvent
  ↓
UiEventQueue.enqueue(event)
  ↓
UI主线程（主循环）
  ↓ processEvents()
  ↓ 从队列取出事件
  ↓ 更新UI（填充列表、显示错误等）
```

### 2. 播放器事件流程

```
TPlayer SDK回调（tplayer内部线程）
  ↓ 播放状态变化
  ↓ 构造UiEvent
  ↓
UiEventQueue.enqueue(event)
  ↓
UI主线程（主循环）
  ↓ processEvents()
  ↓ 从队列取出事件
  ↓ 更新UI（播放按钮状态、进度条等）
```

### 3. 播放器命令流程

```
UI主线程
  ↓ 用户点击播放
  ↓ 构造PlayerCmd
  ↓
PlayerCmdQueue.enqueue(cmd)
  ↓
PlayerThread（播放器线程）
  ↓ 从队列取出命令
  ↓ 串行执行（调用TPlayer API）
  ↓ 执行结果 → 构造UiEvent → UiEventQueue
```

### 4. UI本地事件流程

```
UI主线程
  ↓ 用户点击按钮
  ↓ 直接处理（不经过队列）
  ↓ 更新页面状态
  ↓ 或发送PlayerCmd到PlayerCmdQueue
```

---

## 🚫 程序员禁令清单（业务不准做什么）

### ❌ 禁止事项

1. **禁止UI线程直接调用TPlayer API**
   - ❌ `TPlayerStart(player)` - 必须通过PlayerCmdQueue
   - ❌ `TPlayerPause(player)` - 必须通过PlayerCmdQueue

2. **禁止网络线程直接更新UI**
   - ❌ 在HTTP回调中直接修改LVGL控件
   - ❌ 在JSON解析后直接更新UI状态
   - ✅ 必须通过UiEventQueue

3. **禁止播放器线程直接更新UI**
   - ❌ 在TPlayer回调中直接修改LVGL控件
   - ✅ 必须通过UiEventQueue

4. **禁止跨线程访问共享状态**
   - ❌ 多个线程同时读写同一个变量
   - ✅ 所有状态变化通过事件队列

5. **禁止UI本地事件进队列**
   - ❌ 按钮点击事件进队列
   - ✅ 直接处理，或发送命令到PlayerCmdQueue

### ✅ 允许事项

1. **UI线程可以**：
   - ✅ 直接处理UI输入事件（点击、滑动等）
   - ✅ 发送PlayerCmd到PlayerCmdQueue
   - ✅ 从UiEventQueue消费事件并更新UI

2. **网络线程可以**：
   - ✅ 发送UiEvent到UiEventQueue

3. **播放器线程可以**：
   - ✅ 从PlayerCmdQueue消费命令
   - ✅ 发送UiEvent到UiEventQueue

---

## 📌 最终结论（可贴项目墙）

- ✅ **所有事件遵循同一个架构模型**
- ✅ **网络事件 ≠ 播放器事件 ≠ 控件事件**
- ✅ **但都经由同样的"事件→队列→主线程消费"原则**
- ✅ **队列是职责边界，而不是共享通道**

**回答**：

> **是架构一致**  
> **不是一个队列打天下**

---

## 📚 相关文档

- **线程与消息队列架构设计总稿**: [线程与消息队列架构设计总稿.md](./线程与消息队列架构设计总稿.md)
- **线程架构方案评估**: [线程架构方案评估.md](./线程架构方案评估.md)
- **线程与事件系统设计**: [线程与事件系统设计.md](../design/线程与事件系统设计.md)

---

## 🏷️ 标签

`#KTVLV` `#F133` `#事件架构` `#队列模型`  
`#UiEventQueue` `#PlayerCmdQueue` `#架构规范`  
`#无锁业务` `#职责边界`

---

**最后更新**: 2025-12-30


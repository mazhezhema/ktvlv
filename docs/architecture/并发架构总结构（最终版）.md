# KTVLV é¡¹ç›®å¹¶å‘æ€»ç»“æ„ï¼ˆæœ€ç»ˆç‰ˆï¼‰

> **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
> **æœ€åæ›´æ–°**ï¼š2025-12-30  
> **é¡¹ç›®åç§°**ï¼šKTVLV  
> **ç›®æ ‡å¹³å°**ï¼šå…¨å¿— F133ï¼ˆARM Cortex-A7ï¼‰  
> **çŠ¶æ€**ï¼šâœ… å®˜æ–¹æ¶æ„æ ‡å‡†ç­”æ¡ˆ

---

## ğŸ§µ çº¿ç¨‹æ•°é‡ï¼š4 ä¸ªï¼ˆå›ºå®šè§’è‰²ï¼‰

| çº¿ç¨‹ | èŒè´£ | ä¸ºä»€ä¹ˆå¿…é¡»å­˜åœ¨ | ä¸èƒ½åšä»€ä¹ˆ |
|------|------|---------------|-----------|
| **UI ä¸»çº¿ç¨‹** | LVGL æ¸²æŸ“ã€æ§ä»¶é€»è¾‘ã€UIæ›´æ–° | UI å¿…é¡»å•çº¿ç¨‹ | âŒ ä¸èƒ½è·¨çº¿ç¨‹æ›´æ–°UIï¼ŒâŒ ä¸èƒ½ç›´æ¥è°ƒtplayer |
| **æ’­æ”¾å™¨çº¿ç¨‹ï¼ˆstd::threadï¼‰** | ä¸²è¡Œæ‰§è¡Œæ‰€æœ‰æ’­æ”¾å™¨å‘½ä»¤ | ä¿è¯ tplayer çŠ¶æ€ä¸€è‡´æ€§ | âŒ ä¸èƒ½åšä¸šåŠ¡é€»è¾‘ï¼ŒâŒ ä¸èƒ½æ›´æ–°UI |
| **ç½‘ç»œçº¿ç¨‹ï¼ˆstd::asyncï¼‰** | HTTPè¯·æ±‚ & JSONè§£æ | é¿å…é˜»å¡UI | âŒ ä¸èƒ½ç›´æ¥æ›´æ–°UI |
| **SDKå†…éƒ¨çº¿ç¨‹ï¼ˆtplayerçº¿ç¨‹ï¼‰** | æ¥è‡ªSDKçš„å›è°ƒ | æˆ‘ä»¬æ— æ³•æ§åˆ¶æ¥æº | âŒ ä¸èƒ½ç›´æ¥è§¦UIã€ä¸èƒ½ç›´æ¥è§¦ä¸šåŠ¡çŠ¶æ€ |

ğŸ“Œ **æ³¨æ„**ï¼š
- æ’­æ”¾å™¨çº¿ç¨‹ = æˆ‘ä»¬è‡ªå·±åˆ›å»º
- SDKçº¿ç¨‹ = tplayerå†…éƒ¨è‡ªç„¶å­˜åœ¨ï¼Œä¸å¯æ§ï¼Œåªèƒ½è½¬å‘äº‹ä»¶

---

## ğŸ“© æ¶ˆæ¯é˜Ÿåˆ—æ•°é‡ï¼š2 ä¸ªï¼ˆä¸å¤šä¸å°‘åˆšå¥½ï¼‰

| é˜Ÿåˆ— | æµå‘ | è°å†™ â†’ è°è¯» | å®ç°æ–¹å¼ | ä½œç”¨ |
|------|------|-----------|---------|------|
| **PlayerCmdQueue** | UI/ä¸šåŠ¡ â†’ æ’­æ”¾å™¨ | UI & ç½‘ç»œ â†’ PlayerThread | `std::queue + mutexï¼ˆå¯¹å¤–é€æ˜ï¼‰` | ä¸²è¡ŒåŒ–æ‰€æœ‰æ’­æ”¾å™¨æ“ä½œ |
| **UiEventQueue** | æ’­æ”¾å™¨/ç½‘ç»œ/SDK â†’ UI | PlayerThread & ç½‘ç»œ â†’ UIçº¿ç¨‹ | `std::queue + mutexï¼ˆå¯¹å¤–é€æ˜ï¼‰` | æŠŠåå°äº‹ä»¶å›ä¸»çº¿ç¨‹æ›´æ–°UI |

ğŸ“Œ **å…¨é¡¹ç›®åªæœ‰è¿™ 2 ä¸ªé˜Ÿåˆ—**  
ğŸ“Œ **ç»ä¸æ–°å¢ç¬¬ä¸‰ç¬¬å››ä¸ªï¼ˆMVPé˜¶æ®µï¼‰**

---

## ğŸ§± æ¶æ„æµå‘æ€»å›¾ï¼ˆè´´å¢™çº§åˆ«ï¼‰

```
ğŸ’¡Command Down / Event Up â€”â€” æ ¸å¿ƒè§„åˆ™

 UIç‚¹å‡»/ä¸šåŠ¡éœ€æ±‚        SDK/Networkå›è°ƒ
        â”‚                         â–²
        â”‚                         â”‚
        â–¼                         â”‚
 PlayerCmdQueue  (<--- commands)  â”‚
        â”‚                         â”‚
        â–¼                         â”‚
  ğŸ§ PlayerThread (std::thread)   â”‚
        â”‚    è°ƒç”¨tplayer_*( )     â”‚
        â–¼                         â”‚
    tplayerå†…éƒ¨SDKçº¿ç¨‹            â”‚
        â”‚      å›è°ƒè¿”å›           â”‚
        â–¼                         â”‚
         UiEventQueue  (events) --â”˜
                â”‚
                â–¼
         ğŸ–¥ï¸ UI ä¸»çº¿ç¨‹ (lvgl + UiDispatcher)
```

ğŸ“Œ **ä¸€å¥è¯ç†è§£æ¶æ„åŸºå› **ï¼š

> **UI å‘æŒ‡ä»¤ï¼ˆCommandï¼‰å¾€ä¸‹èµ° â†’ æ’­æ”¾å™¨æ‰§è¡Œ  
> åå°äº‹ä»¶ï¼ˆEventï¼‰å¾€ä¸Šèµ° â†’ UI æ¶ˆè´¹ & æ›´æ–°**

---

## ğŸ§© å¯¹åº”çš„ä»£ç å®ç°æ–¹å‘ï¼ˆCursor å…³é”®æç¤ºï¼‰

### 1ï¸âƒ£ PlayerCmdQueue

* å¤šç”Ÿäº§è€…ï¼ˆUI/ç½‘ç»œï¼‰ã€å•æ¶ˆè´¹è€…ï¼ˆæ’­æ”¾å™¨çº¿ç¨‹ï¼‰
* ç”¨ `std::queue< PlayerCmd >`
* å†…éƒ¨ç”¨ `std::mutex` ä¸Šé”ï¼ˆ**ä¸æš´éœ²ç»™ä¸šåŠ¡**ï¼‰

**Cursoræç¤º**ï¼š
```
Implement PlayerCmdQueue using std::queue<PlayerCmd>.
Provide methods: enqueue(cmd) from any thread, dequeue() from PlayerThread only.
Internally hide locking; never expose mutex to business logic.
```

**æ’­æ”¾å™¨çº¿ç¨‹ä¸»å¾ªç¯**ï¼š
```cpp
while (running) {
    auto cmd = cmdQueue.dequeueBlocking(); // or try + sleep
    handleCommand(cmd); // PLAY/PAUSE/REPLAY...
}
```

### 2ï¸âƒ£ UiEventQueue

* æ‰€æœ‰åå°çº¿ç¨‹å†™å…¥äº‹ä»¶
* UI ä¸»çº¿ç¨‹é€šè¿‡ UiDispatcher æ¶ˆè´¹

**Cursoræç¤º**ï¼š
```
Implement UiEventQueue as std::queue<PlayerEvent>.
UI thread periodically calls drain() inside UiDispatcher::post().
Never update LVGL widgets outside UiDispatcher.
```

**UI ä¾§æ¶ˆè´¹**ï¼š
```cpp
UiDispatcher::post([&](){
    uiEventQueue.drain([](const PlayerEvent& ev){
        PagePlayer::onEvent(ev);
    });
});
```

---

## ğŸ§± æ¯ç§äº‹ä»¶å¦‚ä½•è¿›é˜Ÿåˆ—ï¼Ÿ

| æ¥æº | ç¤ºä¾‹ | å†™å…¥é˜Ÿåˆ— | è¯´æ˜ |
|------|------|---------|------|
| UIæ“ä½œ | æ’­æ”¾æŒ‰é’®ç‚¹å‡» | PlayerCmdQueue | å‘å‘½ä»¤ï¼Œä¸æ›´æ–°UI |
| ç½‘ç»œå®Œæˆ | JSONè¿”å› | UiEventQueue | æœ€åUIæ›´æ–°é¡µé¢ |
| æ’­æ”¾å™¨SDKå›è°ƒ | playing/ended | UiEventQueue | ç¿»è¯‘æˆPlayerEvent |
| æ’­æ”¾å™¨æ§åˆ¶ | play/seek/exit | PlayerCmdQueue | ä¸²è¡ŒåŒ–æ‰§è¡Œ |

---

## ğŸ§¨ ç¦æ­¢åšçš„äº‹ï¼ˆç»™ Cursor / å›¢é˜Ÿçš„é˜²è¸©å‘è§„åˆ™ï¼‰

> **è¿™äº›æ˜¯ Cursor å¿…é¡»éµå®ˆçš„ç¡¬è§„åˆ™ï¼š**

âŒ UI çº¿ç¨‹ç¦æ­¢ç›´æ¥è°ƒç”¨ `tplayer_*()`  
âŒ æ’­æ”¾å™¨çº¿ç¨‹ç¦æ­¢ç›´æ¥è°ƒç”¨ UI æˆ–æ§ä»¶  
âŒ SDKå›è°ƒç¦æ­¢è·¨çº¿ç¨‹æ›´æ–°UI  
âŒ é˜Ÿåˆ—å¯¹è±¡ç¦æ­¢è¢«æš´éœ²ç»™ä¸šåŠ¡å±‚  
âŒ ä¸èƒ½åˆ›å»ºç¬¬ä¸‰ä¸ªæ¶ˆæ¯é˜Ÿåˆ—

**åªæœ‰ä¸¤æ¡è·¯å¾„ï¼š**

```
Command â†’ PlayerCmdQueue â†’ PlayerThread
Event   â†’ UiEventQueue    â†’ UIThread
```

---

## ğŸ¯ å¯ä»¥ç»™ Cursor çš„æ€» Promptï¼ˆå¤åˆ¶ç²˜è´´ç”¨ï¼‰

```
We are implementing a concurrency architecture for an LVGL + tplayer project:

- 4 threads: UI (main), PlayerThread (std::thread), Network (std::async), SDK internal thread.
- 2 message queues only:
   1. PlayerCmdQueue : UI/Network -> PlayerThread (commands)
   2. UiEventQueue   : SDK/PlayerThread/Network -> UI (events)

Rules:
- Command Down, Event Up
- UI never calls tplayer directly
- tplayer callbacks always push events to UiEventQueue, then UiDispatcher::post() to return to UI thread
- std::queue + mutex inside, no lock exposed to business layer
- No moodycamel, no boost, no raw pthread for business
- No direct cross-thread widget updates

Implement:
- PlayerCmdQueue { enqueue/can block, consumed by PlayerThread loop }
- UiEventQueue { push/drain, consumed via UiDispatcher::post }
- PlayerAdapter that translates commands to tplayer_*()
- Translate SDK callbacks to PlayerEvent and push into UiEventQueue

Primary patterns:
- Single Consumer Queue
- Event Driven
- Zero Shared State for business logic
```

---

## ğŸ“Š å‘½ä»¤å’Œäº‹ä»¶å®šä¹‰

### PlayerCmdï¼ˆæ’­æ”¾å™¨å‘½ä»¤ï¼‰

```cpp
enum class PlayerCmdType {
    PLAY,           // æ’­æ”¾/åˆ‡æ­Œ
    PAUSE,          // æš‚åœ
    RESUME,         // ç»§ç»­
    REPLAY,         // é‡å”±
    SWITCH_TRACK,   // åˆ‡æ¢éŸ³è½¨ï¼ˆåŸå”±/ä¼´å¥ï¼‰
    SET_VOLUME,     // è®¾ç½®éŸ³é‡
    STOP,           // åœæ­¢
    EXIT            // é€€å‡ºæ’­æ”¾å™¨
};

struct PlayerCmd {
    PlayerCmdType type;
    std::string url;    // PLAYç”¨
    int value = 0;      // SET_VOLUME / SWITCH_TRACK ç”¨
};
```

### PlayerEventï¼ˆæ’­æ”¾å™¨äº‹ä»¶ï¼‰

```cpp
enum class PlayerEventType {
    PREPARING,      // å‡†å¤‡ä¸­
    PLAYING,        // æ’­æ”¾ä¸­
    PAUSED,         // å·²æš‚åœ
    STOPPED,        // å·²åœæ­¢
    COMPLETED,      // æ’­æ”¾å®Œæˆ
    ERROR           // é”™è¯¯
};

struct PlayerEvent {
    PlayerEventType type;
    int progress_ms;    // æ’­æ”¾è¿›åº¦ï¼ˆæ¯«ç§’ï¼‰
    int error_code;     // é”™è¯¯ç ï¼ˆå¦‚æœæœ‰ï¼‰
    std::string error_msg;  // é”™è¯¯ä¿¡æ¯
};
```

---

## ğŸ”§ é˜Ÿåˆ—å®ç°è§„èŒƒ

### PlayerCmdQueue å®ç°

```cpp
class PlayerCmdQueue {
public:
    // å…¥é˜Ÿï¼ˆå¤šç”Ÿäº§è€…ï¼Œå¯ä»ä»»ä½•çº¿ç¨‹è°ƒç”¨ï¼‰
    void enqueue(const PlayerCmd& cmd);
    
    // å‡ºé˜Ÿï¼ˆå•æ¶ˆè´¹è€…ï¼Œä»…PlayerThreadè°ƒç”¨ï¼‰
    bool dequeue(PlayerCmd& cmd);  // éé˜»å¡
    void dequeueBlocking(PlayerCmd& cmd);  // é˜»å¡ç­‰å¾…
    
    // æ£€æŸ¥é˜Ÿåˆ—çŠ¶æ€
    bool empty() const;
    size_t size() const;
    
private:
    std::queue<PlayerCmd> queue_;
    mutable std::mutex mutex_;
    std::condition_variable cv_;
};
```

### UiEventQueue å®ç°

```cpp
class UiEventQueue {
public:
    // å…¥é˜Ÿï¼ˆå¤šç”Ÿäº§è€…ï¼Œå¯ä»ä»»ä½•çº¿ç¨‹è°ƒç”¨ï¼‰
    void push(const PlayerEvent& event);
    
    // æ‰¹é‡æ¶ˆè´¹ï¼ˆå•æ¶ˆè´¹è€…ï¼Œä»…UIçº¿ç¨‹è°ƒç”¨ï¼‰
    void drain(std::function<void(const PlayerEvent&)> handler);
    
    // æ£€æŸ¥é˜Ÿåˆ—çŠ¶æ€
    bool empty() const;
    size_t size() const;
    
private:
    std::queue<PlayerEvent> queue_;
    mutable std::mutex mutex_;
};
```

---

## ğŸ æœ€ç»ˆä¸€å¥è¯ï¼ˆä½ å¯ä»¥è®²ç»™ä»»ä½•äººï¼‰

> **KT VLV é¡¹ç›®é‡‡ç”¨ 4 çº¿ç¨‹ + 2 é˜Ÿåˆ—ï¼Œ  
> Command Down â†’ PlayerThread ä¸²è¡Œè°ƒåº¦æ’­æ”¾å™¨ï¼Œ  
> Event Up â†’ UiDispatcher å›ä¸»çº¿ç¨‹æ›´æ–° UIï¼Œ  
> ä¸šåŠ¡å±‚å…¨ç¨‹æ— é”ã€‚**

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- **äº‹ä»¶æ¶æ„è§„èŒƒ**: [äº‹ä»¶æ¶æ„è§„èŒƒ.md](./äº‹ä»¶æ¶æ„è§„èŒƒ.md)
- **çº¿ç¨‹æ¶æ„åŸºçº¿**: [çº¿ç¨‹æ¶æ„åŸºçº¿ï¼ˆæœ€ç»ˆç‰ˆï¼‰.md](../çº¿ç¨‹æ¶æ„åŸºçº¿ï¼ˆæœ€ç»ˆç‰ˆï¼‰.md)
- **æ¶ˆæ¯é˜Ÿåˆ—å®Œæ•´æŒ‡å—**: [æ¶ˆæ¯é˜Ÿåˆ—å®Œæ•´æŒ‡å—.md](../æ¶ˆæ¯é˜Ÿåˆ—å®Œæ•´æŒ‡å—.md)

---

## ğŸ·ï¸ æ ‡ç­¾

`#KTVLV` `#F133` `#å¹¶å‘æ¶æ„` `#çº¿ç¨‹è®¾è®¡` `#æ¶ˆæ¯é˜Ÿåˆ—`  
`#CommandDown` `#EventUp` `#æ— é”ä¸šåŠ¡` `#æ¶æ„æ ‡å‡†ç­”æ¡ˆ`

---

**æœ€åæ›´æ–°**: 2025-12-30  
**çŠ¶æ€**: âœ… å®˜æ–¹æ¶æ„æ ‡å‡†ç­”æ¡ˆï¼Œå¯ç›´æ¥ä½¿ç”¨




# 异常态处理总则

> **文档版本**：v1.0  
> **最后更新**：2025-12-30  
> **状态**：✅ 核心文档（架构设计）  
> **适用平台**：F133 / Tina Linux  
> **目标**：定义异常态统一处理原则，确保系统在异常情况下的稳定性和可恢复性

---

## 🎯 核心原则（一句话）

> **模块自愈优先，模块不可恢复 → 通知 AppRuntime，AppRuntime 决定：重启模块 / 重启 App。**

---

## 📋 目录

1. [异常态分类](#一-异常态分类)
2. [处理原则](#二-处理原则)
3. [异常处理流程](#三-异常处理流程)
4. [常见异常场景](#四-常见异常场景)
5. [实现示例](#五-实现示例)

---

## 一、异常态分类

### 异常类型

| 异常类型 | 严重程度 | 影响范围 | 处理策略 |
|---------|---------|---------|---------|
| **网络异常** | ⚠️ 中等 | 网络模块 | 模块自愈（重试、指数退避） |
| **播放卡死** | 🔴 高 | 播放器模块 | 模块重启（最多3次） |
| **UI假死** | 🔴 高 | UI模块 | App重启 |
| **升级失败** | ⚠️ 中等 | 升级模块 | 回滚策略 |
| **内存不足** | 🔴 高 | 全局 | App重启 |
| **线程异常退出** | 🔴 高 | 对应模块 | 模块重启（最多5次/小时） |

---

## 二、处理原则

### 核心原则

1. **模块自愈优先**
   - 模块内部处理异常，尝试恢复
   - 使用重试、指数退避等策略
   - 不立即上报 AppRuntime

2. **模块不可恢复 → 通知 AppRuntime**
   - 模块自愈失败后，通知 AppRuntime
   - 提供异常类型、错误码、错误信息
   - 不自行决定是否重启

3. **AppRuntime 决定：重启模块 / 重启 App**
   - 根据异常类型和严重程度决定处理策略
   - 记录异常日志，便于后续分析
   - 执行重启或回滚操作

### 处理策略表

| 异常类型 | 模块自愈策略 | 模块不可恢复后 | AppRuntime 决策 |
|---------|------------|--------------|---------------|
| **网络异常** | 重试（最多5次，指数退避） | 通知 AppRuntime | 重启 NetworkWorker（最多5次/小时） |
| **播放卡死** | 超时检测（30秒） | 通知 AppRuntime | 重启 PlayerAdapter（最多3次/播放） |
| **UI假死** | 心跳检测（5秒） | 通知 AppRuntime | 重启 App |
| **升级失败** | 重试（最多3次） | 通知 AppRuntime | 回滚到上一版本 |
| **内存不足** | 清理缓存 | 通知 AppRuntime | 重启 App |
| **线程异常退出** | 自动重启（最多5次/小时） | 通知 AppRuntime | 记录日志，继续监控 |

---

## 三、异常处理流程

### 标准流程

```
异常发生
    ↓
模块内部处理（自愈）
    ↓
自愈成功？ ──是──→ 继续运行
    ↓ 否
通知 AppRuntime（异常类型、错误码、错误信息）
    ↓
AppRuntime 决策
    ↓
重启模块？ ──是──→ 重启模块（记录日志）
    ↓ 否
重启 App？ ──是──→ 重启 App（记录日志）
    ↓ 否
记录日志，继续监控
```

### 代码示例

```cpp
class NetworkWorker {
private:
    void handleHttpRequest(const HttpRequest& req) {
        int retry_count = 0;
        const int max_retries = 5;
        
        while (retry_count < max_retries) {
            try {
                // 执行 HTTP 请求
                auto response = performHttpRequest(req);
                
                // 成功，返回
                return response;
                
            } catch (const NetworkException& e) {
                retry_count++;
                
                // 模块自愈：指数退避
                int delay_ms = 1000 * (1 << retry_count);  // 1s, 2s, 4s, 8s, 16s
                std::this_thread::sleep_for(std::chrono::milliseconds(delay_ms));
                
                syslog(LOG_WARNING, "[ktv][network] HTTP request failed, retry %d/%d: %s",
                       retry_count, max_retries, e.what());
            }
        }
        
        // 模块自愈失败，通知 AppRuntime
        syslog(LOG_ERR, "[ktv][network] HTTP request failed after %d retries", max_retries);
        
        AppRuntime::instance().reportException(
            ExceptionType::NETWORK_FAILURE,
            ErrorCode::HTTP_REQUEST_FAILED,
            "Network request failed after max retries"
        );
    }
};

class AppRuntime {
public:
    /**
     * @brief 报告异常（由模块调用）
     */
    void reportException(ExceptionType type, ErrorCode code, const std::string& message) {
        syslog(LOG_ERR, "[ktv][runtime] Exception reported: type=%d, code=%d, msg=%s",
               static_cast<int>(type), static_cast<int>(code), message.c_str());
        
        // 记录异常日志
        logException(type, code, message);
        
        // 根据异常类型决策
        switch (type) {
            case ExceptionType::NETWORK_FAILURE:
                handleNetworkFailure(code, message);
                break;
            case ExceptionType::PLAYER_HANG:
                handlePlayerHang(code, message);
                break;
            case ExceptionType::UI_HANG:
                handleUIHang(code, message);
                break;
            case ExceptionType::UPGRADE_FAILURE:
                handleUpgradeFailure(code, message);
                break;
            case ExceptionType::OUT_OF_MEMORY:
                handleOutOfMemory(code, message);
                break;
            default:
                syslog(LOG_WARNING, "[ktv][runtime] Unknown exception type: %d", static_cast<int>(type));
        }
    }

private:
    void handleNetworkFailure(ErrorCode code, const std::string& message) {
        static int restart_count = 0;
        const int max_restarts = 5;
        
        if (restart_count < max_restarts) {
            restart_count++;
            syslog(LOG_WARNING, "[ktv][runtime] Restarting NetworkWorker (%d/%d)", restart_count, max_restarts);
            
            NetworkWorker::instance().stop();
            std::this_thread::sleep_for(std::chrono::seconds(3));
            NetworkWorker::instance().start();
        } else {
            syslog(LOG_ERR, "[ktv][runtime] NetworkWorker restart limit reached, restarting App");
            restartApp();
        }
    }
    
    void handlePlayerHang(ErrorCode code, const std::string& message) {
        static int restart_count = 0;
        const int max_restarts = 3;
        
        if (restart_count < max_restarts) {
            restart_count++;
            syslog(LOG_WARNING, "[ktv][runtime] Restarting PlayerAdapter (%d/%d)", restart_count, max_restarts);
            
            PlayerAdapter::instance().stop();
            PlayerAdapter::instance().start();
        } else {
            syslog(LOG_ERR, "[ktv][runtime] PlayerAdapter restart limit reached, restarting App");
            restartApp();
        }
    }
    
    void handleUIHang(ErrorCode code, const std::string& message) {
        syslog(LOG_ERR, "[ktv][runtime] UI hang detected, restarting App");
        restartApp();
    }
    
    void handleUpgradeFailure(ErrorCode code, const std::string& message) {
        syslog(LOG_ERR, "[ktv][runtime] Upgrade failure, rolling back");
        rollbackUpgrade();
    }
    
    void handleOutOfMemory(ErrorCode code, const std::string& message) {
        syslog(LOG_ERR, "[ktv][runtime] Out of memory, restarting App");
        restartApp();
    }
    
    void restartApp() {
        syslog(LOG_ERR, "[ktv][runtime] Restarting App...");
        stopAll();
        // 由 systemd 或外部脚本负责重启
        exit(1);
    }
    
    void rollbackUpgrade() {
        syslog(LOG_ERR, "[ktv][runtime] Rolling back upgrade...");
        // 执行回滚逻辑
    }
};
```

---

## 四、常见异常场景

### 1. 网络异常

**场景**：HTTP 请求失败、WebSocket 断开

**模块自愈策略**：
- 重试（最多5次）
- 指数退避（1s, 2s, 4s, 8s, 16s）
- 检查网络连接状态

**模块不可恢复后**：
- 通知 AppRuntime
- AppRuntime 重启 NetworkWorker（最多5次/小时）

### 2. 播放卡死

**场景**：TPlayer 无响应、播放进度不更新

**模块自愈策略**：
- 超时检测（30秒无进度更新）
- 尝试停止并重新播放

**模块不可恢复后**：
- 通知 AppRuntime
- AppRuntime 重启 PlayerAdapter（最多3次/播放）

### 3. UI假死

**场景**：UI 无响应、触摸无反应

**模块自愈策略**：
- 心跳检测（5秒无响应）
- 尝试刷新 UI

**模块不可恢复后**：
- 通知 AppRuntime
- AppRuntime 重启 App

### 4. 升级失败

**场景**：升级包下载失败、升级后启动失败

**模块自愈策略**：
- 重试下载（最多3次）
- 验证升级包完整性

**模块不可恢复后**：
- 通知 AppRuntime
- AppRuntime 执行回滚策略

### 5. 内存不足

**场景**：内存分配失败、系统内存不足

**模块自愈策略**：
- 清理缓存
- 释放非关键资源

**模块不可恢复后**：
- 通知 AppRuntime
- AppRuntime 重启 App

---

## 五、实现示例

### 异常类型定义

```cpp
enum class ExceptionType {
    NETWORK_FAILURE,      // 网络异常
    PLAYER_HANG,          // 播放卡死
    UI_HANG,              // UI假死
    UPGRADE_FAILURE,      // 升级失败
    OUT_OF_MEMORY,        // 内存不足
    THREAD_EXIT           // 线程异常退出
};

enum class ErrorCode {
    HTTP_REQUEST_FAILED,
    WEBSOCKET_DISCONNECTED,
    PLAYER_TIMEOUT,
    UI_NO_RESPONSE,
    UPGRADE_DOWNLOAD_FAILED,
    UPGRADE_START_FAILED,
    MEMORY_ALLOC_FAILED,
    THREAD_CRASHED
};
```

### 异常日志记录

```cpp
void AppRuntime::logException(ExceptionType type, ErrorCode code, const std::string& message) {
    // 记录到 syslog
    syslog(LOG_ERR, "[ktv][exception] type=%d, code=%d, msg=%s",
           static_cast<int>(type), static_cast<int>(code), message.c_str());
    
    // 记录到内存缓冲区（用于远程上传）
    ExceptionLog log;
    log.timestamp = std::time(nullptr);
    log.type = type;
    log.code = code;
    log.message = message;
    
    exception_logs_.push_back(log);
    
    // 如果缓冲区满了，触发日志上传
    if (exception_logs_.size() >= 100) {
        LogUploadService::instance().uploadExceptionLogs(exception_logs_);
        exception_logs_.clear();
    }
}
```

---

## 六、关键规则（必须遵守）

### 🚫 禁止事项

1. **禁止模块自行决定是否重启**
   - ❌ 禁止模块内部直接调用 `restartApp()`
   - ✅ 必须通过 `AppRuntime::reportException()` 上报

2. **禁止忽略异常**
   - ❌ 禁止捕获异常后不处理
   - ✅ 必须尝试自愈或上报 AppRuntime

3. **禁止无限重试**
   - ❌ 禁止无限制的重试
   - ✅ 必须设置最大重试次数和超时时间

---

## 📚 相关文档

- [AppRuntime线程生命周期总控设计.md](./AppRuntime线程生命周期总控设计.md)
- [KTV_App稳定性与自愈设计说明.md](../sdk/KTV_App稳定性与自愈设计说明.md)
- [线程架构基线（最终版）.md](../线程架构基线（最终版）.md)

---

**最后更新**: 2025-12-30  
**维护者**: 项目团队  
**状态**: ✅ 核心文档（架构设计）


# 资源管理规范 v1.0

> **文档版本**：v1.0  
> **最后更新**：2025-12-30  
> **状态**：✅ 核心文档  
> **适用对象**：所有开发工程师  
> **相关文档**：详见 [团队开发规范v1.md](./团队开发规范v1.md)

---

## 📌 核心总原则（可贴墙）

| 目标 | 准则 |
|------|------|
| **避免泄漏** | **所有资源 Singleton**（或按需池化，但 MVP 不用池） |
| **避免碎片** | UI 控件 **禁止频繁创建/删除** |
| **避免跨线程事故** | cross-thread 操作**统一事件队列** |
| **避免生命周期混乱** | 生命周期 = **App 全局**，手动释放**禁止** |
| **避免底层心智负担** | 工程师不写 `delete/free/lv_obj_del/new` |

> **能持久就持久，能隐藏不销毁，能复用就复用。**

---

## 🧱 资源清单：全面 Singleton 表

| 资源类型 | 单例类/组件 | 创建时机 | 生命周期 | 替代行为 |
|---------|-----------|---------|---------|---------|
| **播放器 SDK** | `PlayerService` | App启动 | 全局唯一 | 禁直接调tplayer |
| **WebSocket** | `WebSocketService` | 进入点歌房间前 | 全局唯一/可重连 | 用 connect()/disconnect() |
| **HTTP客户端** | `HttpService` | App启动 | 全局唯一 | 复用连接 |
| **缓存管理** | `CacheService` | App启动 | 全局唯一 | 避免重复落盘 |
| **日志系统** | `Logger` | App启动 | 全局唯一 | 不允许多init |
| **事件总线** | `UiEventBus` | App启动 | 全局唯一 | 控制UI安全调用 |
| **根页面容器** | `AppUIRoot` | LVGL init后 | 全局唯一 | 页面挂载 |
| **页面（每个Page）** | `PageXxx` | 首次进入时 | 保持不销毁 | show()/hide() 切换 |
| **控件容器** | `XxxView` | 页面构建时 | 保持不销毁 | update()/reset() |
| **线程/队列** | 内置在 Service | Service 初始化时 | 稳定运行到退出 | 不让业务操作 |
| **下载缓冲区** | DownloadBuffer | 首次curl时 | 可全局复用 | 限定上限/防碎片 |
| **JSON工厂** | JsonUtil | 纯静态工具 | --- | 用后释放局部对象，不缓存 |
| **LVGL style/theme** | UITheme | App启动初始化一次 | 全局唯一 | 不多实例维护样式 |

---

## 🖼️ UI 处理策略（必守）

### ❌ 错误写法（会导致泄漏 + 碎片）

```cpp
void showSearchPage() {
    lv_obj_t* page = lv_obj_create(lv_scr_act());  // ❌ 每次调用都创建
    lv_obj_t* label = lv_label_create(page);       // ❌ 每次调用都创建
    // 离开页面时忘记删除 → 内存泄漏
}
```

### ✅ 正确写法（单例控件树 + 隐藏/显示）

```cpp
// SearchPage.h
#pragma once
#include "ui/BasePage.h"

class SearchPage : public BasePage {
public:
    static SearchPage& instance();
    
    void show() override;
    void hide() override;
    void update(const SearchData& data);
    
private:
    SearchPage();  // 私有构造函数，确保单例
    
    lv_obj_t* m_label = nullptr;
    lv_obj_t* m_list = nullptr;
    
    void buildUI();  // 只调用一次
};

// SearchPage.cpp
SearchPage::SearchPage() {
    root = lv_obj_create(lv_scr_act());
    buildUI();
    lv_obj_add_flag(root, LV_OBJ_FLAG_HIDDEN);  // 初始隐藏
}

SearchPage& SearchPage::instance() {
    static SearchPage inst;
    return inst;
}

void SearchPage::buildUI() {
    // 只创建一次，不再销毁
    m_label = lv_label_create(root);
    m_list = lv_list_create(root);
    // ... 其他控件
}

void SearchPage::show() {
    lv_obj_clear_flag(root, LV_OBJ_FLAG_HIDDEN);
}

void SearchPage::hide() {
    lv_obj_add_flag(root, LV_OBJ_FLAG_HIDDEN);
}

void SearchPage::update(const SearchData& data) {
    // 操作已有控件更新文本/列表，不创建新控件
    lv_label_set_text(m_label, data.keyword.c_str());
    // ... 更新列表内容
}
```

**使用方式**：

```cpp
// 显示页面
SearchPage::instance().show();

// 更新数据
SearchPage::instance().update(searchData);

// 隐藏页面
SearchPage::instance().hide();
```

> **关键**：**控件只创建一次 → 再也不创建/销毁。**  
> **数据更新靠 `update()`，界面切换靠 `show()/hide()`。**

---

## 🧱 控件复用原则（避免垃圾堆）

| 控件类型 | 如何复用 |
|---------|---------|
| **列表 List** | 固定创建子项池，更新文本/图片，禁止重复 create/delete |
| **图片** | 全局 image cache（必要时），避免频繁 decode |
| **弹窗** | 全局1-2个弹窗实例，动态更新内容再 show() |
| **按钮** | 行为变化靠绑定数据，而非重造按钮 |
| **字体/样式** | 全局唯一 theme，禁止每页 new 一个 style |

---

## 🔁 页内控件池（List最佳实践示例）

```cpp
// SongListView.h
class SongListView {
private:
    static constexpr int POOL_SIZE = 50;  // 固定池大小
    lv_obj_t* m_itemPool[POOL_SIZE] = {nullptr};
    lv_obj_t* m_root = nullptr;
    
public:
    SongListView(lv_obj_t* parent) {
        m_root = lv_obj_create(parent);
        buildItemPool();
    }
    
    void buildItemPool() {
        // 预创建固定数量项
        for(int i = 0; i < POOL_SIZE; i++) {
            m_itemPool[i] = lv_list_add_btn(m_root, NULL, "");
            lv_obj_add_flag(m_itemPool[i], LV_OBJ_FLAG_HIDDEN);
        }
    }
    
    // 更新内容显示
    void updateList(const std::vector<Song>& songs) {
        for(int i = 0; i < POOL_SIZE; i++) {
            if(i < songs.size()) {
                // 复用已有控件，更新内容
                setItemContent(m_itemPool[i], songs[i]);
                lv_obj_clear_flag(m_itemPool[i], LV_OBJ_FLAG_HIDDEN);
            } else {
                // 隐藏多余的项
                lv_obj_add_flag(m_itemPool[i], LV_OBJ_FLAG_HIDDEN);
            }
        }
    }
    
private:
    void setItemContent(lv_obj_t* item, const Song& song) {
        lv_list_set_btn_text(item, song.title.c_str());
        // 更新图标等其他内容
    }
};
```

> **适合弱设备**：**无频繁创建/销毁 UI 对象 → 稳定 + 无抖动**

---

## 🎬 线程/服务初始化流程（生命周期图）

```
AppStart
  ↓  (init LVGL / render root)
AppContext::instance()
  ↓
Logger::instance().init()
  ↓
PlayerService::instance().init()
  ↓
HttpService::instance().init()
  ↓
CacheService::instance().scanExistingCache()
  ↓
WebSocketService::instance().idle()
  ↓
UIRoot::instance().show(HomePage)
```

**退出时**：

```
AppExit
  ↓
只允许 graceful shutdown，不允许手动释放控件或delete
```

---

## ❌ 禁止 & ⚠️ 警告区（必须强调给团队）

### ❌ 禁止出现的关键词

在业务层代码中，**严格禁止**使用以下关键词：

- ❌ `new` - 必须使用 Singleton
- ❌ `delete` - 资源生命周期 = App生命周期
- ❌ `free` - 使用栈对象或Singleton
- ❌ `lv_obj_del` - 使用 show()/hide() 代替
- ❌ `pthread_create` - 使用 Service 内置线程
- ❌ `curl_easy_cleanup` 在业务层 - 使用 HttpService
- ❌ `tplayer_stop` 直接调用 - 必须走 PlayerService

### ⚠️ 危险使用场景（自动触发代码审查）

| 发现行为 | 说明 | 处理方式 |
|---------|------|---------|
| **每次操作新建页面** | 立即驳回：必须单例化 | 改为 `PageXxx::instance().show()` |
| **循环内创建控件** | 立即驳回：必须预创建 | 改为控件池 + update() |
| **UI线程阻塞网络请求** | 严重问题：必须走 HttpService | 改为异步调用 |
| **播放控制不走 PlayerCmdQueue** | 立即驳回：直接破坏并发模型 | 改为 `PlayerService::instance().play()` |
| **页面退出时 delete 控件** | 立即驳回：必须隐藏不销毁 | 改为 `hide()` |
| **Service 中直接 new** | 立即驳回：Service 必须是 Singleton | 改为静态实例 |

---

## 🧠 记忆口诀（给团队背）

> **能 hidden 就不 delete**  
> **能 update 就不 recreate**  
> **能单例就不 new**  
> **能持久就不释放**  
> **能抽象就不上底层**

---

## 💡 这个项目的灵魂

> **KT-VLV 是"常驻内存型应用"，不是"释放式动态应用"。**

所有资源在应用启动时创建，运行期间保持不变，应用退出时系统自动回收。

---

## 📋 代码审查 Checklist

### ✅ 必须检查项

- [ ] 所有 Service 是否使用 Singleton 模式？
- [ ] 所有 Page 是否使用 Singleton 模式？
- [ ] 是否有 `new`/`delete`/`free`/`lv_obj_del` 调用？
- [ ] 控件是否在循环内创建？
- [ ] 页面切换时是否使用 `show()/hide()` 而不是创建/删除？
- [ ] 列表控件是否使用控件池？
- [ ] 网络请求是否使用 `HttpService`？
- [ ] 播放控制是否使用 `PlayerService`？
- [ ] 是否有跨线程直接操作 UI？
- [ ] 事件是否通过 `UiEventBus` 传递？

---

## 📚 相关文档

- **团队开发规范**：[团队开发规范v1.md](./团队开发规范v1.md)
- **服务层API设计**：[服务层API设计文档.md](./服务层API设计文档.md)
- **项目脚手架结构**：[项目脚手架结构.md](./项目脚手架结构.md)
- **技术基座**：[KTVLV技术基座（F133_Tina）.md](./KTVLV技术基座（F133_Tina）.md)

---

**最后更新**: 2025-12-30  
**状态**: ✅ 核心文档，资源管理规范



